{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createConditionalNode = void 0;\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _is = require(\"../../utils/is.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar _operators = require(\"../operators.js\");\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2[\"default\"])(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return (0, _possibleConstructorReturn2[\"default\"])(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar name = 'ConditionalNode';\nvar dependencies = ['Node'];\nvar createConditionalNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n  /**\n   * Test whether a condition is met\n   * @param {*} condition\n   * @returns {boolean} true if condition is true or non-zero, else false\n   */\n  function testCondition(condition) {\n    if (typeof condition === 'number' || typeof condition === 'boolean' || typeof condition === 'string') {\n      return !!condition;\n    }\n    if (condition) {\n      if ((0, _is.isBigNumber)(condition)) {\n        return !condition.isZero();\n      }\n      if ((0, _is.isComplex)(condition)) {\n        return !!(condition.re || condition.im);\n      }\n      if ((0, _is.isUnit)(condition)) {\n        return !!condition.value;\n      }\n    }\n    if (condition === null || condition === undefined) {\n      return false;\n    }\n    throw new TypeError('Unsupported type of condition \"' + (0, _is.typeOf)(condition) + '\"');\n  }\n  var ConditionalNode = /*#__PURE__*/function (_Node) {\n    (0, _inherits2[\"default\"])(ConditionalNode, _Node);\n    var _super = _createSuper(ConditionalNode);\n    /**\n     * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'\n     *\n     * @param {Node} condition   Condition, must result in a boolean\n     * @param {Node} trueExpr    Expression evaluated when condition is true\n     * @param {Node} falseExpr   Expression evaluated when condition is true\n     *\n     * @constructor ConditionalNode\n     * @extends {Node}\n     */\n    function ConditionalNode(condition, trueExpr, falseExpr) {\n      var _this;\n      (0, _classCallCheck2[\"default\"])(this, ConditionalNode);\n      _this = _super.call(this);\n      if (!(0, _is.isNode)(condition)) {\n        throw new TypeError('Parameter condition must be a Node');\n      }\n      if (!(0, _is.isNode)(trueExpr)) {\n        throw new TypeError('Parameter trueExpr must be a Node');\n      }\n      if (!(0, _is.isNode)(falseExpr)) {\n        throw new TypeError('Parameter falseExpr must be a Node');\n      }\n      _this.condition = condition;\n      _this.trueExpr = trueExpr;\n      _this.falseExpr = falseExpr;\n      return _this;\n    }\n    (0, _createClass2[\"default\"])(ConditionalNode, [{\n      key: \"type\",\n      get: function get() {\n        return name;\n      }\n    }, {\n      key: \"isConditionalNode\",\n      get: function get() {\n        return true;\n      }\n\n      /**\n       * Compile a node into a JavaScript function.\n       * This basically pre-calculates as much as possible and only leaves open\n       * calculations which depend on a dynamic scope with variables.\n       * @param {Object} math     Math.js namespace with functions and constants.\n       * @param {Object} argNames An object with argument names as key and `true`\n       *                          as value. Used in the SymbolNode to optimize\n       *                          for arguments from user assigned functions\n       *                          (see FunctionAssignmentNode) or special symbols\n       *                          like `end` (see IndexNode).\n       * @return {function} Returns a function which can be called like:\n       *                        evalNode(scope: Object, args: Object, context: *)\n       */\n    }, {\n      key: \"_compile\",\n      value: function _compile(math, argNames) {\n        var evalCondition = this.condition._compile(math, argNames);\n        var evalTrueExpr = this.trueExpr._compile(math, argNames);\n        var evalFalseExpr = this.falseExpr._compile(math, argNames);\n        return function evalConditionalNode(scope, args, context) {\n          return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);\n        };\n      }\n\n      /**\n       * Execute a callback for each of the child nodes of this node\n       * @param {function(child: Node, path: string, parent: Node)} callback\n       */\n    }, {\n      key: \"forEach\",\n      value: function forEach(callback) {\n        callback(this.condition, 'condition', this);\n        callback(this.trueExpr, 'trueExpr', this);\n        callback(this.falseExpr, 'falseExpr', this);\n      }\n\n      /**\n       * Create a new ConditionalNode whose children are the results of calling\n       * the provided callback function for each child of the original node.\n       * @param {function(child: Node, path: string, parent: Node): Node} callback\n       * @returns {ConditionalNode} Returns a transformed copy of the node\n       */\n    }, {\n      key: \"map\",\n      value: function map(callback) {\n        return new ConditionalNode(this._ifNode(callback(this.condition, 'condition', this)), this._ifNode(callback(this.trueExpr, 'trueExpr', this)), this._ifNode(callback(this.falseExpr, 'falseExpr', this)));\n      }\n\n      /**\n       * Create a clone of this node, a shallow copy\n       * @return {ConditionalNode}\n       */\n    }, {\n      key: \"clone\",\n      value: function clone() {\n        return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);\n      }\n\n      /**\n       * Get string representation\n       * @param {Object} options\n       * @return {string} str\n       */\n    }, {\n      key: \"_toString\",\n      value: function _toString(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var precedence = (0, _operators.getPrecedence)(this, parenthesis, options && options.implicit);\n\n        // Enclose Arguments in parentheses if they are an OperatorNode\n        // or have lower or equal precedence\n        // NOTE: enclosing all OperatorNodes in parentheses is a decision\n        // purely based on aesthetics and readability\n        var condition = this.condition.toString(options);\n        var conditionPrecedence = (0, _operators.getPrecedence)(this.condition, parenthesis, options && options.implicit);\n        if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n          condition = '(' + condition + ')';\n        }\n        var trueExpr = this.trueExpr.toString(options);\n        var truePrecedence = (0, _operators.getPrecedence)(this.trueExpr, parenthesis, options && options.implicit);\n        if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n          trueExpr = '(' + trueExpr + ')';\n        }\n        var falseExpr = this.falseExpr.toString(options);\n        var falsePrecedence = (0, _operators.getPrecedence)(this.falseExpr, parenthesis, options && options.implicit);\n        if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n          falseExpr = '(' + falseExpr + ')';\n        }\n        return condition + ' ? ' + trueExpr + ' : ' + falseExpr;\n      }\n\n      /**\n       * Get a JSON representation of the node\n       * @returns {Object}\n       */\n    }, {\n      key: \"toJSON\",\n      value: function toJSON() {\n        return {\n          mathjs: name,\n          condition: this.condition,\n          trueExpr: this.trueExpr,\n          falseExpr: this.falseExpr\n        };\n      }\n\n      /**\n       * Instantiate an ConditionalNode from its JSON representation\n       * @param {Object} json\n       *     An object structured like\n       *     ```\n       *     {\"mathjs\": \"ConditionalNode\",\n       *      \"condition\": ...,\n       *      \"trueExpr\": ...,\n       *      \"falseExpr\": ...}\n       *     ```\n       *     where mathjs is optional\n       * @returns {ConditionalNode}\n       */\n    }, {\n      key: \"toHTML\",\n      value:\n      /**\n       * Get HTML representation\n       * @param {Object} options\n       * @return {string} str\n       */\n      function toHTML(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var precedence = (0, _operators.getPrecedence)(this, parenthesis, options && options.implicit);\n\n        // Enclose Arguments in parentheses if they are an OperatorNode\n        // or have lower or equal precedence\n        // NOTE: enclosing all OperatorNodes in parentheses is a decision\n        // purely based on aesthetics and readability\n        var condition = this.condition.toHTML(options);\n        var conditionPrecedence = (0, _operators.getPrecedence)(this.condition, parenthesis, options && options.implicit);\n        if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n          condition = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + condition + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n        var trueExpr = this.trueExpr.toHTML(options);\n        var truePrecedence = (0, _operators.getPrecedence)(this.trueExpr, parenthesis, options && options.implicit);\n        if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n          trueExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + trueExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n        var falseExpr = this.falseExpr.toHTML(options);\n        var falsePrecedence = (0, _operators.getPrecedence)(this.falseExpr, parenthesis, options && options.implicit);\n        if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n          falseExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + falseExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n        return condition + '<span class=\"math-operator math-conditional-operator\">?</span>' + trueExpr + '<span class=\"math-operator math-conditional-operator\">:</span>' + falseExpr;\n      }\n\n      /**\n       * Get LaTeX representation\n       * @param {Object} options\n       * @return {string} str\n       */\n    }, {\n      key: \"_toTex\",\n      value: function _toTex(options) {\n        return '\\\\begin{cases} {' + this.trueExpr.toTex(options) + '}, &\\\\quad{\\\\text{if }\\\\;' + this.condition.toTex(options) + '}\\\\\\\\{' + this.falseExpr.toTex(options) + '}, &\\\\quad{\\\\text{otherwise}}\\\\end{cases}';\n      }\n    }], [{\n      key: \"fromJSON\",\n      value: function fromJSON(json) {\n        return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);\n      }\n    }]);\n    return ConditionalNode;\n  }(Node);\n  (0, _defineProperty2[\"default\"])(ConditionalNode, \"name\", name);\n  return ConditionalNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createConditionalNode = createConditionalNode;","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","createConditionalNode","_classCallCheck2","_createClass2","_inherits2","_possibleConstructorReturn2","_getPrototypeOf2","_defineProperty2","_is","_factory","_operators","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","constructor","Reflect","construct","arguments","apply","sham","Proxy","Boolean","prototype","valueOf","call","e","name","dependencies","factory","_ref","Node","testCondition","condition","isBigNumber","isZero","isComplex","re","im","isUnit","undefined","TypeError","typeOf","ConditionalNode","_Node","_super","trueExpr","falseExpr","_this","isNode","key","get","_compile","math","argNames","evalCondition","evalTrueExpr","evalFalseExpr","evalConditionalNode","scope","args","context","forEach","callback","map","_ifNode","clone","_toString","options","parenthesis","precedence","getPrecedence","implicit","toString","conditionPrecedence","type","truePrecedence","falsePrecedence","toJSON","mathjs","toHTML","_toTex","toTex","fromJSON","json","isClass"],"sources":["C:/Users/Admin/Desktop/React-Web-main/node_modules/mathjs/lib/cjs/expression/node/ConditionalNode.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createConditionalNode = void 0;\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _is = require(\"../../utils/is.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar _operators = require(\"../operators.js\");\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2[\"default\"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2[\"default\"])(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nvar name = 'ConditionalNode';\nvar dependencies = ['Node'];\nvar createConditionalNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n  /**\n   * Test whether a condition is met\n   * @param {*} condition\n   * @returns {boolean} true if condition is true or non-zero, else false\n   */\n  function testCondition(condition) {\n    if (typeof condition === 'number' || typeof condition === 'boolean' || typeof condition === 'string') {\n      return !!condition;\n    }\n    if (condition) {\n      if ((0, _is.isBigNumber)(condition)) {\n        return !condition.isZero();\n      }\n      if ((0, _is.isComplex)(condition)) {\n        return !!(condition.re || condition.im);\n      }\n      if ((0, _is.isUnit)(condition)) {\n        return !!condition.value;\n      }\n    }\n    if (condition === null || condition === undefined) {\n      return false;\n    }\n    throw new TypeError('Unsupported type of condition \"' + (0, _is.typeOf)(condition) + '\"');\n  }\n  var ConditionalNode = /*#__PURE__*/function (_Node) {\n    (0, _inherits2[\"default\"])(ConditionalNode, _Node);\n    var _super = _createSuper(ConditionalNode);\n    /**\n     * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'\n     *\n     * @param {Node} condition   Condition, must result in a boolean\n     * @param {Node} trueExpr    Expression evaluated when condition is true\n     * @param {Node} falseExpr   Expression evaluated when condition is true\n     *\n     * @constructor ConditionalNode\n     * @extends {Node}\n     */\n    function ConditionalNode(condition, trueExpr, falseExpr) {\n      var _this;\n      (0, _classCallCheck2[\"default\"])(this, ConditionalNode);\n      _this = _super.call(this);\n      if (!(0, _is.isNode)(condition)) {\n        throw new TypeError('Parameter condition must be a Node');\n      }\n      if (!(0, _is.isNode)(trueExpr)) {\n        throw new TypeError('Parameter trueExpr must be a Node');\n      }\n      if (!(0, _is.isNode)(falseExpr)) {\n        throw new TypeError('Parameter falseExpr must be a Node');\n      }\n      _this.condition = condition;\n      _this.trueExpr = trueExpr;\n      _this.falseExpr = falseExpr;\n      return _this;\n    }\n    (0, _createClass2[\"default\"])(ConditionalNode, [{\n      key: \"type\",\n      get: function get() {\n        return name;\n      }\n    }, {\n      key: \"isConditionalNode\",\n      get: function get() {\n        return true;\n      }\n\n      /**\n       * Compile a node into a JavaScript function.\n       * This basically pre-calculates as much as possible and only leaves open\n       * calculations which depend on a dynamic scope with variables.\n       * @param {Object} math     Math.js namespace with functions and constants.\n       * @param {Object} argNames An object with argument names as key and `true`\n       *                          as value. Used in the SymbolNode to optimize\n       *                          for arguments from user assigned functions\n       *                          (see FunctionAssignmentNode) or special symbols\n       *                          like `end` (see IndexNode).\n       * @return {function} Returns a function which can be called like:\n       *                        evalNode(scope: Object, args: Object, context: *)\n       */\n    }, {\n      key: \"_compile\",\n      value: function _compile(math, argNames) {\n        var evalCondition = this.condition._compile(math, argNames);\n        var evalTrueExpr = this.trueExpr._compile(math, argNames);\n        var evalFalseExpr = this.falseExpr._compile(math, argNames);\n        return function evalConditionalNode(scope, args, context) {\n          return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);\n        };\n      }\n\n      /**\n       * Execute a callback for each of the child nodes of this node\n       * @param {function(child: Node, path: string, parent: Node)} callback\n       */\n    }, {\n      key: \"forEach\",\n      value: function forEach(callback) {\n        callback(this.condition, 'condition', this);\n        callback(this.trueExpr, 'trueExpr', this);\n        callback(this.falseExpr, 'falseExpr', this);\n      }\n\n      /**\n       * Create a new ConditionalNode whose children are the results of calling\n       * the provided callback function for each child of the original node.\n       * @param {function(child: Node, path: string, parent: Node): Node} callback\n       * @returns {ConditionalNode} Returns a transformed copy of the node\n       */\n    }, {\n      key: \"map\",\n      value: function map(callback) {\n        return new ConditionalNode(this._ifNode(callback(this.condition, 'condition', this)), this._ifNode(callback(this.trueExpr, 'trueExpr', this)), this._ifNode(callback(this.falseExpr, 'falseExpr', this)));\n      }\n\n      /**\n       * Create a clone of this node, a shallow copy\n       * @return {ConditionalNode}\n       */\n    }, {\n      key: \"clone\",\n      value: function clone() {\n        return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);\n      }\n\n      /**\n       * Get string representation\n       * @param {Object} options\n       * @return {string} str\n       */\n    }, {\n      key: \"_toString\",\n      value: function _toString(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var precedence = (0, _operators.getPrecedence)(this, parenthesis, options && options.implicit);\n\n        // Enclose Arguments in parentheses if they are an OperatorNode\n        // or have lower or equal precedence\n        // NOTE: enclosing all OperatorNodes in parentheses is a decision\n        // purely based on aesthetics and readability\n        var condition = this.condition.toString(options);\n        var conditionPrecedence = (0, _operators.getPrecedence)(this.condition, parenthesis, options && options.implicit);\n        if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n          condition = '(' + condition + ')';\n        }\n        var trueExpr = this.trueExpr.toString(options);\n        var truePrecedence = (0, _operators.getPrecedence)(this.trueExpr, parenthesis, options && options.implicit);\n        if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n          trueExpr = '(' + trueExpr + ')';\n        }\n        var falseExpr = this.falseExpr.toString(options);\n        var falsePrecedence = (0, _operators.getPrecedence)(this.falseExpr, parenthesis, options && options.implicit);\n        if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n          falseExpr = '(' + falseExpr + ')';\n        }\n        return condition + ' ? ' + trueExpr + ' : ' + falseExpr;\n      }\n\n      /**\n       * Get a JSON representation of the node\n       * @returns {Object}\n       */\n    }, {\n      key: \"toJSON\",\n      value: function toJSON() {\n        return {\n          mathjs: name,\n          condition: this.condition,\n          trueExpr: this.trueExpr,\n          falseExpr: this.falseExpr\n        };\n      }\n\n      /**\n       * Instantiate an ConditionalNode from its JSON representation\n       * @param {Object} json\n       *     An object structured like\n       *     ```\n       *     {\"mathjs\": \"ConditionalNode\",\n       *      \"condition\": ...,\n       *      \"trueExpr\": ...,\n       *      \"falseExpr\": ...}\n       *     ```\n       *     where mathjs is optional\n       * @returns {ConditionalNode}\n       */\n    }, {\n      key: \"toHTML\",\n      value:\n      /**\n       * Get HTML representation\n       * @param {Object} options\n       * @return {string} str\n       */\n      function toHTML(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var precedence = (0, _operators.getPrecedence)(this, parenthesis, options && options.implicit);\n\n        // Enclose Arguments in parentheses if they are an OperatorNode\n        // or have lower or equal precedence\n        // NOTE: enclosing all OperatorNodes in parentheses is a decision\n        // purely based on aesthetics and readability\n        var condition = this.condition.toHTML(options);\n        var conditionPrecedence = (0, _operators.getPrecedence)(this.condition, parenthesis, options && options.implicit);\n        if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n          condition = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + condition + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n        var trueExpr = this.trueExpr.toHTML(options);\n        var truePrecedence = (0, _operators.getPrecedence)(this.trueExpr, parenthesis, options && options.implicit);\n        if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n          trueExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + trueExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n        var falseExpr = this.falseExpr.toHTML(options);\n        var falsePrecedence = (0, _operators.getPrecedence)(this.falseExpr, parenthesis, options && options.implicit);\n        if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n          falseExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + falseExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n        return condition + '<span class=\"math-operator math-conditional-operator\">?</span>' + trueExpr + '<span class=\"math-operator math-conditional-operator\">:</span>' + falseExpr;\n      }\n\n      /**\n       * Get LaTeX representation\n       * @param {Object} options\n       * @return {string} str\n       */\n    }, {\n      key: \"_toTex\",\n      value: function _toTex(options) {\n        return '\\\\begin{cases} {' + this.trueExpr.toTex(options) + '}, &\\\\quad{\\\\text{if }\\\\;' + this.condition.toTex(options) + '}\\\\\\\\{' + this.falseExpr.toTex(options) + '}, &\\\\quad{\\\\text{otherwise}}\\\\end{cases}';\n      }\n    }], [{\n      key: \"fromJSON\",\n      value: function fromJSON(json) {\n        return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);\n      }\n    }]);\n    return ConditionalNode;\n  }(Node);\n  (0, _defineProperty2[\"default\"])(ConditionalNode, \"name\", name);\n  return ConditionalNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createConditionalNode = createConditionalNode;"],"mappings":"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"},"metadata":{},"sourceType":"script"}