{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSymbolicEqual = void 0;\nvar _is = require(\"../../utils/is.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar name = 'symbolicEqual';\nvar dependencies = ['parse', 'simplify', 'typed', 'OperatorNode'];\nvar createSymbolicEqual = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var parse = _ref.parse,\n    simplify = _ref.simplify,\n    typed = _ref.typed,\n    OperatorNode = _ref.OperatorNode;\n  /**\n   * Attempts to determine if two expressions are symbolically equal, i.e.\n   * one is the result of valid algebraic manipulations on the other.\n   * Currently, this simply checks if the difference of the two expressions\n   * simplifies down to 0. So there are two important caveats:\n   * 1. whether two expressions are symbolically equal depends on the\n   *     manipulations allowed. Therefore, this function takes an optional\n   *     third argument, which are the options that control the behavior\n   *     as documented for the `simplify()` function.\n   * 2. it is in general intractable to find the minimal simplification of\n   *     an arbitrarily complicated expression. So while a `true` value\n   *     of `symbolicEqual` ensures that the two expressions can be manipulated\n   *     to match each other, a `false` value does not absolutely rule this out.\n   *\n   * Syntax:\n   *\n   *    symbolicEqual(expr1, expr2)\n   *    symbolicEqual(expr1, expr2, options)\n   *\n   * Examples:\n   *\n   *    symbolicEqual('x*y', 'y*x') // Returns true\n   *    symbolicEqual('x*y', 'y*x', {context: {multiply: {commutative: false}}}) // Returns false\n   *    symbolicEqual('x/y', '(y*x^(-1))^(-1)') // Returns true\n   *    symbolicEqual('abs(x)','x') // Returns false\n   *    symbolicEqual('abs(x)','x', simplify.positiveContext) // Returns true\n   *\n   * See also:\n   *\n   *    simplify, evaluate\n   *\n   * @param {Node|string} expr1  The first expression to compare\n   * @param {Node|string} expr2  The second expression to compare\n   * @param {Object} [options] Optional option object, passed to simplify\n   * @returns {boolean}\n   *     Returns true if a valid manipulation making the expressions equal\n   *     is found.\n   */\n  function _symbolicEqual(e1, e2) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var diff = new OperatorNode('-', 'subtract', [e1, e2]);\n    var simplified = simplify(diff, {}, options);\n    return (0, _is.isConstantNode)(simplified) && !simplified.value;\n  }\n  return typed(name, {\n    'Node, Node': _symbolicEqual,\n    'Node, Node, Object': _symbolicEqual\n  });\n});\nexports.createSymbolicEqual = createSymbolicEqual;","map":{"version":3,"names":["Object","defineProperty","exports","value","createSymbolicEqual","_is","require","_factory","name","dependencies","factory","_ref","parse","simplify","typed","OperatorNode","_symbolicEqual","e1","e2","options","arguments","length","undefined","diff","simplified","isConstantNode"],"sources":["C:/Users/Admin/Desktop/React-Web-main/node_modules/mathjs/lib/cjs/function/algebra/symbolicEqual.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSymbolicEqual = void 0;\nvar _is = require(\"../../utils/is.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar name = 'symbolicEqual';\nvar dependencies = ['parse', 'simplify', 'typed', 'OperatorNode'];\nvar createSymbolicEqual = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var parse = _ref.parse,\n    simplify = _ref.simplify,\n    typed = _ref.typed,\n    OperatorNode = _ref.OperatorNode;\n  /**\n   * Attempts to determine if two expressions are symbolically equal, i.e.\n   * one is the result of valid algebraic manipulations on the other.\n   * Currently, this simply checks if the difference of the two expressions\n   * simplifies down to 0. So there are two important caveats:\n   * 1. whether two expressions are symbolically equal depends on the\n   *     manipulations allowed. Therefore, this function takes an optional\n   *     third argument, which are the options that control the behavior\n   *     as documented for the `simplify()` function.\n   * 2. it is in general intractable to find the minimal simplification of\n   *     an arbitrarily complicated expression. So while a `true` value\n   *     of `symbolicEqual` ensures that the two expressions can be manipulated\n   *     to match each other, a `false` value does not absolutely rule this out.\n   *\n   * Syntax:\n   *\n   *    symbolicEqual(expr1, expr2)\n   *    symbolicEqual(expr1, expr2, options)\n   *\n   * Examples:\n   *\n   *    symbolicEqual('x*y', 'y*x') // Returns true\n   *    symbolicEqual('x*y', 'y*x', {context: {multiply: {commutative: false}}}) // Returns false\n   *    symbolicEqual('x/y', '(y*x^(-1))^(-1)') // Returns true\n   *    symbolicEqual('abs(x)','x') // Returns false\n   *    symbolicEqual('abs(x)','x', simplify.positiveContext) // Returns true\n   *\n   * See also:\n   *\n   *    simplify, evaluate\n   *\n   * @param {Node|string} expr1  The first expression to compare\n   * @param {Node|string} expr2  The second expression to compare\n   * @param {Object} [options] Optional option object, passed to simplify\n   * @returns {boolean}\n   *     Returns true if a valid manipulation making the expressions equal\n   *     is found.\n   */\n  function _symbolicEqual(e1, e2) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var diff = new OperatorNode('-', 'subtract', [e1, e2]);\n    var simplified = simplify(diff, {}, options);\n    return (0, _is.isConstantNode)(simplified) && !simplified.value;\n  }\n  return typed(name, {\n    'Node, Node': _symbolicEqual,\n    'Node, Node, Object': _symbolicEqual\n  });\n});\nexports.createSymbolicEqual = createSymbolicEqual;"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,mBAAmB,GAAG,KAAK,CAAC;AACpC,IAAIC,GAAG,GAAGC,OAAO,CAAC,mBAAmB,CAAC;AACtC,IAAIC,QAAQ,GAAGD,OAAO,CAAC,wBAAwB,CAAC;AAChD,IAAIE,IAAI,GAAG,eAAe;AAC1B,IAAIC,YAAY,GAAG,CAAC,OAAO,EAAE,UAAU,EAAE,OAAO,EAAE,cAAc,CAAC;AACjE,IAAIL,mBAAmB,GAAG,eAAe,CAAC,CAAC,EAAEG,QAAQ,CAACG,OAAO,EAAEF,IAAI,EAAEC,YAAY,EAAE,UAAUE,IAAI,EAAE;EACjG,IAAIC,KAAK,GAAGD,IAAI,CAACC,KAAK;IACpBC,QAAQ,GAAGF,IAAI,CAACE,QAAQ;IACxBC,KAAK,GAAGH,IAAI,CAACG,KAAK;IAClBC,YAAY,GAAGJ,IAAI,CAACI,YAAY;EAClC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASC,cAAc,CAACC,EAAE,EAAEC,EAAE,EAAE;IAC9B,IAAIC,OAAO,GAAGC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IACpF,IAAIG,IAAI,GAAG,IAAIR,YAAY,CAAC,GAAG,EAAE,UAAU,EAAE,CAACE,EAAE,EAAEC,EAAE,CAAC,CAAC;IACtD,IAAIM,UAAU,GAAGX,QAAQ,CAACU,IAAI,EAAE,CAAC,CAAC,EAAEJ,OAAO,CAAC;IAC5C,OAAO,CAAC,CAAC,EAAEd,GAAG,CAACoB,cAAc,EAAED,UAAU,CAAC,IAAI,CAACA,UAAU,CAACrB,KAAK;EACjE;EACA,OAAOW,KAAK,CAACN,IAAI,EAAE;IACjB,YAAY,EAAEQ,cAAc;IAC5B,oBAAoB,EAAEA;EACxB,CAAC,CAAC;AACJ,CAAC,CAAC;AACFd,OAAO,CAACE,mBAAmB,GAAGA,mBAAmB"},"metadata":{},"sourceType":"script"}