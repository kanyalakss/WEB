{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createOperatorNode = void 0;\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _is = require(\"../../utils/is.js\");\nvar _array = require(\"../../utils/array.js\");\nvar _string = require(\"../../utils/string.js\");\nvar _customs = require(\"../../utils/customs.js\");\nvar _operators = require(\"../operators.js\");\nvar _latex = require(\"../../utils/latex.js\");\nvar _factory = require(\"../../utils/factory.js\");\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2[\"default\"])(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return (0, _possibleConstructorReturn2[\"default\"])(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar name = 'OperatorNode';\nvar dependencies = ['Node'];\nvar createOperatorNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n  /**\n   * Returns true if the expression starts with a constant, under\n   * the current parenthesization:\n   * @param {Node} expression\n   * @param {string} parenthesis\n   * @return {boolean}\n   */\n  function startsWithConstant(expr, parenthesis) {\n    var curNode = expr;\n    if (parenthesis === 'auto') {\n      while ((0, _is.isParenthesisNode)(curNode)) {\n        curNode = curNode.content;\n      }\n    }\n    if ((0, _is.isConstantNode)(curNode)) return true;\n    if ((0, _is.isOperatorNode)(curNode)) {\n      return startsWithConstant(curNode.args[0], parenthesis);\n    }\n    return false;\n  }\n\n  /**\n   * Calculate which parentheses are necessary. Gets an OperatorNode\n   * (which is the root of the tree) and an Array of Nodes\n   * (this.args) and returns an array where 'true' means that an argument\n   * has to be enclosed in parentheses whereas 'false' means the opposite.\n   *\n   * @param {OperatorNode} root\n   * @param {string} parenthesis\n   * @param {Node[]} args\n   * @param {boolean} latex\n   * @return {boolean[]}\n   * @private\n   */\n  function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {\n    // precedence of the root OperatorNode\n    var precedence = (0, _operators.getPrecedence)(root, parenthesis, implicit);\n    var associativity = (0, _operators.getAssociativity)(root, parenthesis);\n    if (parenthesis === 'all' || args.length > 2 && root.getIdentifier() !== 'OperatorNode:add' && root.getIdentifier() !== 'OperatorNode:multiply') {\n      return args.map(function (arg) {\n        switch (arg.getContent().type) {\n          // Nodes that don't need extra parentheses\n          case 'ArrayNode':\n          case 'ConstantNode':\n          case 'SymbolNode':\n          case 'ParenthesisNode':\n            return false;\n          default:\n            return true;\n        }\n      });\n    }\n    var result;\n    switch (args.length) {\n      case 0:\n        result = [];\n        break;\n      case 1:\n        // unary operators\n        {\n          // precedence of the operand\n          var operandPrecedence = (0, _operators.getPrecedence)(args[0], parenthesis, implicit, root);\n\n          // handle special cases for LaTeX, where some of the parentheses aren't needed\n          if (latex && operandPrecedence !== null) {\n            var operandIdentifier;\n            var rootIdentifier;\n            if (parenthesis === 'keep') {\n              operandIdentifier = args[0].getIdentifier();\n              rootIdentifier = root.getIdentifier();\n            } else {\n              // Ignore Parenthesis Nodes when not in 'keep' mode\n              operandIdentifier = args[0].getContent().getIdentifier();\n              rootIdentifier = root.getContent().getIdentifier();\n            }\n            if (_operators.properties[precedence][rootIdentifier].latexLeftParens === false) {\n              result = [false];\n              break;\n            }\n            if (_operators.properties[operandPrecedence][operandIdentifier].latexParens === false) {\n              result = [false];\n              break;\n            }\n          }\n          if (operandPrecedence === null) {\n            // if the operand has no defined precedence, no parens are needed\n            result = [false];\n            break;\n          }\n          if (operandPrecedence <= precedence) {\n            // if the operands precedence is lower, parens are needed\n            result = [true];\n            break;\n          }\n\n          // otherwise, no parens needed\n          result = [false];\n        }\n        break;\n      case 2:\n        // binary operators\n        {\n          var lhsParens; // left hand side needs parenthesis?\n          // precedence of the left hand side\n          var lhsPrecedence = (0, _operators.getPrecedence)(args[0], parenthesis, implicit, root);\n          // is the root node associative with the left hand side\n          var assocWithLhs = (0, _operators.isAssociativeWith)(root, args[0], parenthesis);\n          if (lhsPrecedence === null) {\n            // if the left hand side has no defined precedence, no parens are needed\n            // FunctionNode for example\n            lhsParens = false;\n          } else if (lhsPrecedence === precedence && associativity === 'right' && !assocWithLhs) {\n            // In case of equal precedence, if the root node is left associative\n            // parens are **never** necessary for the left hand side.\n            // If it is right associative however, parens are necessary\n            // if the root node isn't associative with the left hand side\n            lhsParens = true;\n          } else if (lhsPrecedence < precedence) {\n            lhsParens = true;\n          } else {\n            lhsParens = false;\n          }\n          var rhsParens; // right hand side needs parenthesis?\n          // precedence of the right hand side\n          var rhsPrecedence = (0, _operators.getPrecedence)(args[1], parenthesis, implicit, root);\n          // is the root node associative with the right hand side?\n          var assocWithRhs = (0, _operators.isAssociativeWith)(root, args[1], parenthesis);\n          if (rhsPrecedence === null) {\n            // if the right hand side has no defined precedence, no parens are needed\n            // FunctionNode for example\n            rhsParens = false;\n          } else if (rhsPrecedence === precedence && associativity === 'left' && !assocWithRhs) {\n            // In case of equal precedence, if the root node is right associative\n            // parens are **never** necessary for the right hand side.\n            // If it is left associative however, parens are necessary\n            // if the root node isn't associative with the right hand side\n            rhsParens = true;\n          } else if (rhsPrecedence < precedence) {\n            rhsParens = true;\n          } else {\n            rhsParens = false;\n          }\n\n          // handle special cases for LaTeX, where some of the parentheses aren't needed\n          if (latex) {\n            var _rootIdentifier;\n            var lhsIdentifier;\n            var rhsIdentifier;\n            if (parenthesis === 'keep') {\n              _rootIdentifier = root.getIdentifier();\n              lhsIdentifier = root.args[0].getIdentifier();\n              rhsIdentifier = root.args[1].getIdentifier();\n            } else {\n              // Ignore ParenthesisNodes when not in 'keep' mode\n              _rootIdentifier = root.getContent().getIdentifier();\n              lhsIdentifier = root.args[0].getContent().getIdentifier();\n              rhsIdentifier = root.args[1].getContent().getIdentifier();\n            }\n            if (lhsPrecedence !== null) {\n              if (_operators.properties[precedence][_rootIdentifier].latexLeftParens === false) {\n                lhsParens = false;\n              }\n              if (_operators.properties[lhsPrecedence][lhsIdentifier].latexParens === false) {\n                lhsParens = false;\n              }\n            }\n            if (rhsPrecedence !== null) {\n              if (_operators.properties[precedence][_rootIdentifier].latexRightParens === false) {\n                rhsParens = false;\n              }\n              if (_operators.properties[rhsPrecedence][rhsIdentifier].latexParens === false) {\n                rhsParens = false;\n              }\n            }\n          }\n          result = [lhsParens, rhsParens];\n        }\n        break;\n      default:\n        if (root.getIdentifier() === 'OperatorNode:add' || root.getIdentifier() === 'OperatorNode:multiply') {\n          result = args.map(function (arg) {\n            var argPrecedence = (0, _operators.getPrecedence)(arg, parenthesis, implicit, root);\n            var assocWithArg = (0, _operators.isAssociativeWith)(root, arg, parenthesis);\n            var argAssociativity = (0, _operators.getAssociativity)(arg, parenthesis);\n            if (argPrecedence === null) {\n              // if the argument has no defined precedence, no parens are needed\n              return false;\n            } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {\n              return true;\n            } else if (argPrecedence < precedence) {\n              return true;\n            }\n            return false;\n          });\n        }\n        break;\n    }\n\n    // Handles an edge case of parentheses with implicit multiplication\n    // of ConstantNode.\n    // In that case, parenthesize ConstantNodes that follow an unparenthesized\n    // expression, even though they normally wouldn't be printed.\n    if (args.length >= 2 && root.getIdentifier() === 'OperatorNode:multiply' && root.implicit && parenthesis !== 'all' && implicit === 'hide') {\n      for (var i = 1; i < result.length; ++i) {\n        if (startsWithConstant(args[i], parenthesis) && !result[i - 1] && (parenthesis !== 'keep' || !(0, _is.isParenthesisNode)(args[i - 1]))) {\n          result[i] = true;\n        }\n      }\n    }\n    return result;\n  }\n  var OperatorNode = /*#__PURE__*/function (_Node) {\n    (0, _inherits2[\"default\"])(OperatorNode, _Node);\n    var _super = _createSuper(OperatorNode);\n    /**\n     * @constructor OperatorNode\n     * @extends {Node}\n     * An operator with two arguments, like 2+3\n     *\n     * @param {string} op           Operator name, for example '+'\n     * @param {string} fn           Function name, for example 'add'\n     * @param {Node[]} args         Operator arguments\n     * @param {boolean} [implicit]  Is this an implicit multiplication?\n     * @param {boolean} [isPercentage] Is this an percentage Operation?\n     */\n    function OperatorNode(op, fn, args, implicit, isPercentage) {\n      var _this;\n      (0, _classCallCheck2[\"default\"])(this, OperatorNode);\n      _this = _super.call(this);\n      // validate input\n      if (typeof op !== 'string') {\n        throw new TypeError('string expected for parameter \"op\"');\n      }\n      if (typeof fn !== 'string') {\n        throw new TypeError('string expected for parameter \"fn\"');\n      }\n      if (!Array.isArray(args) || !args.every(_is.isNode)) {\n        throw new TypeError('Array containing Nodes expected for parameter \"args\"');\n      }\n      _this.implicit = implicit === true;\n      _this.isPercentage = isPercentage === true;\n      _this.op = op;\n      _this.fn = fn;\n      _this.args = args || [];\n      return _this;\n    }\n    (0, _createClass2[\"default\"])(OperatorNode, [{\n      key: \"type\",\n      get: function get() {\n        return name;\n      }\n    }, {\n      key: \"isOperatorNode\",\n      get: function get() {\n        return true;\n      }\n\n      /**\n       * Compile a node into a JavaScript function.\n       * This basically pre-calculates as much as possible and only leaves open\n       * calculations which depend on a dynamic scope with variables.\n       * @param {Object} math     Math.js namespace with functions and constants.\n       * @param {Object} argNames An object with argument names as key and `true`\n       *                          as value. Used in the SymbolNode to optimize\n       *                          for arguments from user assigned functions\n       *                          (see FunctionAssignmentNode) or special symbols\n       *                          like `end` (see IndexNode).\n       * @return {function} Returns a function which can be called like:\n       *                        evalNode(scope: Object, args: Object, context: *)\n       */\n    }, {\n      key: \"_compile\",\n      value: function _compile(math, argNames) {\n        // validate fn\n        if (typeof this.fn !== 'string' || !(0, _customs.isSafeMethod)(math, this.fn)) {\n          if (!math[this.fn]) {\n            throw new Error('Function ' + this.fn + ' missing in provided namespace \"math\"');\n          } else {\n            throw new Error('No access to function \"' + this.fn + '\"');\n          }\n        }\n        var fn = (0, _customs.getSafeProperty)(math, this.fn);\n        var evalArgs = (0, _array.map)(this.args, function (arg) {\n          return arg._compile(math, argNames);\n        });\n        if (evalArgs.length === 1) {\n          var evalArg0 = evalArgs[0];\n          return function evalOperatorNode(scope, args, context) {\n            return fn(evalArg0(scope, args, context));\n          };\n        } else if (evalArgs.length === 2) {\n          var _evalArg = evalArgs[0];\n          var evalArg1 = evalArgs[1];\n          return function evalOperatorNode(scope, args, context) {\n            return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));\n          };\n        } else {\n          return function evalOperatorNode(scope, args, context) {\n            return fn.apply(null, (0, _array.map)(evalArgs, function (evalArg) {\n              return evalArg(scope, args, context);\n            }));\n          };\n        }\n      }\n\n      /**\n       * Execute a callback for each of the child nodes of this node\n       * @param {function(child: Node, path: string, parent: Node)} callback\n       */\n    }, {\n      key: \"forEach\",\n      value: function forEach(callback) {\n        for (var i = 0; i < this.args.length; i++) {\n          callback(this.args[i], 'args[' + i + ']', this);\n        }\n      }\n\n      /**\n       * Create a new OperatorNode whose children are the results of calling\n       * the provided callback function for each child of the original node.\n       * @param {function(child: Node, path: string, parent: Node): Node} callback\n       * @returns {OperatorNode} Returns a transformed copy of the node\n       */\n    }, {\n      key: \"map\",\n      value: function map(callback) {\n        var args = [];\n        for (var i = 0; i < this.args.length; i++) {\n          args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));\n        }\n        return new OperatorNode(this.op, this.fn, args, this.implicit, this.isPercentage);\n      }\n\n      /**\n       * Create a clone of this node, a shallow copy\n       * @return {OperatorNode}\n       */\n    }, {\n      key: \"clone\",\n      value: function clone() {\n        return new OperatorNode(this.op, this.fn, this.args.slice(0), this.implicit, this.isPercentage);\n      }\n\n      /**\n       * Check whether this is an unary OperatorNode:\n       * has exactly one argument, like `-a`.\n       * @return {boolean}\n       *     Returns true when an unary operator node, false otherwise.\n       */\n    }, {\n      key: \"isUnary\",\n      value: function isUnary() {\n        return this.args.length === 1;\n      }\n\n      /**\n       * Check whether this is a binary OperatorNode:\n       * has exactly two arguments, like `a + b`.\n       * @return {boolean}\n       *     Returns true when a binary operator node, false otherwise.\n       */\n    }, {\n      key: \"isBinary\",\n      value: function isBinary() {\n        return this.args.length === 2;\n      }\n\n      /**\n       * Get string representation.\n       * @param {Object} options\n       * @return {string} str\n       */\n    }, {\n      key: \"_toString\",\n      value: function _toString(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var implicit = options && options.implicit ? options.implicit : 'hide';\n        var args = this.args;\n        var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n        if (args.length === 1) {\n          // unary operators\n          var assoc = (0, _operators.getAssociativity)(this, parenthesis);\n          var operand = args[0].toString(options);\n          if (parens[0]) {\n            operand = '(' + operand + ')';\n          }\n\n          // for example for \"not\", we want a space between operand and argument\n          var opIsNamed = /[a-zA-Z]+/.test(this.op);\n          if (assoc === 'right') {\n            // prefix operator\n            return this.op + (opIsNamed ? ' ' : '') + operand;\n          } else if (assoc === 'left') {\n            // postfix\n            return operand + (opIsNamed ? ' ' : '') + this.op;\n          }\n\n          // fall back to postfix\n          return operand + this.op;\n        } else if (args.length === 2) {\n          var lhs = args[0].toString(options); // left hand side\n          var rhs = args[1].toString(options); // right hand side\n          if (parens[0]) {\n            // left hand side in parenthesis?\n            lhs = '(' + lhs + ')';\n          }\n          if (parens[1]) {\n            // right hand side in parenthesis?\n            rhs = '(' + rhs + ')';\n          }\n          if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n            return lhs + ' ' + rhs;\n          }\n          return lhs + ' ' + this.op + ' ' + rhs;\n        } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n          var stringifiedArgs = args.map(function (arg, index) {\n            arg = arg.toString(options);\n            if (parens[index]) {\n              // put in parenthesis?\n              arg = '(' + arg + ')';\n            }\n            return arg;\n          });\n          if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n            return stringifiedArgs.join(' ');\n          }\n          return stringifiedArgs.join(' ' + this.op + ' ');\n        } else {\n          // fallback to formatting as a function call\n          return this.fn + '(' + this.args.join(', ') + ')';\n        }\n      }\n\n      /**\n       * Get a JSON representation of the node\n       * @returns {Object}\n       */\n    }, {\n      key: \"toJSON\",\n      value: function toJSON() {\n        return {\n          mathjs: name,\n          op: this.op,\n          fn: this.fn,\n          args: this.args,\n          implicit: this.implicit,\n          isPercentage: this.isPercentage\n        };\n      }\n\n      /**\n       * Instantiate an OperatorNode from its JSON representation\n       * @param {Object} json\n       *     An object structured like\n       *     ```\n       *     {\"mathjs\": \"OperatorNode\",\n       *      \"op\": \"+\", \"fn\": \"add\", \"args\": [...],\n       *      \"implicit\": false,\n       *      \"isPercentage\":false}\n       *     ```\n       *     where mathjs is optional\n       * @returns {OperatorNode}\n       */\n    }, {\n      key: \"toHTML\",\n      value:\n      /**\n       * Get HTML representation.\n       * @param {Object} options\n       * @return {string} str\n       */\n      function toHTML(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var implicit = options && options.implicit ? options.implicit : 'hide';\n        var args = this.args;\n        var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n        if (args.length === 1) {\n          // unary operators\n          var assoc = (0, _operators.getAssociativity)(this, parenthesis);\n          var operand = args[0].toHTML(options);\n          if (parens[0]) {\n            operand = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + operand + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n          }\n          if (assoc === 'right') {\n            // prefix operator\n            return '<span class=\"math-operator math-unary-operator ' + 'math-lefthand-unary-operator\">' + (0, _string.escape)(this.op) + '</span>' + operand;\n          } else {\n            // postfix when assoc === 'left' or undefined\n            return operand + '<span class=\"math-operator math-unary-operator ' + 'math-righthand-unary-operator\">' + (0, _string.escape)(this.op) + '</span>';\n          }\n        } else if (args.length === 2) {\n          // binary operatoes\n          var lhs = args[0].toHTML(options); // left hand side\n          var rhs = args[1].toHTML(options); // right hand side\n          if (parens[0]) {\n            // left hand side in parenthesis?\n            lhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + lhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n          }\n          if (parens[1]) {\n            // right hand side in parenthesis?\n            rhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + rhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n          }\n          if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n            return lhs + '<span class=\"math-operator math-binary-operator ' + 'math-implicit-binary-operator\"></span>' + rhs;\n          }\n          return lhs + '<span class=\"math-operator math-binary-operator ' + 'math-explicit-binary-operator\">' + (0, _string.escape)(this.op) + '</span>' + rhs;\n        } else {\n          var stringifiedArgs = args.map(function (arg, index) {\n            arg = arg.toHTML(options);\n            if (parens[index]) {\n              // put in parenthesis?\n              arg = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + arg + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n            }\n            return arg;\n          });\n          if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n            if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n              return stringifiedArgs.join('<span class=\"math-operator math-binary-operator ' + 'math-implicit-binary-operator\"></span>');\n            }\n            return stringifiedArgs.join('<span class=\"math-operator math-binary-operator ' + 'math-explicit-binary-operator\">' + (0, _string.escape)(this.op) + '</span>');\n          } else {\n            // fallback to formatting as a function call\n            return '<span class=\"math-function\">' + (0, _string.escape)(this.fn) + '</span><span class=\"math-paranthesis math-round-parenthesis\">' + '(</span>' + stringifiedArgs.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-paranthesis math-round-parenthesis\">)</span>';\n          }\n        }\n      }\n\n      /**\n       * Get LaTeX representation\n       * @param {Object} options\n       * @return {string} str\n       */\n    }, {\n      key: \"_toTex\",\n      value: function _toTex(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var implicit = options && options.implicit ? options.implicit : 'hide';\n        var args = this.args;\n        var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);\n        var op = _latex.latexOperators[this.fn];\n        op = typeof op === 'undefined' ? this.op : op; // fall back to using this.op\n\n        if (args.length === 1) {\n          // unary operators\n          var assoc = (0, _operators.getAssociativity)(this, parenthesis);\n          var operand = args[0].toTex(options);\n          if (parens[0]) {\n            operand = \"\\\\left(\".concat(operand, \"\\\\right)\");\n          }\n          if (assoc === 'right') {\n            // prefix operator\n            return op + operand;\n          } else if (assoc === 'left') {\n            // postfix operator\n            return operand + op;\n          }\n\n          // fall back to postfix\n          return operand + op;\n        } else if (args.length === 2) {\n          // binary operators\n          var lhs = args[0]; // left hand side\n          var lhsTex = lhs.toTex(options);\n          if (parens[0]) {\n            lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n          }\n          var rhs = args[1]; // right hand side\n          var rhsTex = rhs.toTex(options);\n          if (parens[1]) {\n            rhsTex = \"\\\\left(\".concat(rhsTex, \"\\\\right)\");\n          }\n\n          // handle some exceptions (due to the way LaTeX works)\n          var lhsIdentifier;\n          if (parenthesis === 'keep') {\n            lhsIdentifier = lhs.getIdentifier();\n          } else {\n            // Ignore ParenthesisNodes if in 'keep' mode\n            lhsIdentifier = lhs.getContent().getIdentifier();\n          }\n          switch (this.getIdentifier()) {\n            case 'OperatorNode:divide':\n              // op contains '\\\\frac' at this point\n              return op + '{' + lhsTex + '}' + '{' + rhsTex + '}';\n            case 'OperatorNode:pow':\n              lhsTex = '{' + lhsTex + '}';\n              rhsTex = '{' + rhsTex + '}';\n              switch (lhsIdentifier) {\n                case 'ConditionalNode': //\n                case 'OperatorNode:divide':\n                  lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n              }\n              break;\n            case 'OperatorNode:multiply':\n              if (this.implicit && implicit === 'hide') {\n                return lhsTex + '~' + rhsTex;\n              }\n          }\n          return lhsTex + op + rhsTex;\n        } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n          var texifiedArgs = args.map(function (arg, index) {\n            arg = arg.toTex(options);\n            if (parens[index]) {\n              arg = \"\\\\left(\".concat(arg, \"\\\\right)\");\n            }\n            return arg;\n          });\n          if (this.getIdentifier() === 'OperatorNode:multiply' && this.implicit && implicit === 'hide') {\n            return texifiedArgs.join('~');\n          }\n          return texifiedArgs.join(op);\n        } else {\n          // fall back to formatting as a function call\n          // as this is a fallback, it doesn't use\n          // fancy function names\n          return '\\\\mathrm{' + this.fn + '}\\\\left(' + args.map(function (arg) {\n            return arg.toTex(options);\n          }).join(',') + '\\\\right)';\n        }\n      }\n\n      /**\n       * Get identifier.\n       * @return {string}\n       */\n    }, {\n      key: \"getIdentifier\",\n      value: function getIdentifier() {\n        return this.type + ':' + this.fn;\n      }\n    }], [{\n      key: \"fromJSON\",\n      value: function fromJSON(json) {\n        return new OperatorNode(json.op, json.fn, json.args, json.implicit, json.isPercentage);\n      }\n    }]);\n    return OperatorNode;\n  }(Node);\n  (0, _defineProperty2[\"default\"])(OperatorNode, \"name\", name);\n  return OperatorNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createOperatorNode = createOperatorNode;","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","createOperatorNode","_classCallCheck2","_createClass2","_inherits2","_possibleConstructorReturn2","_getPrototypeOf2","_defineProperty2","_is","_array","_string","_customs","_operators","_latex","_factory","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","constructor","Reflect","construct","arguments","apply","sham","Proxy","Boolean","prototype","valueOf","call","e","name","dependencies","factory","_ref","Node","startsWithConstant","expr","parenthesis","curNode","isParenthesisNode","content","isConstantNode","isOperatorNode","args","calculateNecessaryParentheses","root","implicit","latex","precedence","getPrecedence","associativity","getAssociativity","length","getIdentifier","map","arg","getContent","type","operandPrecedence","operandIdentifier","rootIdentifier","properties","latexLeftParens","latexParens","lhsParens","lhsPrecedence","assocWithLhs","isAssociativeWith","rhsParens","rhsPrecedence","assocWithRhs","_rootIdentifier","lhsIdentifier","rhsIdentifier","latexRightParens","argPrecedence","assocWithArg","argAssociativity","i","OperatorNode","_Node","_super","op","fn","isPercentage","_this","TypeError","Array","isArray","every","isNode","key","get","_compile","math","argNames","isSafeMethod","Error","getSafeProperty","evalArgs","evalArg0","evalOperatorNode","scope","context","_evalArg","evalArg1","evalArg","forEach","callback","_ifNode","clone","slice","isUnary","isBinary","_toString","options","parens","assoc","operand","toString","opIsNamed","test","lhs","rhs","stringifiedArgs","index","join","toJSON","mathjs","toHTML","escape","_toTex","latexOperators","toTex","concat","lhsTex","rhsTex","texifiedArgs","fromJSON","json","isClass"],"sources":["C:/Users/Admin/Desktop/React-Web-main/node_modules/mathjs/lib/cjs/expression/node/OperatorNode.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createOperatorNode = void 0;\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _is = require(\"../../utils/is.js\");\nvar _array = require(\"../../utils/array.js\");\nvar _string = require(\"../../utils/string.js\");\nvar _customs = require(\"../../utils/customs.js\");\nvar _operators = require(\"../operators.js\");\nvar _latex = require(\"../../utils/latex.js\");\nvar _factory = require(\"../../utils/factory.js\");\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2[\"default\"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2[\"default\"])(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nvar name = 'OperatorNode';\nvar dependencies = ['Node'];\nvar createOperatorNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n  /**\n   * Returns true if the expression starts with a constant, under\n   * the current parenthesization:\n   * @param {Node} expression\n   * @param {string} parenthesis\n   * @return {boolean}\n   */\n  function startsWithConstant(expr, parenthesis) {\n    var curNode = expr;\n    if (parenthesis === 'auto') {\n      while ((0, _is.isParenthesisNode)(curNode)) {\n        curNode = curNode.content;\n      }\n    }\n    if ((0, _is.isConstantNode)(curNode)) return true;\n    if ((0, _is.isOperatorNode)(curNode)) {\n      return startsWithConstant(curNode.args[0], parenthesis);\n    }\n    return false;\n  }\n\n  /**\n   * Calculate which parentheses are necessary. Gets an OperatorNode\n   * (which is the root of the tree) and an Array of Nodes\n   * (this.args) and returns an array where 'true' means that an argument\n   * has to be enclosed in parentheses whereas 'false' means the opposite.\n   *\n   * @param {OperatorNode} root\n   * @param {string} parenthesis\n   * @param {Node[]} args\n   * @param {boolean} latex\n   * @return {boolean[]}\n   * @private\n   */\n  function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {\n    // precedence of the root OperatorNode\n    var precedence = (0, _operators.getPrecedence)(root, parenthesis, implicit);\n    var associativity = (0, _operators.getAssociativity)(root, parenthesis);\n    if (parenthesis === 'all' || args.length > 2 && root.getIdentifier() !== 'OperatorNode:add' && root.getIdentifier() !== 'OperatorNode:multiply') {\n      return args.map(function (arg) {\n        switch (arg.getContent().type) {\n          // Nodes that don't need extra parentheses\n          case 'ArrayNode':\n          case 'ConstantNode':\n          case 'SymbolNode':\n          case 'ParenthesisNode':\n            return false;\n          default:\n            return true;\n        }\n      });\n    }\n    var result;\n    switch (args.length) {\n      case 0:\n        result = [];\n        break;\n      case 1:\n        // unary operators\n        {\n          // precedence of the operand\n          var operandPrecedence = (0, _operators.getPrecedence)(args[0], parenthesis, implicit, root);\n\n          // handle special cases for LaTeX, where some of the parentheses aren't needed\n          if (latex && operandPrecedence !== null) {\n            var operandIdentifier;\n            var rootIdentifier;\n            if (parenthesis === 'keep') {\n              operandIdentifier = args[0].getIdentifier();\n              rootIdentifier = root.getIdentifier();\n            } else {\n              // Ignore Parenthesis Nodes when not in 'keep' mode\n              operandIdentifier = args[0].getContent().getIdentifier();\n              rootIdentifier = root.getContent().getIdentifier();\n            }\n            if (_operators.properties[precedence][rootIdentifier].latexLeftParens === false) {\n              result = [false];\n              break;\n            }\n            if (_operators.properties[operandPrecedence][operandIdentifier].latexParens === false) {\n              result = [false];\n              break;\n            }\n          }\n          if (operandPrecedence === null) {\n            // if the operand has no defined precedence, no parens are needed\n            result = [false];\n            break;\n          }\n          if (operandPrecedence <= precedence) {\n            // if the operands precedence is lower, parens are needed\n            result = [true];\n            break;\n          }\n\n          // otherwise, no parens needed\n          result = [false];\n        }\n        break;\n      case 2:\n        // binary operators\n        {\n          var lhsParens; // left hand side needs parenthesis?\n          // precedence of the left hand side\n          var lhsPrecedence = (0, _operators.getPrecedence)(args[0], parenthesis, implicit, root);\n          // is the root node associative with the left hand side\n          var assocWithLhs = (0, _operators.isAssociativeWith)(root, args[0], parenthesis);\n          if (lhsPrecedence === null) {\n            // if the left hand side has no defined precedence, no parens are needed\n            // FunctionNode for example\n            lhsParens = false;\n          } else if (lhsPrecedence === precedence && associativity === 'right' && !assocWithLhs) {\n            // In case of equal precedence, if the root node is left associative\n            // parens are **never** necessary for the left hand side.\n            // If it is right associative however, parens are necessary\n            // if the root node isn't associative with the left hand side\n            lhsParens = true;\n          } else if (lhsPrecedence < precedence) {\n            lhsParens = true;\n          } else {\n            lhsParens = false;\n          }\n          var rhsParens; // right hand side needs parenthesis?\n          // precedence of the right hand side\n          var rhsPrecedence = (0, _operators.getPrecedence)(args[1], parenthesis, implicit, root);\n          // is the root node associative with the right hand side?\n          var assocWithRhs = (0, _operators.isAssociativeWith)(root, args[1], parenthesis);\n          if (rhsPrecedence === null) {\n            // if the right hand side has no defined precedence, no parens are needed\n            // FunctionNode for example\n            rhsParens = false;\n          } else if (rhsPrecedence === precedence && associativity === 'left' && !assocWithRhs) {\n            // In case of equal precedence, if the root node is right associative\n            // parens are **never** necessary for the right hand side.\n            // If it is left associative however, parens are necessary\n            // if the root node isn't associative with the right hand side\n            rhsParens = true;\n          } else if (rhsPrecedence < precedence) {\n            rhsParens = true;\n          } else {\n            rhsParens = false;\n          }\n\n          // handle special cases for LaTeX, where some of the parentheses aren't needed\n          if (latex) {\n            var _rootIdentifier;\n            var lhsIdentifier;\n            var rhsIdentifier;\n            if (parenthesis === 'keep') {\n              _rootIdentifier = root.getIdentifier();\n              lhsIdentifier = root.args[0].getIdentifier();\n              rhsIdentifier = root.args[1].getIdentifier();\n            } else {\n              // Ignore ParenthesisNodes when not in 'keep' mode\n              _rootIdentifier = root.getContent().getIdentifier();\n              lhsIdentifier = root.args[0].getContent().getIdentifier();\n              rhsIdentifier = root.args[1].getContent().getIdentifier();\n            }\n            if (lhsPrecedence !== null) {\n              if (_operators.properties[precedence][_rootIdentifier].latexLeftParens === false) {\n                lhsParens = false;\n              }\n              if (_operators.properties[lhsPrecedence][lhsIdentifier].latexParens === false) {\n                lhsParens = false;\n              }\n            }\n            if (rhsPrecedence !== null) {\n              if (_operators.properties[precedence][_rootIdentifier].latexRightParens === false) {\n                rhsParens = false;\n              }\n              if (_operators.properties[rhsPrecedence][rhsIdentifier].latexParens === false) {\n                rhsParens = false;\n              }\n            }\n          }\n          result = [lhsParens, rhsParens];\n        }\n        break;\n      default:\n        if (root.getIdentifier() === 'OperatorNode:add' || root.getIdentifier() === 'OperatorNode:multiply') {\n          result = args.map(function (arg) {\n            var argPrecedence = (0, _operators.getPrecedence)(arg, parenthesis, implicit, root);\n            var assocWithArg = (0, _operators.isAssociativeWith)(root, arg, parenthesis);\n            var argAssociativity = (0, _operators.getAssociativity)(arg, parenthesis);\n            if (argPrecedence === null) {\n              // if the argument has no defined precedence, no parens are needed\n              return false;\n            } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {\n              return true;\n            } else if (argPrecedence < precedence) {\n              return true;\n            }\n            return false;\n          });\n        }\n        break;\n    }\n\n    // Handles an edge case of parentheses with implicit multiplication\n    // of ConstantNode.\n    // In that case, parenthesize ConstantNodes that follow an unparenthesized\n    // expression, even though they normally wouldn't be printed.\n    if (args.length >= 2 && root.getIdentifier() === 'OperatorNode:multiply' && root.implicit && parenthesis !== 'all' && implicit === 'hide') {\n      for (var i = 1; i < result.length; ++i) {\n        if (startsWithConstant(args[i], parenthesis) && !result[i - 1] && (parenthesis !== 'keep' || !(0, _is.isParenthesisNode)(args[i - 1]))) {\n          result[i] = true;\n        }\n      }\n    }\n    return result;\n  }\n  var OperatorNode = /*#__PURE__*/function (_Node) {\n    (0, _inherits2[\"default\"])(OperatorNode, _Node);\n    var _super = _createSuper(OperatorNode);\n    /**\n     * @constructor OperatorNode\n     * @extends {Node}\n     * An operator with two arguments, like 2+3\n     *\n     * @param {string} op           Operator name, for example '+'\n     * @param {string} fn           Function name, for example 'add'\n     * @param {Node[]} args         Operator arguments\n     * @param {boolean} [implicit]  Is this an implicit multiplication?\n     * @param {boolean} [isPercentage] Is this an percentage Operation?\n     */\n    function OperatorNode(op, fn, args, implicit, isPercentage) {\n      var _this;\n      (0, _classCallCheck2[\"default\"])(this, OperatorNode);\n      _this = _super.call(this);\n      // validate input\n      if (typeof op !== 'string') {\n        throw new TypeError('string expected for parameter \"op\"');\n      }\n      if (typeof fn !== 'string') {\n        throw new TypeError('string expected for parameter \"fn\"');\n      }\n      if (!Array.isArray(args) || !args.every(_is.isNode)) {\n        throw new TypeError('Array containing Nodes expected for parameter \"args\"');\n      }\n      _this.implicit = implicit === true;\n      _this.isPercentage = isPercentage === true;\n      _this.op = op;\n      _this.fn = fn;\n      _this.args = args || [];\n      return _this;\n    }\n    (0, _createClass2[\"default\"])(OperatorNode, [{\n      key: \"type\",\n      get: function get() {\n        return name;\n      }\n    }, {\n      key: \"isOperatorNode\",\n      get: function get() {\n        return true;\n      }\n\n      /**\n       * Compile a node into a JavaScript function.\n       * This basically pre-calculates as much as possible and only leaves open\n       * calculations which depend on a dynamic scope with variables.\n       * @param {Object} math     Math.js namespace with functions and constants.\n       * @param {Object} argNames An object with argument names as key and `true`\n       *                          as value. Used in the SymbolNode to optimize\n       *                          for arguments from user assigned functions\n       *                          (see FunctionAssignmentNode) or special symbols\n       *                          like `end` (see IndexNode).\n       * @return {function} Returns a function which can be called like:\n       *                        evalNode(scope: Object, args: Object, context: *)\n       */\n    }, {\n      key: \"_compile\",\n      value: function _compile(math, argNames) {\n        // validate fn\n        if (typeof this.fn !== 'string' || !(0, _customs.isSafeMethod)(math, this.fn)) {\n          if (!math[this.fn]) {\n            throw new Error('Function ' + this.fn + ' missing in provided namespace \"math\"');\n          } else {\n            throw new Error('No access to function \"' + this.fn + '\"');\n          }\n        }\n        var fn = (0, _customs.getSafeProperty)(math, this.fn);\n        var evalArgs = (0, _array.map)(this.args, function (arg) {\n          return arg._compile(math, argNames);\n        });\n        if (evalArgs.length === 1) {\n          var evalArg0 = evalArgs[0];\n          return function evalOperatorNode(scope, args, context) {\n            return fn(evalArg0(scope, args, context));\n          };\n        } else if (evalArgs.length === 2) {\n          var _evalArg = evalArgs[0];\n          var evalArg1 = evalArgs[1];\n          return function evalOperatorNode(scope, args, context) {\n            return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));\n          };\n        } else {\n          return function evalOperatorNode(scope, args, context) {\n            return fn.apply(null, (0, _array.map)(evalArgs, function (evalArg) {\n              return evalArg(scope, args, context);\n            }));\n          };\n        }\n      }\n\n      /**\n       * Execute a callback for each of the child nodes of this node\n       * @param {function(child: Node, path: string, parent: Node)} callback\n       */\n    }, {\n      key: \"forEach\",\n      value: function forEach(callback) {\n        for (var i = 0; i < this.args.length; i++) {\n          callback(this.args[i], 'args[' + i + ']', this);\n        }\n      }\n\n      /**\n       * Create a new OperatorNode whose children are the results of calling\n       * the provided callback function for each child of the original node.\n       * @param {function(child: Node, path: string, parent: Node): Node} callback\n       * @returns {OperatorNode} Returns a transformed copy of the node\n       */\n    }, {\n      key: \"map\",\n      value: function map(callback) {\n        var args = [];\n        for (var i = 0; i < this.args.length; i++) {\n          args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));\n        }\n        return new OperatorNode(this.op, this.fn, args, this.implicit, this.isPercentage);\n      }\n\n      /**\n       * Create a clone of this node, a shallow copy\n       * @return {OperatorNode}\n       */\n    }, {\n      key: \"clone\",\n      value: function clone() {\n        return new OperatorNode(this.op, this.fn, this.args.slice(0), this.implicit, this.isPercentage);\n      }\n\n      /**\n       * Check whether this is an unary OperatorNode:\n       * has exactly one argument, like `-a`.\n       * @return {boolean}\n       *     Returns true when an unary operator node, false otherwise.\n       */\n    }, {\n      key: \"isUnary\",\n      value: function isUnary() {\n        return this.args.length === 1;\n      }\n\n      /**\n       * Check whether this is a binary OperatorNode:\n       * has exactly two arguments, like `a + b`.\n       * @return {boolean}\n       *     Returns true when a binary operator node, false otherwise.\n       */\n    }, {\n      key: \"isBinary\",\n      value: function isBinary() {\n        return this.args.length === 2;\n      }\n\n      /**\n       * Get string representation.\n       * @param {Object} options\n       * @return {string} str\n       */\n    }, {\n      key: \"_toString\",\n      value: function _toString(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var implicit = options && options.implicit ? options.implicit : 'hide';\n        var args = this.args;\n        var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n        if (args.length === 1) {\n          // unary operators\n          var assoc = (0, _operators.getAssociativity)(this, parenthesis);\n          var operand = args[0].toString(options);\n          if (parens[0]) {\n            operand = '(' + operand + ')';\n          }\n\n          // for example for \"not\", we want a space between operand and argument\n          var opIsNamed = /[a-zA-Z]+/.test(this.op);\n          if (assoc === 'right') {\n            // prefix operator\n            return this.op + (opIsNamed ? ' ' : '') + operand;\n          } else if (assoc === 'left') {\n            // postfix\n            return operand + (opIsNamed ? ' ' : '') + this.op;\n          }\n\n          // fall back to postfix\n          return operand + this.op;\n        } else if (args.length === 2) {\n          var lhs = args[0].toString(options); // left hand side\n          var rhs = args[1].toString(options); // right hand side\n          if (parens[0]) {\n            // left hand side in parenthesis?\n            lhs = '(' + lhs + ')';\n          }\n          if (parens[1]) {\n            // right hand side in parenthesis?\n            rhs = '(' + rhs + ')';\n          }\n          if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n            return lhs + ' ' + rhs;\n          }\n          return lhs + ' ' + this.op + ' ' + rhs;\n        } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n          var stringifiedArgs = args.map(function (arg, index) {\n            arg = arg.toString(options);\n            if (parens[index]) {\n              // put in parenthesis?\n              arg = '(' + arg + ')';\n            }\n            return arg;\n          });\n          if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n            return stringifiedArgs.join(' ');\n          }\n          return stringifiedArgs.join(' ' + this.op + ' ');\n        } else {\n          // fallback to formatting as a function call\n          return this.fn + '(' + this.args.join(', ') + ')';\n        }\n      }\n\n      /**\n       * Get a JSON representation of the node\n       * @returns {Object}\n       */\n    }, {\n      key: \"toJSON\",\n      value: function toJSON() {\n        return {\n          mathjs: name,\n          op: this.op,\n          fn: this.fn,\n          args: this.args,\n          implicit: this.implicit,\n          isPercentage: this.isPercentage\n        };\n      }\n\n      /**\n       * Instantiate an OperatorNode from its JSON representation\n       * @param {Object} json\n       *     An object structured like\n       *     ```\n       *     {\"mathjs\": \"OperatorNode\",\n       *      \"op\": \"+\", \"fn\": \"add\", \"args\": [...],\n       *      \"implicit\": false,\n       *      \"isPercentage\":false}\n       *     ```\n       *     where mathjs is optional\n       * @returns {OperatorNode}\n       */\n    }, {\n      key: \"toHTML\",\n      value:\n      /**\n       * Get HTML representation.\n       * @param {Object} options\n       * @return {string} str\n       */\n      function toHTML(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var implicit = options && options.implicit ? options.implicit : 'hide';\n        var args = this.args;\n        var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n        if (args.length === 1) {\n          // unary operators\n          var assoc = (0, _operators.getAssociativity)(this, parenthesis);\n          var operand = args[0].toHTML(options);\n          if (parens[0]) {\n            operand = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + operand + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n          }\n          if (assoc === 'right') {\n            // prefix operator\n            return '<span class=\"math-operator math-unary-operator ' + 'math-lefthand-unary-operator\">' + (0, _string.escape)(this.op) + '</span>' + operand;\n          } else {\n            // postfix when assoc === 'left' or undefined\n            return operand + '<span class=\"math-operator math-unary-operator ' + 'math-righthand-unary-operator\">' + (0, _string.escape)(this.op) + '</span>';\n          }\n        } else if (args.length === 2) {\n          // binary operatoes\n          var lhs = args[0].toHTML(options); // left hand side\n          var rhs = args[1].toHTML(options); // right hand side\n          if (parens[0]) {\n            // left hand side in parenthesis?\n            lhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + lhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n          }\n          if (parens[1]) {\n            // right hand side in parenthesis?\n            rhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + rhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n          }\n          if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n            return lhs + '<span class=\"math-operator math-binary-operator ' + 'math-implicit-binary-operator\"></span>' + rhs;\n          }\n          return lhs + '<span class=\"math-operator math-binary-operator ' + 'math-explicit-binary-operator\">' + (0, _string.escape)(this.op) + '</span>' + rhs;\n        } else {\n          var stringifiedArgs = args.map(function (arg, index) {\n            arg = arg.toHTML(options);\n            if (parens[index]) {\n              // put in parenthesis?\n              arg = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + arg + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n            }\n            return arg;\n          });\n          if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n            if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n              return stringifiedArgs.join('<span class=\"math-operator math-binary-operator ' + 'math-implicit-binary-operator\"></span>');\n            }\n            return stringifiedArgs.join('<span class=\"math-operator math-binary-operator ' + 'math-explicit-binary-operator\">' + (0, _string.escape)(this.op) + '</span>');\n          } else {\n            // fallback to formatting as a function call\n            return '<span class=\"math-function\">' + (0, _string.escape)(this.fn) + '</span><span class=\"math-paranthesis math-round-parenthesis\">' + '(</span>' + stringifiedArgs.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-paranthesis math-round-parenthesis\">)</span>';\n          }\n        }\n      }\n\n      /**\n       * Get LaTeX representation\n       * @param {Object} options\n       * @return {string} str\n       */\n    }, {\n      key: \"_toTex\",\n      value: function _toTex(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var implicit = options && options.implicit ? options.implicit : 'hide';\n        var args = this.args;\n        var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);\n        var op = _latex.latexOperators[this.fn];\n        op = typeof op === 'undefined' ? this.op : op; // fall back to using this.op\n\n        if (args.length === 1) {\n          // unary operators\n          var assoc = (0, _operators.getAssociativity)(this, parenthesis);\n          var operand = args[0].toTex(options);\n          if (parens[0]) {\n            operand = \"\\\\left(\".concat(operand, \"\\\\right)\");\n          }\n          if (assoc === 'right') {\n            // prefix operator\n            return op + operand;\n          } else if (assoc === 'left') {\n            // postfix operator\n            return operand + op;\n          }\n\n          // fall back to postfix\n          return operand + op;\n        } else if (args.length === 2) {\n          // binary operators\n          var lhs = args[0]; // left hand side\n          var lhsTex = lhs.toTex(options);\n          if (parens[0]) {\n            lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n          }\n          var rhs = args[1]; // right hand side\n          var rhsTex = rhs.toTex(options);\n          if (parens[1]) {\n            rhsTex = \"\\\\left(\".concat(rhsTex, \"\\\\right)\");\n          }\n\n          // handle some exceptions (due to the way LaTeX works)\n          var lhsIdentifier;\n          if (parenthesis === 'keep') {\n            lhsIdentifier = lhs.getIdentifier();\n          } else {\n            // Ignore ParenthesisNodes if in 'keep' mode\n            lhsIdentifier = lhs.getContent().getIdentifier();\n          }\n          switch (this.getIdentifier()) {\n            case 'OperatorNode:divide':\n              // op contains '\\\\frac' at this point\n              return op + '{' + lhsTex + '}' + '{' + rhsTex + '}';\n            case 'OperatorNode:pow':\n              lhsTex = '{' + lhsTex + '}';\n              rhsTex = '{' + rhsTex + '}';\n              switch (lhsIdentifier) {\n                case 'ConditionalNode': //\n                case 'OperatorNode:divide':\n                  lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n              }\n              break;\n            case 'OperatorNode:multiply':\n              if (this.implicit && implicit === 'hide') {\n                return lhsTex + '~' + rhsTex;\n              }\n          }\n          return lhsTex + op + rhsTex;\n        } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n          var texifiedArgs = args.map(function (arg, index) {\n            arg = arg.toTex(options);\n            if (parens[index]) {\n              arg = \"\\\\left(\".concat(arg, \"\\\\right)\");\n            }\n            return arg;\n          });\n          if (this.getIdentifier() === 'OperatorNode:multiply' && this.implicit && implicit === 'hide') {\n            return texifiedArgs.join('~');\n          }\n          return texifiedArgs.join(op);\n        } else {\n          // fall back to formatting as a function call\n          // as this is a fallback, it doesn't use\n          // fancy function names\n          return '\\\\mathrm{' + this.fn + '}\\\\left(' + args.map(function (arg) {\n            return arg.toTex(options);\n          }).join(',') + '\\\\right)';\n        }\n      }\n\n      /**\n       * Get identifier.\n       * @return {string}\n       */\n    }, {\n      key: \"getIdentifier\",\n      value: function getIdentifier() {\n        return this.type + ':' + this.fn;\n      }\n    }], [{\n      key: \"fromJSON\",\n      value: function fromJSON(json) {\n        return new OperatorNode(json.op, json.fn, json.args, json.implicit, json.isPercentage);\n      }\n    }]);\n    return OperatorNode;\n  }(Node);\n  (0, _defineProperty2[\"default\"])(OperatorNode, \"name\", name);\n  return OperatorNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createOperatorNode = createOperatorNode;"],"mappings":"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"},"metadata":{},"sourceType":"script"}