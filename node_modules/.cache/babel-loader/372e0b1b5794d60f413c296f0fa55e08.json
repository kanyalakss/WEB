{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createNode = void 0;\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _is = require(\"../../utils/is.js\");\nvar _keywords = require(\"../keywords.js\");\nvar _object = require(\"../../utils/object.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar _map = require(\"../../utils/map.js\");\nvar name = 'Node';\nvar dependencies = ['mathWithTransform'];\nvar createNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var mathWithTransform = _ref.mathWithTransform;\n  /**\n   * Validate the symbol names of a scope.\n   * Throws an error when the scope contains an illegal symbol.\n   * @param {Object} scope\n   */\n  function _validateScope(scope) {\n    for (var _i = 0, _arr = (0, _toConsumableArray2[\"default\"])(_keywords.keywords); _i < _arr.length; _i++) {\n      var symbol = _arr[_i];\n      if (scope.has(symbol)) {\n        throw new Error('Scope contains an illegal symbol, \"' + symbol + '\" is a reserved keyword');\n      }\n    }\n  }\n  var Node = /*#__PURE__*/function () {\n    function Node() {\n      (0, _classCallCheck2[\"default\"])(this, Node);\n    }\n    (0, _createClass2[\"default\"])(Node, [{\n      key: \"type\",\n      get: function get() {\n        return 'Node';\n      }\n    }, {\n      key: \"isNode\",\n      get: function get() {\n        return true;\n      }\n\n      /**\n       * Evaluate the node\n       * @param {Object} [scope]  Scope to read/write variables\n       * @return {*}              Returns the result\n       */\n    }, {\n      key: \"evaluate\",\n      value: function evaluate(scope) {\n        return this.compile().evaluate(scope);\n      }\n\n      /**\n       * Compile the node into an optimized, evauatable JavaScript function\n       * @return {{evaluate: function([Object])}} object\n       *                Returns an object with a function 'evaluate',\n       *                which can be invoked as expr.evaluate([scope: Object]),\n       *                where scope is an optional object with\n       *                variables.\n       */\n    }, {\n      key: \"compile\",\n      value: function compile() {\n        var expr = this._compile(mathWithTransform, {});\n        var args = {};\n        var context = null;\n        function evaluate(scope) {\n          var s = (0, _map.createMap)(scope);\n          _validateScope(s);\n          return expr(s, args, context);\n        }\n        return {\n          evaluate: evaluate\n        };\n      }\n\n      /**\n       * Compile a node into a JavaScript function.\n       * This basically pre-calculates as much as possible and only leaves open\n       * calculations which depend on a dynamic scope with variables.\n       * @param {Object} math     Math.js namespace with functions and constants.\n       * @param {Object} argNames An object with argument names as key and `true`\n       *                          as value. Used in the SymbolNode to optimize\n       *                          for arguments from user assigned functions\n       *                          (see FunctionAssignmentNode) or special symbols\n       *                          like `end` (see IndexNode).\n       * @return {function} Returns a function which can be called like:\n       *                        evalNode(scope: Object, args: Object, context: *)\n       */\n    }, {\n      key: \"_compile\",\n      value: function _compile(math, argNames) {\n        throw new Error('Method _compile must be implemented by type ' + this.type);\n      }\n\n      /**\n       * Execute a callback for each of the child nodes of this node\n       * @param {function(child: Node, path: string, parent: Node)} callback\n       */\n    }, {\n      key: \"forEach\",\n      value: function forEach(callback) {\n        // must be implemented by each of the Node implementations\n        throw new Error('Cannot run forEach on a Node interface');\n      }\n\n      /**\n       * Create a new Node whose children are the results of calling the\n       * provided callback function for each child of the original node.\n       * @param {function(child: Node, path: string, parent: Node): Node} callback\n       * @returns {OperatorNode} Returns a transformed copy of the node\n       */\n    }, {\n      key: \"map\",\n      value: function map(callback) {\n        // must be implemented by each of the Node implementations\n        throw new Error('Cannot run map on a Node interface');\n      }\n\n      /**\n       * Validate whether an object is a Node, for use with map\n       * @param {Node} node\n       * @returns {Node} Returns the input if it's a node, else throws an Error\n       * @protected\n       */\n    }, {\n      key: \"_ifNode\",\n      value: function _ifNode(node) {\n        if (!(0, _is.isNode)(node)) {\n          throw new TypeError('Callback function must return a Node');\n        }\n        return node;\n      }\n\n      /**\n       * Recursively traverse all nodes in a node tree. Executes given callback for\n       * this node and each of its child nodes.\n       * @param {function(node: Node, path: string, parent: Node)} callback\n       *          A callback called for every node in the node tree.\n       */\n    }, {\n      key: \"traverse\",\n      value: function traverse(callback) {\n        // execute callback for itself\n        // eslint-disable-next-line\n        callback(this, null, null);\n\n        // recursively traverse over all children of a node\n        function _traverse(node, callback) {\n          node.forEach(function (child, path, parent) {\n            callback(child, path, parent);\n            _traverse(child, callback);\n          });\n        }\n        _traverse(this, callback);\n      }\n\n      /**\n       * Recursively transform a node tree via a transform function.\n       *\n       * For example, to replace all nodes of type SymbolNode having name 'x' with\n       * a ConstantNode with value 2:\n       *\n       *     const res = Node.transform(function (node, path, parent) {\n       *       if (node && node.isSymbolNode) && (node.name === 'x')) {\n       *         return new ConstantNode(2)\n       *       }\n       *       else {\n       *         return node\n       *       }\n       *     })\n       *\n       * @param {function(node: Node, path: string, parent: Node) : Node} callback\n       *          A mapping function accepting a node, and returning\n       *          a replacement for the node or the original node. The \"signature\"\n       *          of the callback must be:\n       *          callback(node: Node, index: string, parent: Node) : Node\n       * @return {Node} Returns the original node or its replacement\n       */\n    }, {\n      key: \"transform\",\n      value: function transform(callback) {\n        function _transform(child, path, parent) {\n          var replacement = callback(child, path, parent);\n          if (replacement !== child) {\n            // stop iterating when the node is replaced\n            return replacement;\n          }\n          return child.map(_transform);\n        }\n        return _transform(this, null, null);\n      }\n\n      /**\n       * Find any node in the node tree matching given filter function. For\n       * example, to find all nodes of type SymbolNode having name 'x':\n       *\n       *     const results = Node.filter(function (node) {\n       *       return (node && node.isSymbolNode) && (node.name === 'x')\n       *     })\n       *\n       * @param {function(node: Node, path: string, parent: Node) : Node} callback\n       *            A test function returning true when a node matches, and false\n       *            otherwise. Function signature:\n       *            callback(node: Node, index: string, parent: Node) : boolean\n       * @return {Node[]} nodes\n       *            An array with nodes matching given filter criteria\n       */\n    }, {\n      key: \"filter\",\n      value: function filter(callback) {\n        var nodes = [];\n        this.traverse(function (node, path, parent) {\n          if (callback(node, path, parent)) {\n            nodes.push(node);\n          }\n        });\n        return nodes;\n      }\n\n      /**\n       * Create a shallow clone of this node\n       * @return {Node}\n       */\n    }, {\n      key: \"clone\",\n      value: function clone() {\n        // must be implemented by each of the Node implementations\n        throw new Error('Cannot clone a Node interface');\n      }\n\n      /**\n       * Create a deep clone of this node\n       * @return {Node}\n       */\n    }, {\n      key: \"cloneDeep\",\n      value: function cloneDeep() {\n        return this.map(function (node) {\n          return node.cloneDeep();\n        });\n      }\n\n      /**\n       * Deep compare this node with another node.\n       * @param {Node} other\n       * @return {boolean} Returns true when both nodes are of the same type and\n       *                   contain the same values (as do their childs)\n       */\n    }, {\n      key: \"equals\",\n      value: function equals(other) {\n        return other ? this.type === other.type && (0, _object.deepStrictEqual)(this, other) : false;\n      }\n\n      /**\n       * Get string representation. (wrapper function)\n       *\n       * This function can get an object of the following form:\n       * {\n       *    handler: //This can be a callback function of the form\n       *             // \"function callback(node, options)\"or\n       *             // a map that maps function names (used in FunctionNodes)\n       *             // to callbacks\n       *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n       * }\n       *\n       * @param {Object} [options]\n       * @return {string}\n       */\n    }, {\n      key: \"toString\",\n      value: function toString(options) {\n        var customString = this._getCustomString(options);\n        if (typeof customString !== 'undefined') {\n          return customString;\n        }\n        return this._toString(options);\n      }\n\n      /**\n       * Get a JSON representation of the node\n       * Both .toJSON() and the static .fromJSON(json) should be implemented by all\n       * implementations of Node\n       * @returns {Object}\n       */\n    }, {\n      key: \"toJSON\",\n      value: function toJSON() {\n        throw new Error('Cannot serialize object: toJSON not implemented by ' + this.type);\n      }\n\n      /**\n       * Get HTML representation. (wrapper function)\n       *\n       * This function can get an object of the following form:\n       * {\n       *    handler: //This can be a callback function of the form\n       *             // \"function callback(node, options)\" or\n       *             // a map that maps function names (used in FunctionNodes)\n       *             // to callbacks\n       *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n       * }\n       *\n       * @param {Object} [options]\n       * @return {string}\n       */\n    }, {\n      key: \"toHTML\",\n      value: function toHTML(options) {\n        var customString = this._getCustomString(options);\n        if (typeof customString !== 'undefined') {\n          return customString;\n        }\n        return this.toHTML(options);\n      }\n\n      /**\n       * Internal function to generate the string output.\n       * This has to be implemented by every Node\n       *\n       * @throws {Error}\n       */\n    }, {\n      key: \"_toString\",\n      value: function _toString() {\n        // must be implemented by each of the Node implementations\n        throw new Error('_toString not implemented for ' + this.type);\n      }\n\n      /**\n       * Get LaTeX representation. (wrapper function)\n       *\n       * This function can get an object of the following form:\n       * {\n       *    handler: //This can be a callback function of the form\n       *             // \"function callback(node, options)\"or\n       *             // a map that maps function names (used in FunctionNodes)\n       *             // to callbacks\n       *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n       * }\n       *\n       * @param {Object} [options]\n       * @return {string}\n       */\n    }, {\n      key: \"toTex\",\n      value: function toTex(options) {\n        var customString = this._getCustomString(options);\n        if (typeof customString !== 'undefined') {\n          return customString;\n        }\n        return this._toTex(options);\n      }\n\n      /**\n       * Internal function to generate the LaTeX output.\n       * This has to be implemented by every Node\n       *\n       * @param {Object} [options]\n       * @throws {Error}\n       */\n    }, {\n      key: \"_toTex\",\n      value: function _toTex(options) {\n        // must be implemented by each of the Node implementations\n        throw new Error('_toTex not implemented for ' + this.type);\n      }\n\n      /**\n       * Helper used by `to...` functions.\n       */\n    }, {\n      key: \"_getCustomString\",\n      value: function _getCustomString(options) {\n        if (options && (0, _typeof2[\"default\"])(options) === 'object') {\n          switch ((0, _typeof2[\"default\"])(options.handler)) {\n            case 'object':\n            case 'undefined':\n              return;\n            case 'function':\n              return options.handler(this, options);\n            default:\n              throw new TypeError('Object or function expected as callback');\n          }\n        }\n      }\n\n      /**\n       * Get identifier.\n       * @return {string}\n       */\n    }, {\n      key: \"getIdentifier\",\n      value: function getIdentifier() {\n        return this.type;\n      }\n\n      /**\n       * Get the content of the current Node.\n       * @return {Node} node\n       **/\n    }, {\n      key: \"getContent\",\n      value: function getContent() {\n        return this;\n      }\n    }]);\n    return Node;\n  }();\n  return Node;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createNode = createNode;","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","createNode","_typeof2","_classCallCheck2","_createClass2","_toConsumableArray2","_is","_keywords","_object","_factory","_map","name","dependencies","factory","_ref","mathWithTransform","_validateScope","scope","_i","_arr","keywords","length","symbol","has","Error","Node","key","get","evaluate","compile","expr","_compile","args","context","s","createMap","math","argNames","type","forEach","callback","map","_ifNode","node","isNode","TypeError","traverse","_traverse","child","path","parent","transform","_transform","replacement","filter","nodes","push","clone","cloneDeep","equals","other","deepStrictEqual","toString","options","customString","_getCustomString","_toString","toJSON","toHTML","toTex","_toTex","handler","getIdentifier","getContent","isClass"],"sources":["C:/Users/Admin/Desktop/React-Web-main/node_modules/mathjs/lib/cjs/expression/node/Node.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createNode = void 0;\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _is = require(\"../../utils/is.js\");\nvar _keywords = require(\"../keywords.js\");\nvar _object = require(\"../../utils/object.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar _map = require(\"../../utils/map.js\");\nvar name = 'Node';\nvar dependencies = ['mathWithTransform'];\nvar createNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var mathWithTransform = _ref.mathWithTransform;\n  /**\n   * Validate the symbol names of a scope.\n   * Throws an error when the scope contains an illegal symbol.\n   * @param {Object} scope\n   */\n  function _validateScope(scope) {\n    for (var _i = 0, _arr = (0, _toConsumableArray2[\"default\"])(_keywords.keywords); _i < _arr.length; _i++) {\n      var symbol = _arr[_i];\n      if (scope.has(symbol)) {\n        throw new Error('Scope contains an illegal symbol, \"' + symbol + '\" is a reserved keyword');\n      }\n    }\n  }\n  var Node = /*#__PURE__*/function () {\n    function Node() {\n      (0, _classCallCheck2[\"default\"])(this, Node);\n    }\n    (0, _createClass2[\"default\"])(Node, [{\n      key: \"type\",\n      get: function get() {\n        return 'Node';\n      }\n    }, {\n      key: \"isNode\",\n      get: function get() {\n        return true;\n      }\n\n      /**\n       * Evaluate the node\n       * @param {Object} [scope]  Scope to read/write variables\n       * @return {*}              Returns the result\n       */\n    }, {\n      key: \"evaluate\",\n      value: function evaluate(scope) {\n        return this.compile().evaluate(scope);\n      }\n\n      /**\n       * Compile the node into an optimized, evauatable JavaScript function\n       * @return {{evaluate: function([Object])}} object\n       *                Returns an object with a function 'evaluate',\n       *                which can be invoked as expr.evaluate([scope: Object]),\n       *                where scope is an optional object with\n       *                variables.\n       */\n    }, {\n      key: \"compile\",\n      value: function compile() {\n        var expr = this._compile(mathWithTransform, {});\n        var args = {};\n        var context = null;\n        function evaluate(scope) {\n          var s = (0, _map.createMap)(scope);\n          _validateScope(s);\n          return expr(s, args, context);\n        }\n        return {\n          evaluate: evaluate\n        };\n      }\n\n      /**\n       * Compile a node into a JavaScript function.\n       * This basically pre-calculates as much as possible and only leaves open\n       * calculations which depend on a dynamic scope with variables.\n       * @param {Object} math     Math.js namespace with functions and constants.\n       * @param {Object} argNames An object with argument names as key and `true`\n       *                          as value. Used in the SymbolNode to optimize\n       *                          for arguments from user assigned functions\n       *                          (see FunctionAssignmentNode) or special symbols\n       *                          like `end` (see IndexNode).\n       * @return {function} Returns a function which can be called like:\n       *                        evalNode(scope: Object, args: Object, context: *)\n       */\n    }, {\n      key: \"_compile\",\n      value: function _compile(math, argNames) {\n        throw new Error('Method _compile must be implemented by type ' + this.type);\n      }\n\n      /**\n       * Execute a callback for each of the child nodes of this node\n       * @param {function(child: Node, path: string, parent: Node)} callback\n       */\n    }, {\n      key: \"forEach\",\n      value: function forEach(callback) {\n        // must be implemented by each of the Node implementations\n        throw new Error('Cannot run forEach on a Node interface');\n      }\n\n      /**\n       * Create a new Node whose children are the results of calling the\n       * provided callback function for each child of the original node.\n       * @param {function(child: Node, path: string, parent: Node): Node} callback\n       * @returns {OperatorNode} Returns a transformed copy of the node\n       */\n    }, {\n      key: \"map\",\n      value: function map(callback) {\n        // must be implemented by each of the Node implementations\n        throw new Error('Cannot run map on a Node interface');\n      }\n\n      /**\n       * Validate whether an object is a Node, for use with map\n       * @param {Node} node\n       * @returns {Node} Returns the input if it's a node, else throws an Error\n       * @protected\n       */\n    }, {\n      key: \"_ifNode\",\n      value: function _ifNode(node) {\n        if (!(0, _is.isNode)(node)) {\n          throw new TypeError('Callback function must return a Node');\n        }\n        return node;\n      }\n\n      /**\n       * Recursively traverse all nodes in a node tree. Executes given callback for\n       * this node and each of its child nodes.\n       * @param {function(node: Node, path: string, parent: Node)} callback\n       *          A callback called for every node in the node tree.\n       */\n    }, {\n      key: \"traverse\",\n      value: function traverse(callback) {\n        // execute callback for itself\n        // eslint-disable-next-line\n        callback(this, null, null);\n\n        // recursively traverse over all children of a node\n        function _traverse(node, callback) {\n          node.forEach(function (child, path, parent) {\n            callback(child, path, parent);\n            _traverse(child, callback);\n          });\n        }\n        _traverse(this, callback);\n      }\n\n      /**\n       * Recursively transform a node tree via a transform function.\n       *\n       * For example, to replace all nodes of type SymbolNode having name 'x' with\n       * a ConstantNode with value 2:\n       *\n       *     const res = Node.transform(function (node, path, parent) {\n       *       if (node && node.isSymbolNode) && (node.name === 'x')) {\n       *         return new ConstantNode(2)\n       *       }\n       *       else {\n       *         return node\n       *       }\n       *     })\n       *\n       * @param {function(node: Node, path: string, parent: Node) : Node} callback\n       *          A mapping function accepting a node, and returning\n       *          a replacement for the node or the original node. The \"signature\"\n       *          of the callback must be:\n       *          callback(node: Node, index: string, parent: Node) : Node\n       * @return {Node} Returns the original node or its replacement\n       */\n    }, {\n      key: \"transform\",\n      value: function transform(callback) {\n        function _transform(child, path, parent) {\n          var replacement = callback(child, path, parent);\n          if (replacement !== child) {\n            // stop iterating when the node is replaced\n            return replacement;\n          }\n          return child.map(_transform);\n        }\n        return _transform(this, null, null);\n      }\n\n      /**\n       * Find any node in the node tree matching given filter function. For\n       * example, to find all nodes of type SymbolNode having name 'x':\n       *\n       *     const results = Node.filter(function (node) {\n       *       return (node && node.isSymbolNode) && (node.name === 'x')\n       *     })\n       *\n       * @param {function(node: Node, path: string, parent: Node) : Node} callback\n       *            A test function returning true when a node matches, and false\n       *            otherwise. Function signature:\n       *            callback(node: Node, index: string, parent: Node) : boolean\n       * @return {Node[]} nodes\n       *            An array with nodes matching given filter criteria\n       */\n    }, {\n      key: \"filter\",\n      value: function filter(callback) {\n        var nodes = [];\n        this.traverse(function (node, path, parent) {\n          if (callback(node, path, parent)) {\n            nodes.push(node);\n          }\n        });\n        return nodes;\n      }\n\n      /**\n       * Create a shallow clone of this node\n       * @return {Node}\n       */\n    }, {\n      key: \"clone\",\n      value: function clone() {\n        // must be implemented by each of the Node implementations\n        throw new Error('Cannot clone a Node interface');\n      }\n\n      /**\n       * Create a deep clone of this node\n       * @return {Node}\n       */\n    }, {\n      key: \"cloneDeep\",\n      value: function cloneDeep() {\n        return this.map(function (node) {\n          return node.cloneDeep();\n        });\n      }\n\n      /**\n       * Deep compare this node with another node.\n       * @param {Node} other\n       * @return {boolean} Returns true when both nodes are of the same type and\n       *                   contain the same values (as do their childs)\n       */\n    }, {\n      key: \"equals\",\n      value: function equals(other) {\n        return other ? this.type === other.type && (0, _object.deepStrictEqual)(this, other) : false;\n      }\n\n      /**\n       * Get string representation. (wrapper function)\n       *\n       * This function can get an object of the following form:\n       * {\n       *    handler: //This can be a callback function of the form\n       *             // \"function callback(node, options)\"or\n       *             // a map that maps function names (used in FunctionNodes)\n       *             // to callbacks\n       *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n       * }\n       *\n       * @param {Object} [options]\n       * @return {string}\n       */\n    }, {\n      key: \"toString\",\n      value: function toString(options) {\n        var customString = this._getCustomString(options);\n        if (typeof customString !== 'undefined') {\n          return customString;\n        }\n        return this._toString(options);\n      }\n\n      /**\n       * Get a JSON representation of the node\n       * Both .toJSON() and the static .fromJSON(json) should be implemented by all\n       * implementations of Node\n       * @returns {Object}\n       */\n    }, {\n      key: \"toJSON\",\n      value: function toJSON() {\n        throw new Error('Cannot serialize object: toJSON not implemented by ' + this.type);\n      }\n\n      /**\n       * Get HTML representation. (wrapper function)\n       *\n       * This function can get an object of the following form:\n       * {\n       *    handler: //This can be a callback function of the form\n       *             // \"function callback(node, options)\" or\n       *             // a map that maps function names (used in FunctionNodes)\n       *             // to callbacks\n       *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n       * }\n       *\n       * @param {Object} [options]\n       * @return {string}\n       */\n    }, {\n      key: \"toHTML\",\n      value: function toHTML(options) {\n        var customString = this._getCustomString(options);\n        if (typeof customString !== 'undefined') {\n          return customString;\n        }\n        return this.toHTML(options);\n      }\n\n      /**\n       * Internal function to generate the string output.\n       * This has to be implemented by every Node\n       *\n       * @throws {Error}\n       */\n    }, {\n      key: \"_toString\",\n      value: function _toString() {\n        // must be implemented by each of the Node implementations\n        throw new Error('_toString not implemented for ' + this.type);\n      }\n\n      /**\n       * Get LaTeX representation. (wrapper function)\n       *\n       * This function can get an object of the following form:\n       * {\n       *    handler: //This can be a callback function of the form\n       *             // \"function callback(node, options)\"or\n       *             // a map that maps function names (used in FunctionNodes)\n       *             // to callbacks\n       *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n       * }\n       *\n       * @param {Object} [options]\n       * @return {string}\n       */\n    }, {\n      key: \"toTex\",\n      value: function toTex(options) {\n        var customString = this._getCustomString(options);\n        if (typeof customString !== 'undefined') {\n          return customString;\n        }\n        return this._toTex(options);\n      }\n\n      /**\n       * Internal function to generate the LaTeX output.\n       * This has to be implemented by every Node\n       *\n       * @param {Object} [options]\n       * @throws {Error}\n       */\n    }, {\n      key: \"_toTex\",\n      value: function _toTex(options) {\n        // must be implemented by each of the Node implementations\n        throw new Error('_toTex not implemented for ' + this.type);\n      }\n\n      /**\n       * Helper used by `to...` functions.\n       */\n    }, {\n      key: \"_getCustomString\",\n      value: function _getCustomString(options) {\n        if (options && (0, _typeof2[\"default\"])(options) === 'object') {\n          switch ((0, _typeof2[\"default\"])(options.handler)) {\n            case 'object':\n            case 'undefined':\n              return;\n            case 'function':\n              return options.handler(this, options);\n            default:\n              throw new TypeError('Object or function expected as callback');\n          }\n        }\n      }\n\n      /**\n       * Get identifier.\n       * @return {string}\n       */\n    }, {\n      key: \"getIdentifier\",\n      value: function getIdentifier() {\n        return this.type;\n      }\n\n      /**\n       * Get the content of the current Node.\n       * @return {Node} node\n       **/\n    }, {\n      key: \"getContent\",\n      value: function getContent() {\n        return this;\n      }\n    }]);\n    return Node;\n  }();\n  return Node;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createNode = createNode;"],"mappings":"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"},"metadata":{},"sourceType":"script"}