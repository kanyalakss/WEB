{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getAssociativity = getAssociativity;\nexports.getOperator = getOperator;\nexports.getPrecedence = getPrecedence;\nexports.isAssociativeWith = isAssociativeWith;\nexports.properties = void 0;\nvar _object = require(\"../utils/object.js\");\nvar _is = require(\"../utils/is.js\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nvar properties = [{\n  // assignment\n  AssignmentNode: {},\n  FunctionAssignmentNode: {}\n}, {\n  // conditional expression\n  ConditionalNode: {\n    latexLeftParens: false,\n    latexRightParens: false,\n    latexParens: false\n    // conditionals don't need parentheses in LaTeX because\n    // they are 2 dimensional\n  }\n}, {\n  // logical or\n  'OperatorNode:or': {\n    op: 'or',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // logical xor\n  'OperatorNode:xor': {\n    op: 'xor',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // logical and\n  'OperatorNode:and': {\n    op: 'and',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise or\n  'OperatorNode:bitOr': {\n    op: '|',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise xor\n  'OperatorNode:bitXor': {\n    op: '^|',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise and\n  'OperatorNode:bitAnd': {\n    op: '&',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // relational operators\n  'OperatorNode:equal': {\n    op: '==',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:unequal': {\n    op: '!=',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:smaller': {\n    op: '<',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:larger': {\n    op: '>',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:smallerEq': {\n    op: '<=',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:largerEq': {\n    op: '>=',\n    associativity: 'left',\n    associativeWith: []\n  },\n  RelationalNode: {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitshift operators\n  'OperatorNode:leftShift': {\n    op: '<<',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:rightArithShift': {\n    op: '>>',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:rightLogShift': {\n    op: '>>>',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // unit conversion\n  'OperatorNode:to': {\n    op: 'to',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // range\n  RangeNode: {}\n}, {\n  // addition, subtraction\n  'OperatorNode:add': {\n    op: '+',\n    associativity: 'left',\n    associativeWith: ['OperatorNode:add', 'OperatorNode:subtract']\n  },\n  'OperatorNode:subtract': {\n    op: '-',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // multiply, divide, modulus\n  'OperatorNode:multiply': {\n    op: '*',\n    associativity: 'left',\n    associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'Operator:dotMultiply', 'Operator:dotDivide']\n  },\n  'OperatorNode:divide': {\n    op: '/',\n    associativity: 'left',\n    associativeWith: [],\n    latexLeftParens: false,\n    latexRightParens: false,\n    latexParens: false\n    // fractions don't require parentheses because\n    // they're 2 dimensional, so parens aren't needed\n    // in LaTeX\n  },\n\n  'OperatorNode:dotMultiply': {\n    op: '.*',\n    associativity: 'left',\n    associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'OperatorNode:dotMultiply', 'OperatorNode:doDivide']\n  },\n  'OperatorNode:dotDivide': {\n    op: './',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:mod': {\n    op: 'mod',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // Repeat multiplication for implicit multiplication\n  'OperatorNode:multiply': {\n    associativity: 'left',\n    associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'Operator:dotMultiply', 'Operator:dotDivide']\n  }\n}, {\n  // unary prefix operators\n  'OperatorNode:unaryPlus': {\n    op: '+',\n    associativity: 'right'\n  },\n  'OperatorNode:unaryMinus': {\n    op: '-',\n    associativity: 'right'\n  },\n  'OperatorNode:bitNot': {\n    op: '~',\n    associativity: 'right'\n  },\n  'OperatorNode:not': {\n    op: 'not',\n    associativity: 'right'\n  }\n}, {\n  // exponentiation\n  'OperatorNode:pow': {\n    op: '^',\n    associativity: 'right',\n    associativeWith: [],\n    latexRightParens: false\n    // the exponent doesn't need parentheses in\n    // LaTeX because it's 2 dimensional\n    // (it's on top)\n  },\n\n  'OperatorNode:dotPow': {\n    op: '.^',\n    associativity: 'right',\n    associativeWith: []\n  }\n}, {\n  // factorial\n  'OperatorNode:factorial': {\n    op: '!',\n    associativity: 'left'\n  }\n}, {\n  // matrix transpose\n  'OperatorNode:ctranspose': {\n    op: \"'\",\n    associativity: 'left'\n  }\n}];\n\n/**\n * Returns the first non-parenthesis internal node, but only\n * when the 'parenthesis' option is unset or auto.\n * @param {Node} _node\n * @param {string} parenthesis\n * @return {Node}\n */\nexports.properties = properties;\nfunction unwrapParen(_node, parenthesis) {\n  if (!parenthesis || parenthesis !== 'auto') return _node;\n  var node = _node;\n  while ((0, _is.isParenthesisNode)(node)) {\n    node = node.content;\n  }\n  return node;\n}\n\n/**\n * Get the precedence of a Node.\n * Higher number for higher precedence, starting with 0.\n * Returns null if the precedence is undefined.\n *\n * @param {Node} _node\n * @param {string} parenthesis\n * @param {string} implicit\n * @param {Node} parent (for determining context for implicit multiplication)\n * @return {number | null}\n */\nfunction getPrecedence(_node, parenthesis, implicit, parent) {\n  var node = _node;\n  if (parenthesis !== 'keep') {\n    // ParenthesisNodes are only ignored when not in 'keep' mode\n    node = _node.getContent();\n  }\n  var identifier = node.getIdentifier();\n  var precedence = null;\n  for (var i = 0; i < properties.length; i++) {\n    if (identifier in properties[i]) {\n      precedence = i;\n      break;\n    }\n  }\n  // Bump up precedence of implicit multiplication, except when preceded\n  // by a \"Rule 2\" fraction ( [unaryOp]constant / constant )\n  if (identifier === 'OperatorNode:multiply' && node.implicit && implicit !== 'show') {\n    var leftArg = unwrapParen(node.args[0], parenthesis);\n    if (!((0, _is.isConstantNode)(leftArg) && parent && parent.getIdentifier() === 'OperatorNode:divide' && (0, _is.rule2Node)(unwrapParen(parent.args[0], parenthesis))) && !(leftArg.getIdentifier() === 'OperatorNode:divide' && (0, _is.rule2Node)(unwrapParen(leftArg.args[0], parenthesis)) && (0, _is.isConstantNode)(unwrapParen(leftArg.args[1])))) {\n      precedence += 1;\n    }\n  }\n  return precedence;\n}\n\n/**\n * Get the associativity of an operator (left or right).\n * Returns a string containing 'left' or 'right' or null if\n * the associativity is not defined.\n *\n * @param {Node} _node\n * @param {string} parenthesis\n * @return {string|null}\n * @throws {Error}\n */\nfunction getAssociativity(_node, parenthesis) {\n  var node = _node;\n  if (parenthesis !== 'keep') {\n    // ParenthesisNodes are only ignored when not in 'keep' mode\n    node = _node.getContent();\n  }\n  var identifier = node.getIdentifier();\n  var index = getPrecedence(node, parenthesis);\n  if (index === null) {\n    // node isn't in the list\n    return null;\n  }\n  var property = properties[index][identifier];\n  if ((0, _object.hasOwnProperty)(property, 'associativity')) {\n    if (property.associativity === 'left') {\n      return 'left';\n    }\n    if (property.associativity === 'right') {\n      return 'right';\n    }\n    // associativity is invalid\n    throw Error('\\'' + identifier + '\\' has the invalid associativity \\'' + property.associativity + '\\'.');\n  }\n\n  // associativity is undefined\n  return null;\n}\n\n/**\n * Check if an operator is associative with another operator.\n * Returns either true or false or null if not defined.\n *\n * @param {Node} nodeA\n * @param {Node} nodeB\n * @param {string} parenthesis\n * @return {boolean | null}\n */\nfunction isAssociativeWith(nodeA, nodeB, parenthesis) {\n  // ParenthesisNodes are only ignored when not in 'keep' mode\n  var a = parenthesis !== 'keep' ? nodeA.getContent() : nodeA;\n  var b = parenthesis !== 'keep' ? nodeA.getContent() : nodeB;\n  var identifierA = a.getIdentifier();\n  var identifierB = b.getIdentifier();\n  var index = getPrecedence(a, parenthesis);\n  if (index === null) {\n    // node isn't in the list\n    return null;\n  }\n  var property = properties[index][identifierA];\n  if ((0, _object.hasOwnProperty)(property, 'associativeWith') && property.associativeWith instanceof Array) {\n    for (var i = 0; i < property.associativeWith.length; i++) {\n      if (property.associativeWith[i] === identifierB) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // associativeWith is not defined\n  return null;\n}\n\n/**\n * Get the operator associated with a function name.\n * Returns a string with the operator symbol, or null if the\n * input is not the name of a function associated with an\n * operator.\n *\n * @param {string} Function name\n * @return {string | null} Associated operator symbol, if any\n */\nfunction getOperator(fn) {\n  var identifier = 'OperatorNode:' + fn;\n  var _iterator = _createForOfIteratorHelper(properties),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var group = _step.value;\n      if (identifier in group) {\n        return group[identifier].op;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return null;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","getAssociativity","getOperator","getPrecedence","isAssociativeWith","properties","_object","require","_is","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","length","i","F","s","n","done","e","_e","f","TypeError","normalCompletion","didErr","err","call","step","next","_e2","minLen","_arrayLikeToArray","prototype","toString","slice","constructor","name","from","test","arr","len","arr2","AssignmentNode","FunctionAssignmentNode","ConditionalNode","latexLeftParens","latexRightParens","latexParens","op","associativity","associativeWith","RelationalNode","RangeNode","unwrapParen","_node","parenthesis","node","isParenthesisNode","content","implicit","parent","getContent","identifier","getIdentifier","precedence","leftArg","args","isConstantNode","rule2Node","index","property","hasOwnProperty","Error","nodeA","nodeB","a","b","identifierA","identifierB","fn","_iterator","_step","group"],"sources":["C:/Users/Admin/Desktop/React-Web-main/node_modules/mathjs/lib/cjs/expression/operators.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getAssociativity = getAssociativity;\nexports.getOperator = getOperator;\nexports.getPrecedence = getPrecedence;\nexports.isAssociativeWith = isAssociativeWith;\nexports.properties = void 0;\nvar _object = require(\"../utils/object.js\");\nvar _is = require(\"../utils/is.js\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar properties = [{\n  // assignment\n  AssignmentNode: {},\n  FunctionAssignmentNode: {}\n}, {\n  // conditional expression\n  ConditionalNode: {\n    latexLeftParens: false,\n    latexRightParens: false,\n    latexParens: false\n    // conditionals don't need parentheses in LaTeX because\n    // they are 2 dimensional\n  }\n}, {\n  // logical or\n  'OperatorNode:or': {\n    op: 'or',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // logical xor\n  'OperatorNode:xor': {\n    op: 'xor',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // logical and\n  'OperatorNode:and': {\n    op: 'and',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise or\n  'OperatorNode:bitOr': {\n    op: '|',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise xor\n  'OperatorNode:bitXor': {\n    op: '^|',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise and\n  'OperatorNode:bitAnd': {\n    op: '&',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // relational operators\n  'OperatorNode:equal': {\n    op: '==',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:unequal': {\n    op: '!=',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:smaller': {\n    op: '<',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:larger': {\n    op: '>',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:smallerEq': {\n    op: '<=',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:largerEq': {\n    op: '>=',\n    associativity: 'left',\n    associativeWith: []\n  },\n  RelationalNode: {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitshift operators\n  'OperatorNode:leftShift': {\n    op: '<<',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:rightArithShift': {\n    op: '>>',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:rightLogShift': {\n    op: '>>>',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // unit conversion\n  'OperatorNode:to': {\n    op: 'to',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // range\n  RangeNode: {}\n}, {\n  // addition, subtraction\n  'OperatorNode:add': {\n    op: '+',\n    associativity: 'left',\n    associativeWith: ['OperatorNode:add', 'OperatorNode:subtract']\n  },\n  'OperatorNode:subtract': {\n    op: '-',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // multiply, divide, modulus\n  'OperatorNode:multiply': {\n    op: '*',\n    associativity: 'left',\n    associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'Operator:dotMultiply', 'Operator:dotDivide']\n  },\n  'OperatorNode:divide': {\n    op: '/',\n    associativity: 'left',\n    associativeWith: [],\n    latexLeftParens: false,\n    latexRightParens: false,\n    latexParens: false\n    // fractions don't require parentheses because\n    // they're 2 dimensional, so parens aren't needed\n    // in LaTeX\n  },\n\n  'OperatorNode:dotMultiply': {\n    op: '.*',\n    associativity: 'left',\n    associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'OperatorNode:dotMultiply', 'OperatorNode:doDivide']\n  },\n  'OperatorNode:dotDivide': {\n    op: './',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:mod': {\n    op: 'mod',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // Repeat multiplication for implicit multiplication\n  'OperatorNode:multiply': {\n    associativity: 'left',\n    associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'Operator:dotMultiply', 'Operator:dotDivide']\n  }\n}, {\n  // unary prefix operators\n  'OperatorNode:unaryPlus': {\n    op: '+',\n    associativity: 'right'\n  },\n  'OperatorNode:unaryMinus': {\n    op: '-',\n    associativity: 'right'\n  },\n  'OperatorNode:bitNot': {\n    op: '~',\n    associativity: 'right'\n  },\n  'OperatorNode:not': {\n    op: 'not',\n    associativity: 'right'\n  }\n}, {\n  // exponentiation\n  'OperatorNode:pow': {\n    op: '^',\n    associativity: 'right',\n    associativeWith: [],\n    latexRightParens: false\n    // the exponent doesn't need parentheses in\n    // LaTeX because it's 2 dimensional\n    // (it's on top)\n  },\n\n  'OperatorNode:dotPow': {\n    op: '.^',\n    associativity: 'right',\n    associativeWith: []\n  }\n}, {\n  // factorial\n  'OperatorNode:factorial': {\n    op: '!',\n    associativity: 'left'\n  }\n}, {\n  // matrix transpose\n  'OperatorNode:ctranspose': {\n    op: \"'\",\n    associativity: 'left'\n  }\n}];\n\n/**\n * Returns the first non-parenthesis internal node, but only\n * when the 'parenthesis' option is unset or auto.\n * @param {Node} _node\n * @param {string} parenthesis\n * @return {Node}\n */\nexports.properties = properties;\nfunction unwrapParen(_node, parenthesis) {\n  if (!parenthesis || parenthesis !== 'auto') return _node;\n  var node = _node;\n  while ((0, _is.isParenthesisNode)(node)) {\n    node = node.content;\n  }\n  return node;\n}\n\n/**\n * Get the precedence of a Node.\n * Higher number for higher precedence, starting with 0.\n * Returns null if the precedence is undefined.\n *\n * @param {Node} _node\n * @param {string} parenthesis\n * @param {string} implicit\n * @param {Node} parent (for determining context for implicit multiplication)\n * @return {number | null}\n */\nfunction getPrecedence(_node, parenthesis, implicit, parent) {\n  var node = _node;\n  if (parenthesis !== 'keep') {\n    // ParenthesisNodes are only ignored when not in 'keep' mode\n    node = _node.getContent();\n  }\n  var identifier = node.getIdentifier();\n  var precedence = null;\n  for (var i = 0; i < properties.length; i++) {\n    if (identifier in properties[i]) {\n      precedence = i;\n      break;\n    }\n  }\n  // Bump up precedence of implicit multiplication, except when preceded\n  // by a \"Rule 2\" fraction ( [unaryOp]constant / constant )\n  if (identifier === 'OperatorNode:multiply' && node.implicit && implicit !== 'show') {\n    var leftArg = unwrapParen(node.args[0], parenthesis);\n    if (!((0, _is.isConstantNode)(leftArg) && parent && parent.getIdentifier() === 'OperatorNode:divide' && (0, _is.rule2Node)(unwrapParen(parent.args[0], parenthesis))) && !(leftArg.getIdentifier() === 'OperatorNode:divide' && (0, _is.rule2Node)(unwrapParen(leftArg.args[0], parenthesis)) && (0, _is.isConstantNode)(unwrapParen(leftArg.args[1])))) {\n      precedence += 1;\n    }\n  }\n  return precedence;\n}\n\n/**\n * Get the associativity of an operator (left or right).\n * Returns a string containing 'left' or 'right' or null if\n * the associativity is not defined.\n *\n * @param {Node} _node\n * @param {string} parenthesis\n * @return {string|null}\n * @throws {Error}\n */\nfunction getAssociativity(_node, parenthesis) {\n  var node = _node;\n  if (parenthesis !== 'keep') {\n    // ParenthesisNodes are only ignored when not in 'keep' mode\n    node = _node.getContent();\n  }\n  var identifier = node.getIdentifier();\n  var index = getPrecedence(node, parenthesis);\n  if (index === null) {\n    // node isn't in the list\n    return null;\n  }\n  var property = properties[index][identifier];\n  if ((0, _object.hasOwnProperty)(property, 'associativity')) {\n    if (property.associativity === 'left') {\n      return 'left';\n    }\n    if (property.associativity === 'right') {\n      return 'right';\n    }\n    // associativity is invalid\n    throw Error('\\'' + identifier + '\\' has the invalid associativity \\'' + property.associativity + '\\'.');\n  }\n\n  // associativity is undefined\n  return null;\n}\n\n/**\n * Check if an operator is associative with another operator.\n * Returns either true or false or null if not defined.\n *\n * @param {Node} nodeA\n * @param {Node} nodeB\n * @param {string} parenthesis\n * @return {boolean | null}\n */\nfunction isAssociativeWith(nodeA, nodeB, parenthesis) {\n  // ParenthesisNodes are only ignored when not in 'keep' mode\n  var a = parenthesis !== 'keep' ? nodeA.getContent() : nodeA;\n  var b = parenthesis !== 'keep' ? nodeA.getContent() : nodeB;\n  var identifierA = a.getIdentifier();\n  var identifierB = b.getIdentifier();\n  var index = getPrecedence(a, parenthesis);\n  if (index === null) {\n    // node isn't in the list\n    return null;\n  }\n  var property = properties[index][identifierA];\n  if ((0, _object.hasOwnProperty)(property, 'associativeWith') && property.associativeWith instanceof Array) {\n    for (var i = 0; i < property.associativeWith.length; i++) {\n      if (property.associativeWith[i] === identifierB) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // associativeWith is not defined\n  return null;\n}\n\n/**\n * Get the operator associated with a function name.\n * Returns a string with the operator symbol, or null if the\n * input is not the name of a function associated with an\n * operator.\n *\n * @param {string} Function name\n * @return {string | null} Associated operator symbol, if any\n */\nfunction getOperator(fn) {\n  var identifier = 'OperatorNode:' + fn;\n  var _iterator = _createForOfIteratorHelper(properties),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var group = _step.value;\n      if (identifier in group) {\n        return group[identifier].op;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return null;\n}"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,gBAAgB,GAAGA,gBAAgB;AAC3CF,OAAO,CAACG,WAAW,GAAGA,WAAW;AACjCH,OAAO,CAACI,aAAa,GAAGA,aAAa;AACrCJ,OAAO,CAACK,iBAAiB,GAAGA,iBAAiB;AAC7CL,OAAO,CAACM,UAAU,GAAG,KAAK,CAAC;AAC3B,IAAIC,OAAO,GAAGC,OAAO,CAAC,oBAAoB,CAAC;AAC3C,IAAIC,GAAG,GAAGD,OAAO,CAAC,gBAAgB,CAAC;AACnC,SAASE,0BAA0B,CAACC,CAAC,EAAEC,cAAc,EAAE;EAAE,IAAIC,EAAE,GAAG,OAAOC,MAAM,KAAK,WAAW,IAAIH,CAAC,CAACG,MAAM,CAACC,QAAQ,CAAC,IAAIJ,CAAC,CAAC,YAAY,CAAC;EAAE,IAAI,CAACE,EAAE,EAAE;IAAE,IAAIG,KAAK,CAACC,OAAO,CAACN,CAAC,CAAC,KAAKE,EAAE,GAAGK,2BAA2B,CAACP,CAAC,CAAC,CAAC,IAAIC,cAAc,IAAID,CAAC,IAAI,OAAOA,CAAC,CAACQ,MAAM,KAAK,QAAQ,EAAE;MAAE,IAAIN,EAAE,EAAEF,CAAC,GAAGE,EAAE;MAAE,IAAIO,CAAC,GAAG,CAAC;MAAE,IAAIC,CAAC,GAAG,SAASA,CAAC,GAAG,CAAC,CAAC;MAAE,OAAO;QAAEC,CAAC,EAAED,CAAC;QAAEE,CAAC,EAAE,SAASA,CAAC,GAAG;UAAE,IAAIH,CAAC,IAAIT,CAAC,CAACQ,MAAM,EAAE,OAAO;YAAEK,IAAI,EAAE;UAAK,CAAC;UAAE,OAAO;YAAEA,IAAI,EAAE,KAAK;YAAEvB,KAAK,EAAEU,CAAC,CAACS,CAAC,EAAE;UAAE,CAAC;QAAE,CAAC;QAAEK,CAAC,EAAE,SAASA,CAAC,CAACC,EAAE,EAAE;UAAE,MAAMA,EAAE;QAAE,CAAC;QAAEC,CAAC,EAAEN;MAAE,CAAC;IAAE;IAAE,MAAM,IAAIO,SAAS,CAAC,uIAAuI,CAAC;EAAE;EAAE,IAAIC,gBAAgB,GAAG,IAAI;IAAEC,MAAM,GAAG,KAAK;IAAEC,GAAG;EAAE,OAAO;IAAET,CAAC,EAAE,SAASA,CAAC,GAAG;MAAET,EAAE,GAAGA,EAAE,CAACmB,IAAI,CAACrB,CAAC,CAAC;IAAE,CAAC;IAAEY,CAAC,EAAE,SAASA,CAAC,GAAG;MAAE,IAAIU,IAAI,GAAGpB,EAAE,CAACqB,IAAI,EAAE;MAAEL,gBAAgB,GAAGI,IAAI,CAACT,IAAI;MAAE,OAAOS,IAAI;IAAE,CAAC;IAAER,CAAC,EAAE,SAASA,CAAC,CAACU,GAAG,EAAE;MAAEL,MAAM,GAAG,IAAI;MAAEC,GAAG,GAAGI,GAAG;IAAE,CAAC;IAAER,CAAC,EAAE,SAASA,CAAC,GAAG;MAAE,IAAI;QAAE,IAAI,CAACE,gBAAgB,IAAIhB,EAAE,CAAC,QAAQ,CAAC,IAAI,IAAI,EAAEA,EAAE,CAAC,QAAQ,CAAC,EAAE;MAAE,CAAC,SAAS;QAAE,IAAIiB,MAAM,EAAE,MAAMC,GAAG;MAAE;IAAE;EAAE,CAAC;AAAE;AAC3+B,SAASb,2BAA2B,CAACP,CAAC,EAAEyB,MAAM,EAAE;EAAE,IAAI,CAACzB,CAAC,EAAE;EAAQ,IAAI,OAAOA,CAAC,KAAK,QAAQ,EAAE,OAAO0B,iBAAiB,CAAC1B,CAAC,EAAEyB,MAAM,CAAC;EAAE,IAAIb,CAAC,GAAGzB,MAAM,CAACwC,SAAS,CAACC,QAAQ,CAACP,IAAI,CAACrB,CAAC,CAAC,CAAC6B,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EAAE,IAAIjB,CAAC,KAAK,QAAQ,IAAIZ,CAAC,CAAC8B,WAAW,EAAElB,CAAC,GAAGZ,CAAC,CAAC8B,WAAW,CAACC,IAAI;EAAE,IAAInB,CAAC,KAAK,KAAK,IAAIA,CAAC,KAAK,KAAK,EAAE,OAAOP,KAAK,CAAC2B,IAAI,CAAChC,CAAC,CAAC;EAAE,IAAIY,CAAC,KAAK,WAAW,IAAI,0CAA0C,CAACqB,IAAI,CAACrB,CAAC,CAAC,EAAE,OAAOc,iBAAiB,CAAC1B,CAAC,EAAEyB,MAAM,CAAC;AAAE;AAC/Z,SAASC,iBAAiB,CAACQ,GAAG,EAAEC,GAAG,EAAE;EAAE,IAAIA,GAAG,IAAI,IAAI,IAAIA,GAAG,GAAGD,GAAG,CAAC1B,MAAM,EAAE2B,GAAG,GAAGD,GAAG,CAAC1B,MAAM;EAAE,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAE2B,IAAI,GAAG,IAAI/B,KAAK,CAAC8B,GAAG,CAAC,EAAE1B,CAAC,GAAG0B,GAAG,EAAE1B,CAAC,EAAE,EAAE;IAAE2B,IAAI,CAAC3B,CAAC,CAAC,GAAGyB,GAAG,CAACzB,CAAC,CAAC;EAAE;EAAE,OAAO2B,IAAI;AAAE;AACtL,IAAIzC,UAAU,GAAG,CAAC;EAChB;EACA0C,cAAc,EAAE,CAAC,CAAC;EAClBC,sBAAsB,EAAE,CAAC;AAC3B,CAAC,EAAE;EACD;EACAC,eAAe,EAAE;IACfC,eAAe,EAAE,KAAK;IACtBC,gBAAgB,EAAE,KAAK;IACvBC,WAAW,EAAE;IACb;IACA;EACF;AACF,CAAC,EAAE;EACD;EACA,iBAAiB,EAAE;IACjBC,EAAE,EAAE,IAAI;IACRC,aAAa,EAAE,MAAM;IACrBC,eAAe,EAAE;EACnB;AACF,CAAC,EAAE;EACD;EACA,kBAAkB,EAAE;IAClBF,EAAE,EAAE,KAAK;IACTC,aAAa,EAAE,MAAM;IACrBC,eAAe,EAAE;EACnB;AACF,CAAC,EAAE;EACD;EACA,kBAAkB,EAAE;IAClBF,EAAE,EAAE,KAAK;IACTC,aAAa,EAAE,MAAM;IACrBC,eAAe,EAAE;EACnB;AACF,CAAC,EAAE;EACD;EACA,oBAAoB,EAAE;IACpBF,EAAE,EAAE,GAAG;IACPC,aAAa,EAAE,MAAM;IACrBC,eAAe,EAAE;EACnB;AACF,CAAC,EAAE;EACD;EACA,qBAAqB,EAAE;IACrBF,EAAE,EAAE,IAAI;IACRC,aAAa,EAAE,MAAM;IACrBC,eAAe,EAAE;EACnB;AACF,CAAC,EAAE;EACD;EACA,qBAAqB,EAAE;IACrBF,EAAE,EAAE,GAAG;IACPC,aAAa,EAAE,MAAM;IACrBC,eAAe,EAAE;EACnB;AACF,CAAC,EAAE;EACD;EACA,oBAAoB,EAAE;IACpBF,EAAE,EAAE,IAAI;IACRC,aAAa,EAAE,MAAM;IACrBC,eAAe,EAAE;EACnB,CAAC;EACD,sBAAsB,EAAE;IACtBF,EAAE,EAAE,IAAI;IACRC,aAAa,EAAE,MAAM;IACrBC,eAAe,EAAE;EACnB,CAAC;EACD,sBAAsB,EAAE;IACtBF,EAAE,EAAE,GAAG;IACPC,aAAa,EAAE,MAAM;IACrBC,eAAe,EAAE;EACnB,CAAC;EACD,qBAAqB,EAAE;IACrBF,EAAE,EAAE,GAAG;IACPC,aAAa,EAAE,MAAM;IACrBC,eAAe,EAAE;EACnB,CAAC;EACD,wBAAwB,EAAE;IACxBF,EAAE,EAAE,IAAI;IACRC,aAAa,EAAE,MAAM;IACrBC,eAAe,EAAE;EACnB,CAAC;EACD,uBAAuB,EAAE;IACvBF,EAAE,EAAE,IAAI;IACRC,aAAa,EAAE,MAAM;IACrBC,eAAe,EAAE;EACnB,CAAC;EACDC,cAAc,EAAE;IACdF,aAAa,EAAE,MAAM;IACrBC,eAAe,EAAE;EACnB;AACF,CAAC,EAAE;EACD;EACA,wBAAwB,EAAE;IACxBF,EAAE,EAAE,IAAI;IACRC,aAAa,EAAE,MAAM;IACrBC,eAAe,EAAE;EACnB,CAAC;EACD,8BAA8B,EAAE;IAC9BF,EAAE,EAAE,IAAI;IACRC,aAAa,EAAE,MAAM;IACrBC,eAAe,EAAE;EACnB,CAAC;EACD,4BAA4B,EAAE;IAC5BF,EAAE,EAAE,KAAK;IACTC,aAAa,EAAE,MAAM;IACrBC,eAAe,EAAE;EACnB;AACF,CAAC,EAAE;EACD;EACA,iBAAiB,EAAE;IACjBF,EAAE,EAAE,IAAI;IACRC,aAAa,EAAE,MAAM;IACrBC,eAAe,EAAE;EACnB;AACF,CAAC,EAAE;EACD;EACAE,SAAS,EAAE,CAAC;AACd,CAAC,EAAE;EACD;EACA,kBAAkB,EAAE;IAClBJ,EAAE,EAAE,GAAG;IACPC,aAAa,EAAE,MAAM;IACrBC,eAAe,EAAE,CAAC,kBAAkB,EAAE,uBAAuB;EAC/D,CAAC;EACD,uBAAuB,EAAE;IACvBF,EAAE,EAAE,GAAG;IACPC,aAAa,EAAE,MAAM;IACrBC,eAAe,EAAE;EACnB;AACF,CAAC,EAAE;EACD;EACA,uBAAuB,EAAE;IACvBF,EAAE,EAAE,GAAG;IACPC,aAAa,EAAE,MAAM;IACrBC,eAAe,EAAE,CAAC,uBAAuB,EAAE,qBAAqB,EAAE,sBAAsB,EAAE,oBAAoB;EAChH,CAAC;EACD,qBAAqB,EAAE;IACrBF,EAAE,EAAE,GAAG;IACPC,aAAa,EAAE,MAAM;IACrBC,eAAe,EAAE,EAAE;IACnBL,eAAe,EAAE,KAAK;IACtBC,gBAAgB,EAAE,KAAK;IACvBC,WAAW,EAAE;IACb;IACA;IACA;EACF,CAAC;;EAED,0BAA0B,EAAE;IAC1BC,EAAE,EAAE,IAAI;IACRC,aAAa,EAAE,MAAM;IACrBC,eAAe,EAAE,CAAC,uBAAuB,EAAE,qBAAqB,EAAE,0BAA0B,EAAE,uBAAuB;EACvH,CAAC;EACD,wBAAwB,EAAE;IACxBF,EAAE,EAAE,IAAI;IACRC,aAAa,EAAE,MAAM;IACrBC,eAAe,EAAE;EACnB,CAAC;EACD,kBAAkB,EAAE;IAClBF,EAAE,EAAE,KAAK;IACTC,aAAa,EAAE,MAAM;IACrBC,eAAe,EAAE;EACnB;AACF,CAAC,EAAE;EACD;EACA,uBAAuB,EAAE;IACvBD,aAAa,EAAE,MAAM;IACrBC,eAAe,EAAE,CAAC,uBAAuB,EAAE,qBAAqB,EAAE,sBAAsB,EAAE,oBAAoB;EAChH;AACF,CAAC,EAAE;EACD;EACA,wBAAwB,EAAE;IACxBF,EAAE,EAAE,GAAG;IACPC,aAAa,EAAE;EACjB,CAAC;EACD,yBAAyB,EAAE;IACzBD,EAAE,EAAE,GAAG;IACPC,aAAa,EAAE;EACjB,CAAC;EACD,qBAAqB,EAAE;IACrBD,EAAE,EAAE,GAAG;IACPC,aAAa,EAAE;EACjB,CAAC;EACD,kBAAkB,EAAE;IAClBD,EAAE,EAAE,KAAK;IACTC,aAAa,EAAE;EACjB;AACF,CAAC,EAAE;EACD;EACA,kBAAkB,EAAE;IAClBD,EAAE,EAAE,GAAG;IACPC,aAAa,EAAE,OAAO;IACtBC,eAAe,EAAE,EAAE;IACnBJ,gBAAgB,EAAE;IAClB;IACA;IACA;EACF,CAAC;;EAED,qBAAqB,EAAE;IACrBE,EAAE,EAAE,IAAI;IACRC,aAAa,EAAE,OAAO;IACtBC,eAAe,EAAE;EACnB;AACF,CAAC,EAAE;EACD;EACA,wBAAwB,EAAE;IACxBF,EAAE,EAAE,GAAG;IACPC,aAAa,EAAE;EACjB;AACF,CAAC,EAAE;EACD;EACA,yBAAyB,EAAE;IACzBD,EAAE,EAAE,GAAG;IACPC,aAAa,EAAE;EACjB;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACAvD,OAAO,CAACM,UAAU,GAAGA,UAAU;AAC/B,SAASqD,WAAW,CAACC,KAAK,EAAEC,WAAW,EAAE;EACvC,IAAI,CAACA,WAAW,IAAIA,WAAW,KAAK,MAAM,EAAE,OAAOD,KAAK;EACxD,IAAIE,IAAI,GAAGF,KAAK;EAChB,OAAO,CAAC,CAAC,EAAEnD,GAAG,CAACsD,iBAAiB,EAAED,IAAI,CAAC,EAAE;IACvCA,IAAI,GAAGA,IAAI,CAACE,OAAO;EACrB;EACA,OAAOF,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS1D,aAAa,CAACwD,KAAK,EAAEC,WAAW,EAAEI,QAAQ,EAAEC,MAAM,EAAE;EAC3D,IAAIJ,IAAI,GAAGF,KAAK;EAChB,IAAIC,WAAW,KAAK,MAAM,EAAE;IAC1B;IACAC,IAAI,GAAGF,KAAK,CAACO,UAAU,EAAE;EAC3B;EACA,IAAIC,UAAU,GAAGN,IAAI,CAACO,aAAa,EAAE;EACrC,IAAIC,UAAU,GAAG,IAAI;EACrB,KAAK,IAAIlD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGd,UAAU,CAACa,MAAM,EAAEC,CAAC,EAAE,EAAE;IAC1C,IAAIgD,UAAU,IAAI9D,UAAU,CAACc,CAAC,CAAC,EAAE;MAC/BkD,UAAU,GAAGlD,CAAC;MACd;IACF;EACF;EACA;EACA;EACA,IAAIgD,UAAU,KAAK,uBAAuB,IAAIN,IAAI,CAACG,QAAQ,IAAIA,QAAQ,KAAK,MAAM,EAAE;IAClF,IAAIM,OAAO,GAAGZ,WAAW,CAACG,IAAI,CAACU,IAAI,CAAC,CAAC,CAAC,EAAEX,WAAW,CAAC;IACpD,IAAI,EAAE,CAAC,CAAC,EAAEpD,GAAG,CAACgE,cAAc,EAAEF,OAAO,CAAC,IAAIL,MAAM,IAAIA,MAAM,CAACG,aAAa,EAAE,KAAK,qBAAqB,IAAI,CAAC,CAAC,EAAE5D,GAAG,CAACiE,SAAS,EAAEf,WAAW,CAACO,MAAM,CAACM,IAAI,CAAC,CAAC,CAAC,EAAEX,WAAW,CAAC,CAAC,CAAC,IAAI,EAAEU,OAAO,CAACF,aAAa,EAAE,KAAK,qBAAqB,IAAI,CAAC,CAAC,EAAE5D,GAAG,CAACiE,SAAS,EAAEf,WAAW,CAACY,OAAO,CAACC,IAAI,CAAC,CAAC,CAAC,EAAEX,WAAW,CAAC,CAAC,IAAI,CAAC,CAAC,EAAEpD,GAAG,CAACgE,cAAc,EAAEd,WAAW,CAACY,OAAO,CAACC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;MACvVF,UAAU,IAAI,CAAC;IACjB;EACF;EACA,OAAOA,UAAU;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASpE,gBAAgB,CAAC0D,KAAK,EAAEC,WAAW,EAAE;EAC5C,IAAIC,IAAI,GAAGF,KAAK;EAChB,IAAIC,WAAW,KAAK,MAAM,EAAE;IAC1B;IACAC,IAAI,GAAGF,KAAK,CAACO,UAAU,EAAE;EAC3B;EACA,IAAIC,UAAU,GAAGN,IAAI,CAACO,aAAa,EAAE;EACrC,IAAIM,KAAK,GAAGvE,aAAa,CAAC0D,IAAI,EAAED,WAAW,CAAC;EAC5C,IAAIc,KAAK,KAAK,IAAI,EAAE;IAClB;IACA,OAAO,IAAI;EACb;EACA,IAAIC,QAAQ,GAAGtE,UAAU,CAACqE,KAAK,CAAC,CAACP,UAAU,CAAC;EAC5C,IAAI,CAAC,CAAC,EAAE7D,OAAO,CAACsE,cAAc,EAAED,QAAQ,EAAE,eAAe,CAAC,EAAE;IAC1D,IAAIA,QAAQ,CAACrB,aAAa,KAAK,MAAM,EAAE;MACrC,OAAO,MAAM;IACf;IACA,IAAIqB,QAAQ,CAACrB,aAAa,KAAK,OAAO,EAAE;MACtC,OAAO,OAAO;IAChB;IACA;IACA,MAAMuB,KAAK,CAAC,IAAI,GAAGV,UAAU,GAAG,qCAAqC,GAAGQ,QAAQ,CAACrB,aAAa,GAAG,KAAK,CAAC;EACzG;;EAEA;EACA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASlD,iBAAiB,CAAC0E,KAAK,EAAEC,KAAK,EAAEnB,WAAW,EAAE;EACpD;EACA,IAAIoB,CAAC,GAAGpB,WAAW,KAAK,MAAM,GAAGkB,KAAK,CAACZ,UAAU,EAAE,GAAGY,KAAK;EAC3D,IAAIG,CAAC,GAAGrB,WAAW,KAAK,MAAM,GAAGkB,KAAK,CAACZ,UAAU,EAAE,GAAGa,KAAK;EAC3D,IAAIG,WAAW,GAAGF,CAAC,CAACZ,aAAa,EAAE;EACnC,IAAIe,WAAW,GAAGF,CAAC,CAACb,aAAa,EAAE;EACnC,IAAIM,KAAK,GAAGvE,aAAa,CAAC6E,CAAC,EAAEpB,WAAW,CAAC;EACzC,IAAIc,KAAK,KAAK,IAAI,EAAE;IAClB;IACA,OAAO,IAAI;EACb;EACA,IAAIC,QAAQ,GAAGtE,UAAU,CAACqE,KAAK,CAAC,CAACQ,WAAW,CAAC;EAC7C,IAAI,CAAC,CAAC,EAAE5E,OAAO,CAACsE,cAAc,EAAED,QAAQ,EAAE,iBAAiB,CAAC,IAAIA,QAAQ,CAACpB,eAAe,YAAYxC,KAAK,EAAE;IACzG,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwD,QAAQ,CAACpB,eAAe,CAACrC,MAAM,EAAEC,CAAC,EAAE,EAAE;MACxD,IAAIwD,QAAQ,CAACpB,eAAe,CAACpC,CAAC,CAAC,KAAKgE,WAAW,EAAE;QAC/C,OAAO,IAAI;MACb;IACF;IACA,OAAO,KAAK;EACd;;EAEA;EACA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASjF,WAAW,CAACkF,EAAE,EAAE;EACvB,IAAIjB,UAAU,GAAG,eAAe,GAAGiB,EAAE;EACrC,IAAIC,SAAS,GAAG5E,0BAA0B,CAACJ,UAAU,CAAC;IACpDiF,KAAK;EACP,IAAI;IACF,KAAKD,SAAS,CAAChE,CAAC,EAAE,EAAE,CAAC,CAACiE,KAAK,GAAGD,SAAS,CAAC/D,CAAC,EAAE,EAAEC,IAAI,GAAG;MAClD,IAAIgE,KAAK,GAAGD,KAAK,CAACtF,KAAK;MACvB,IAAImE,UAAU,IAAIoB,KAAK,EAAE;QACvB,OAAOA,KAAK,CAACpB,UAAU,CAAC,CAACd,EAAE;MAC7B;IACF;EACF,CAAC,CAAC,OAAOvB,GAAG,EAAE;IACZuD,SAAS,CAAC7D,CAAC,CAACM,GAAG,CAAC;EAClB,CAAC,SAAS;IACRuD,SAAS,CAAC3D,CAAC,EAAE;EACf;EACA,OAAO,IAAI;AACb"},"metadata":{},"sourceType":"script"}