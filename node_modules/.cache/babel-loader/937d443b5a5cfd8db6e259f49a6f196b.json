{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createComplexEigs = createComplexEigs;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _object = require(\"../../../utils/object.js\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction createComplexEigs(_ref) {\n  var addScalar = _ref.addScalar,\n    subtract = _ref.subtract,\n    flatten = _ref.flatten,\n    multiply = _ref.multiply,\n    multiplyScalar = _ref.multiplyScalar,\n    divideScalar = _ref.divideScalar,\n    sqrt = _ref.sqrt,\n    abs = _ref.abs,\n    bignumber = _ref.bignumber,\n    diag = _ref.diag,\n    inv = _ref.inv,\n    qr = _ref.qr,\n    usolve = _ref.usolve,\n    usolveAll = _ref.usolveAll,\n    equal = _ref.equal,\n    complex = _ref.complex,\n    larger = _ref.larger,\n    smaller = _ref.smaller,\n    matrixFromColumns = _ref.matrixFromColumns,\n    dot = _ref.dot;\n  /**\n   * @param {number[][]} arr the matrix to find eigenvalues of\n   * @param {number} N size of the matrix\n   * @param {number|BigNumber} prec precision, anything lower will be considered zero\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @param {boolean} findVectors should we find eigenvectors?\n   *\n   * @returns {{ values: number[], vectors: number[][] }}\n   */\n  function complexEigs(arr, N, prec, type, findVectors) {\n    if (findVectors === undefined) {\n      findVectors = true;\n    }\n\n    // TODO check if any row/col are zero except the diagonal\n\n    // make sure corresponding rows and columns have similar magnitude\n    // important because of numerical stability\n    // MODIFIES arr by side effect!\n    var R = balance(arr, N, prec, type, findVectors);\n\n    // R is the row transformation matrix\n    // arr = A' = R A R⁻¹, A is the original matrix\n    // (if findVectors is false, R is undefined)\n    // (And so to return to original matrix: A = R⁻¹ arr R)\n\n    // TODO if magnitudes of elements vary over many orders,\n    // move greatest elements to the top left corner\n\n    // using similarity transformations, reduce the matrix\n    // to Hessenberg form (upper triangular plus one subdiagonal row)\n    // updates the transformation matrix R with new row operationsq\n    // MODIFIES arr by side effect!\n    reduceToHessenberg(arr, N, prec, type, findVectors, R);\n    // still true that original A = R⁻¹ arr R)\n\n    // find eigenvalues\n    var _iterateUntilTriangul = iterateUntilTriangular(arr, N, prec, type, findVectors),\n      values = _iterateUntilTriangul.values,\n      C = _iterateUntilTriangul.C;\n\n    // values is the list of eigenvalues, C is the column\n    // transformation matrix that transforms arr, the hessenberg\n    // matrix, to upper triangular\n    // (So U = C⁻¹ arr C and the relationship between current arr\n    // and original A is unchanged.)\n\n    var vectors;\n    if (findVectors) {\n      vectors = findEigenvectors(arr, N, C, R, values, prec, type);\n      vectors = matrixFromColumns.apply(void 0, (0, _toConsumableArray2[\"default\"])(vectors));\n    }\n    return {\n      values: values,\n      vectors: vectors\n    };\n  }\n\n  /**\n   * @param {number[][]} arr\n   * @param {number} N\n   * @param {number} prec\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {number[][]}\n   */\n  function balance(arr, N, prec, type, findVectors) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var realzero = big ? bignumber(0) : 0;\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n    var realone = big ? bignumber(1) : 1;\n\n    // base of the floating-point arithmetic\n    var radix = big ? bignumber(10) : 2;\n    var radixSq = multiplyScalar(radix, radix);\n\n    // the diagonal transformation matrix R\n    var Rdiag;\n    if (findVectors) {\n      Rdiag = Array(N).fill(one);\n    }\n\n    // this isn't the only time we loop thru the matrix...\n    var last = false;\n    while (!last) {\n      // ...haha I'm joking! unless...\n      last = true;\n      for (var i = 0; i < N; i++) {\n        // compute the taxicab norm of i-th column and row\n        // TODO optimize for complex numbers\n        var colNorm = realzero;\n        var rowNorm = realzero;\n        for (var j = 0; j < N; j++) {\n          if (i === j) continue;\n          var c = abs(arr[i][j]); // should be real\n          colNorm = addScalar(colNorm, c);\n          rowNorm = addScalar(rowNorm, c);\n        }\n        if (!equal(colNorm, 0) && !equal(rowNorm, 0)) {\n          // find integer power closest to balancing the matrix\n          // (we want to scale only by integer powers of radix,\n          // so that we don't lose any precision due to round-off)\n\n          var f = realone;\n          var _c = colNorm;\n          var rowDivRadix = divideScalar(rowNorm, radix);\n          var rowMulRadix = multiplyScalar(rowNorm, radix);\n          while (smaller(_c, rowDivRadix)) {\n            _c = multiplyScalar(_c, radixSq);\n            f = multiplyScalar(f, radix);\n          }\n          while (larger(_c, rowMulRadix)) {\n            _c = divideScalar(_c, radixSq);\n            f = divideScalar(f, radix);\n          }\n\n          // check whether balancing is needed\n          // condition = (c + rowNorm) / f < 0.95 * (colNorm + rowNorm)\n          var condition = smaller(divideScalar(addScalar(_c, rowNorm), f), multiplyScalar(addScalar(colNorm, rowNorm), 0.95));\n\n          // apply balancing similarity transformation\n          if (condition) {\n            // we should loop once again to check whether\n            // another rebalancing is needed\n            last = false;\n            var g = divideScalar(1, f);\n            for (var _j = 0; _j < N; _j++) {\n              if (i === _j) {\n                continue;\n              }\n              arr[i][_j] = multiplyScalar(arr[i][_j], f);\n              arr[_j][i] = multiplyScalar(arr[_j][i], g);\n            }\n\n            // keep track of transformations\n            if (findVectors) {\n              Rdiag[i] = multiplyScalar(Rdiag[i], f);\n            }\n          }\n        }\n      }\n    }\n\n    // return the diagonal row transformation matrix\n    return diag(Rdiag);\n  }\n\n  /**\n   * @param {number[][]} arr\n   * @param {number} N\n   * @param {number} prec\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @param {boolean} findVectors\n   * @param {number[][]} R the row transformation matrix that will be modified\n   */\n  function reduceToHessenberg(arr, N, prec, type, findVectors, R) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n    if (big) {\n      prec = bignumber(prec);\n    }\n    for (var i = 0; i < N - 2; i++) {\n      // Find the largest subdiag element in the i-th col\n\n      var maxIndex = 0;\n      var max = zero;\n      for (var j = i + 1; j < N; j++) {\n        var el = arr[j][i];\n        if (smaller(abs(max), abs(el))) {\n          max = el;\n          maxIndex = j;\n        }\n      }\n\n      // This col is pivoted, no need to do anything\n      if (smaller(abs(max), prec)) {\n        continue;\n      }\n      if (maxIndex !== i + 1) {\n        // Interchange maxIndex-th and (i+1)-th row\n        var tmp1 = arr[maxIndex];\n        arr[maxIndex] = arr[i + 1];\n        arr[i + 1] = tmp1;\n\n        // Interchange maxIndex-th and (i+1)-th column\n        for (var _j2 = 0; _j2 < N; _j2++) {\n          var tmp2 = arr[_j2][maxIndex];\n          arr[_j2][maxIndex] = arr[_j2][i + 1];\n          arr[_j2][i + 1] = tmp2;\n        }\n\n        // keep track of transformations\n        if (findVectors) {\n          var tmp3 = R[maxIndex];\n          R[maxIndex] = R[i + 1];\n          R[i + 1] = tmp3;\n        }\n      }\n\n      // Reduce following rows and columns\n      for (var _j3 = i + 2; _j3 < N; _j3++) {\n        var n = divideScalar(arr[_j3][i], max);\n        if (n === 0) {\n          continue;\n        }\n\n        // from j-th row subtract n-times (i+1)th row\n        for (var k = 0; k < N; k++) {\n          arr[_j3][k] = subtract(arr[_j3][k], multiplyScalar(n, arr[i + 1][k]));\n        }\n\n        // to (i+1)th column add n-times j-th column\n        for (var _k = 0; _k < N; _k++) {\n          arr[_k][i + 1] = addScalar(arr[_k][i + 1], multiplyScalar(n, arr[_k][_j3]));\n        }\n\n        // keep track of transformations\n        if (findVectors) {\n          for (var _k2 = 0; _k2 < N; _k2++) {\n            R[_j3][_k2] = subtract(R[_j3][_k2], multiplyScalar(n, R[i + 1][_k2]));\n          }\n        }\n      }\n    }\n    return R;\n  }\n\n  /**\n   * @returns {{values: values, C: Matrix}}\n   * @see Press, Wiliams: Numerical recipes in Fortran 77\n   * @see https://en.wikipedia.org/wiki/QR_algorithm\n   */\n  function iterateUntilTriangular(A, N, prec, type, findVectors) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n    if (big) {\n      prec = bignumber(prec);\n    }\n\n    // The Francis Algorithm\n    // The core idea of this algorithm is that doing successive\n    // A' = Q⁺AQ transformations will eventually converge to block-\n    // upper-triangular with diagonal blocks either 1x1 or 2x2.\n    // The Q here is the one from the QR decomposition, A = QR.\n    // Since the eigenvalues of a block-upper-triangular matrix are\n    // the eigenvalues of its diagonal blocks and we know how to find\n    // eigenvalues of a 2x2 matrix, we know the eigenvalues of A.\n\n    var arr = (0, _object.clone)(A);\n\n    // the list of converged eigenvalues\n    var lambdas = [];\n\n    // size of arr, which will get smaller as eigenvalues converge\n    var n = N;\n\n    // the diagonal of the block-diagonal matrix that turns\n    // converged 2x2 matrices into upper triangular matrices\n    var Sdiag = [];\n\n    // N×N matrix describing the overall transformation done during the QR algorithm\n    var Qtotal = findVectors ? diag(Array(N).fill(one)) : undefined;\n\n    // n×n matrix describing the QR transformations done since last convergence\n    var Qpartial = findVectors ? diag(Array(n).fill(one)) : undefined;\n\n    // last eigenvalue converged before this many steps\n    var lastConvergenceBefore = 0;\n    while (lastConvergenceBefore <= 100) {\n      lastConvergenceBefore += 1;\n\n      // TODO if the convergence is slow, do something clever\n\n      // Perform the factorization\n\n      var k = 0; // TODO set close to an eigenvalue\n\n      for (var i = 0; i < n; i++) {\n        arr[i][i] = subtract(arr[i][i], k);\n      }\n\n      // TODO do an implicit QR transformation\n      var _qr = qr(arr),\n        Q = _qr.Q,\n        R = _qr.R;\n      arr = multiply(R, Q);\n      for (var _i = 0; _i < n; _i++) {\n        arr[_i][_i] = addScalar(arr[_i][_i], k);\n      }\n\n      // keep track of transformations\n      if (findVectors) {\n        Qpartial = multiply(Qpartial, Q);\n      }\n\n      // The rightmost diagonal element converged to an eigenvalue\n      if (n === 1 || smaller(abs(arr[n - 1][n - 2]), prec)) {\n        lastConvergenceBefore = 0;\n        lambdas.push(arr[n - 1][n - 1]);\n\n        // keep track of transformations\n        if (findVectors) {\n          Sdiag.unshift([[1]]);\n          inflateMatrix(Qpartial, N);\n          Qtotal = multiply(Qtotal, Qpartial);\n          if (n > 1) {\n            Qpartial = diag(Array(n - 1).fill(one));\n          }\n        }\n\n        // reduce the matrix size\n        n -= 1;\n        arr.pop();\n        for (var _i2 = 0; _i2 < n; _i2++) {\n          arr[_i2].pop();\n        }\n\n        // The rightmost diagonal 2x2 block converged\n      } else if (n === 2 || smaller(abs(arr[n - 2][n - 3]), prec)) {\n        lastConvergenceBefore = 0;\n        var ll = eigenvalues2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1]);\n        lambdas.push.apply(lambdas, (0, _toConsumableArray2[\"default\"])(ll));\n\n        // keep track of transformations\n        if (findVectors) {\n          Sdiag.unshift(jordanBase2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1], ll[0], ll[1], prec, type));\n          inflateMatrix(Qpartial, N);\n          Qtotal = multiply(Qtotal, Qpartial);\n          if (n > 2) {\n            Qpartial = diag(Array(n - 2).fill(one));\n          }\n        }\n\n        // reduce the matrix size\n        n -= 2;\n        arr.pop();\n        arr.pop();\n        for (var _i3 = 0; _i3 < n; _i3++) {\n          arr[_i3].pop();\n          arr[_i3].pop();\n        }\n      }\n      if (n === 0) {\n        break;\n      }\n    }\n\n    // standard sorting\n    lambdas.sort(function (a, b) {\n      return +subtract(abs(a), abs(b));\n    });\n\n    // the algorithm didn't converge\n    if (lastConvergenceBefore > 100) {\n      var err = Error('The eigenvalues failed to converge. Only found these eigenvalues: ' + lambdas.join(', '));\n      err.values = lambdas;\n      err.vectors = [];\n      throw err;\n    }\n\n    // combine the overall QR transformation Qtotal with the subsequent\n    // transformation S that turns the diagonal 2x2 blocks to upper triangular\n    var C = findVectors ? multiply(Qtotal, blockDiag(Sdiag, N)) : undefined;\n    return {\n      values: lambdas,\n      C: C\n    };\n  }\n\n  /**\n   * @param {Matrix} A hessenberg-form matrix\n   * @param {number} N size of A\n   * @param {Matrix} C column transformation matrix that turns A into upper triangular\n   * @param {Matrix} R similarity that turns original matrix into A\n   * @param {number[]} values array of eigenvalues of A\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {number[][]} eigenvalues\n   */\n  function findEigenvectors(A, N, C, R, values, prec, type) {\n    var Cinv = inv(C);\n    var U = multiply(Cinv, A, C);\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n\n    // turn values into a kind of \"multiset\"\n    // this way it is easier to find eigenvectors\n    var uniqueValues = [];\n    var multiplicities = [];\n    var _iterator = _createForOfIteratorHelper(values),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var λ = _step.value;\n        var _i4 = indexOf(uniqueValues, λ, equal);\n        if (_i4 === -1) {\n          uniqueValues.push(λ);\n          multiplicities.push(1);\n        } else {\n          multiplicities[_i4] += 1;\n        }\n      }\n\n      // find eigenvectors by solving U − λE = 0\n      // TODO replace with an iterative eigenvector algorithm\n      // (this one might fail for imprecise eigenvalues)\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var vectors = [];\n    var len = uniqueValues.length;\n    var b = Array(N).fill(zero);\n    var E = diag(Array(N).fill(one));\n\n    // eigenvalues for which usolve failed (due to numerical error)\n    var failedLambdas = [];\n    var _loop = function _loop(i) {\n      var λ = uniqueValues[i];\n      var S = subtract(U, multiply(λ, E)); // the characteristic matrix\n\n      var solutions = usolveAll(S, b);\n      solutions.shift(); // ignore the null vector\n\n      // looks like we missed something, try inverse iteration\n      while (solutions.length < multiplicities[i]) {\n        var approxVec = inverseIterate(S, N, solutions, prec, type);\n        if (approxVec == null) {\n          // no more vectors were found\n          failedLambdas.push(λ);\n          break;\n        }\n        solutions.push(approxVec);\n      }\n\n      // Transform back into original array coordinates\n      var correction = multiply(inv(R), C);\n      solutions = solutions.map(function (v) {\n        return multiply(correction, v);\n      });\n      vectors.push.apply(vectors, (0, _toConsumableArray2[\"default\"])(solutions.map(function (v) {\n        return flatten(v);\n      })));\n    };\n    for (var i = 0; i < len; i++) {\n      _loop(i);\n    }\n    if (failedLambdas.length !== 0) {\n      var err = new Error('Failed to find eigenvectors for the following eigenvalues: ' + failedLambdas.join(', '));\n      err.values = values;\n      err.vectors = vectors;\n      throw err;\n    }\n    return vectors;\n  }\n\n  /**\n   * Compute the eigenvalues of an 2x2 matrix\n   * @return {[number,number]}\n   */\n  function eigenvalues2x2(a, b, c, d) {\n    // λ± = ½ trA ± ½ √( tr²A - 4 detA )\n    var trA = addScalar(a, d);\n    var detA = subtract(multiplyScalar(a, d), multiplyScalar(b, c));\n    var x = multiplyScalar(trA, 0.5);\n    var y = multiplyScalar(sqrt(subtract(multiplyScalar(trA, trA), multiplyScalar(4, detA))), 0.5);\n    return [addScalar(x, y), subtract(x, y)];\n  }\n\n  /**\n   * For an 2x2 matrix compute the transformation matrix S,\n   * so that SAS⁻¹ is an upper triangular matrix\n   * @return {[[number,number],[number,number]]}\n   * @see https://math.berkeley.edu/~ogus/old/Math_54-05/webfoils/jordan.pdf\n   * @see http://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html\n   */\n  function jordanBase2x2(a, b, c, d, l1, l2, prec, type) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n\n    // matrix is already upper triangular\n    // return an identity matrix\n    if (smaller(abs(c), prec)) {\n      return [[one, zero], [zero, one]];\n    }\n\n    // matrix is diagonalizable\n    // return its eigenvectors as columns\n    if (larger(abs(subtract(l1, l2)), prec)) {\n      return [[subtract(l1, d), subtract(l2, d)], [c, c]];\n    }\n\n    // matrix is not diagonalizable\n    // compute off-diagonal elements of N = A - λI\n    // N₁₂ = 0 ⇒ S = ( N⃗₁, I⃗₁ )\n    // N₁₂ ≠ 0 ⇒ S = ( N⃗₂, I⃗₂ )\n\n    var na = subtract(a, l1);\n    var nb = subtract(b, l1);\n    var nc = subtract(c, l1);\n    var nd = subtract(d, l1);\n    if (smaller(abs(nb), prec)) {\n      return [[na, one], [nc, zero]];\n    } else {\n      return [[nb, zero], [nd, one]];\n    }\n  }\n\n  /**\n   * Enlarge the matrix from n×n to N×N, setting the new\n   * elements to 1 on diagonal and 0 elsewhere\n   */\n  function inflateMatrix(arr, N) {\n    // add columns\n    for (var i = 0; i < arr.length; i++) {\n      var _arr$i;\n      (_arr$i = arr[i]).push.apply(_arr$i, (0, _toConsumableArray2[\"default\"])(Array(N - arr[i].length).fill(0)));\n    }\n\n    // add rows\n    for (var _i5 = arr.length; _i5 < N; _i5++) {\n      arr.push(Array(N).fill(0));\n      arr[_i5][_i5] = 1;\n    }\n    return arr;\n  }\n\n  /**\n   * Create a block-diagonal matrix with the given square matrices on the diagonal\n   * @param {Matrix[] | number[][][]} arr array of matrices to be placed on the diagonal\n   * @param {number} N the size of the resulting matrix\n   */\n  function blockDiag(arr, N) {\n    var M = [];\n    for (var i = 0; i < N; i++) {\n      M[i] = Array(N).fill(0);\n    }\n    var I = 0;\n    var _iterator2 = _createForOfIteratorHelper(arr),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var sub = _step2.value;\n        var n = sub.length;\n        for (var _i6 = 0; _i6 < n; _i6++) {\n          for (var j = 0; j < n; j++) {\n            M[I + _i6][I + j] = sub[_i6][j];\n          }\n        }\n        I += n;\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    return M;\n  }\n\n  /**\n   * Finds the index of an element in an array using a custom equality function\n   * @template T\n   * @param {Array<T>} arr array in which to search\n   * @param {T} el the element to find\n   * @param {function(T, T): boolean} fn the equality function, first argument is an element of `arr`, the second is always `el`\n   * @returns {number} the index of `el`, or -1 when it's not in `arr`\n   */\n  function indexOf(arr, el, fn) {\n    for (var i = 0; i < arr.length; i++) {\n      if (fn(arr[i], el)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Provided a near-singular upper-triangular matrix A and a list of vectors,\n   * finds an eigenvector of A with the smallest eigenvalue, which is orthogonal\n   * to each vector in the list\n   * @template T\n   * @param {T[][]} A near-singular square matrix\n   * @param {number} N dimension\n   * @param {T[][]} orthog list of vectors\n   * @param {number} prec epsilon\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @return {T[] | null} eigenvector\n   *\n   * @see Numerical Recipes for Fortran 77 – 11.7 Eigenvalues or Eigenvectors by Inverse Iteration\n   */\n  function inverseIterate(A, N, orthog, prec, type) {\n    var largeNum = type === 'BigNumber' ? bignumber(1000) : 1000;\n    var b; // the vector\n\n    // you better choose a random vector before I count to five\n    var i = 0;\n    while (true) {\n      b = randomOrthogonalVector(N, orthog, type);\n      b = usolve(A, b);\n      if (larger(norm(b), largeNum)) {\n        break;\n      }\n      if (++i >= 5) {\n        return null;\n      }\n    }\n\n    // you better converge before I count to ten\n    i = 0;\n    while (true) {\n      var c = usolve(A, b);\n      if (smaller(norm(orthogonalComplement(b, [c])), prec)) {\n        break;\n      }\n      if (++i >= 10) {\n        return null;\n      }\n      b = normalize(c);\n    }\n    return b;\n  }\n\n  /**\n   * Generates a random unit vector of dimension N, orthogonal to each vector in the list\n   * @template T\n   * @param {number} N dimension\n   * @param {T[][]} orthog list of vectors\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {T[]} random vector\n   */\n  function randomOrthogonalVector(N, orthog, type) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n\n    // generate random vector with the correct type\n    var v = Array(N).fill(0).map(function (_) {\n      return 2 * Math.random() - 1;\n    });\n    if (big) {\n      v = v.map(function (n) {\n        return bignumber(n);\n      });\n    }\n    if (cplx) {\n      v = v.map(function (n) {\n        return complex(n);\n      });\n    }\n\n    // project to orthogonal complement\n    v = orthogonalComplement(v, orthog);\n\n    // normalize\n    return normalize(v, type);\n  }\n\n  /**\n   * Project vector v to the orthogonal complement of an array of vectors\n   */\n  function orthogonalComplement(v, orthog) {\n    var _iterator3 = _createForOfIteratorHelper(orthog),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var w = _step3.value;\n        // v := v − (w, v)/∥w∥² w\n        v = subtract(v, multiply(divideScalar(dot(w, v), dot(w, w)), w));\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    return v;\n  }\n\n  /**\n   * Calculate the norm of a vector.\n   * We can't use math.norm because factory can't handle circular dependency.\n   * Seriously, I'm really fed up with factory.\n   */\n  function norm(v) {\n    return abs(sqrt(dot(v, v)));\n  }\n\n  /**\n   * Normalize a vector\n   * @template T\n   * @param {T[]} v\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {T[]} normalized vec\n   */\n  function normalize(v, type) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n    return multiply(divideScalar(one, norm(v)), v);\n  }\n  return complexEigs;\n}","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","createComplexEigs","_toConsumableArray2","_object","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","length","i","F","s","n","done","e","_e","f","TypeError","normalCompletion","didErr","err","call","step","next","_e2","minLen","_arrayLikeToArray","prototype","toString","slice","constructor","name","from","test","arr","len","arr2","_ref","addScalar","subtract","flatten","multiply","multiplyScalar","divideScalar","sqrt","abs","bignumber","diag","inv","qr","usolve","usolveAll","equal","complex","larger","smaller","matrixFromColumns","dot","complexEigs","N","prec","type","findVectors","undefined","R","balance","reduceToHessenberg","_iterateUntilTriangul","iterateUntilTriangular","values","C","vectors","findEigenvectors","apply","big","cplx","realzero","one","realone","radix","radixSq","Rdiag","fill","last","colNorm","rowNorm","j","c","_c","rowDivRadix","rowMulRadix","condition","g","_j","zero","maxIndex","max","el","tmp1","_j2","tmp2","tmp3","_j3","k","_k","_k2","A","clone","lambdas","Sdiag","Qtotal","Qpartial","lastConvergenceBefore","_qr","Q","_i","push","unshift","inflateMatrix","pop","_i2","ll","eigenvalues2x2","jordanBase2x2","_i3","sort","a","b","Error","join","blockDiag","Cinv","U","uniqueValues","multiplicities","_iterator","_step","λ","_i4","indexOf","E","failedLambdas","_loop","S","solutions","shift","approxVec","inverseIterate","correction","map","v","d","trA","detA","x","y","l1","l2","na","nb","nc","nd","_arr$i","_i5","M","I","_iterator2","_step2","sub","_i6","fn","orthog","largeNum","randomOrthogonalVector","norm","orthogonalComplement","normalize","_","Math","random","_iterator3","_step3","w"],"sources":["C:/Users/Admin/Desktop/React-Web-main/node_modules/mathjs/lib/cjs/function/matrix/eigs/complexEigs.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createComplexEigs = createComplexEigs;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _object = require(\"../../../utils/object.js\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction createComplexEigs(_ref) {\n  var addScalar = _ref.addScalar,\n    subtract = _ref.subtract,\n    flatten = _ref.flatten,\n    multiply = _ref.multiply,\n    multiplyScalar = _ref.multiplyScalar,\n    divideScalar = _ref.divideScalar,\n    sqrt = _ref.sqrt,\n    abs = _ref.abs,\n    bignumber = _ref.bignumber,\n    diag = _ref.diag,\n    inv = _ref.inv,\n    qr = _ref.qr,\n    usolve = _ref.usolve,\n    usolveAll = _ref.usolveAll,\n    equal = _ref.equal,\n    complex = _ref.complex,\n    larger = _ref.larger,\n    smaller = _ref.smaller,\n    matrixFromColumns = _ref.matrixFromColumns,\n    dot = _ref.dot;\n  /**\n   * @param {number[][]} arr the matrix to find eigenvalues of\n   * @param {number} N size of the matrix\n   * @param {number|BigNumber} prec precision, anything lower will be considered zero\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @param {boolean} findVectors should we find eigenvectors?\n   *\n   * @returns {{ values: number[], vectors: number[][] }}\n   */\n  function complexEigs(arr, N, prec, type, findVectors) {\n    if (findVectors === undefined) {\n      findVectors = true;\n    }\n\n    // TODO check if any row/col are zero except the diagonal\n\n    // make sure corresponding rows and columns have similar magnitude\n    // important because of numerical stability\n    // MODIFIES arr by side effect!\n    var R = balance(arr, N, prec, type, findVectors);\n\n    // R is the row transformation matrix\n    // arr = A' = R A R⁻¹, A is the original matrix\n    // (if findVectors is false, R is undefined)\n    // (And so to return to original matrix: A = R⁻¹ arr R)\n\n    // TODO if magnitudes of elements vary over many orders,\n    // move greatest elements to the top left corner\n\n    // using similarity transformations, reduce the matrix\n    // to Hessenberg form (upper triangular plus one subdiagonal row)\n    // updates the transformation matrix R with new row operationsq\n    // MODIFIES arr by side effect!\n    reduceToHessenberg(arr, N, prec, type, findVectors, R);\n    // still true that original A = R⁻¹ arr R)\n\n    // find eigenvalues\n    var _iterateUntilTriangul = iterateUntilTriangular(arr, N, prec, type, findVectors),\n      values = _iterateUntilTriangul.values,\n      C = _iterateUntilTriangul.C;\n\n    // values is the list of eigenvalues, C is the column\n    // transformation matrix that transforms arr, the hessenberg\n    // matrix, to upper triangular\n    // (So U = C⁻¹ arr C and the relationship between current arr\n    // and original A is unchanged.)\n\n    var vectors;\n    if (findVectors) {\n      vectors = findEigenvectors(arr, N, C, R, values, prec, type);\n      vectors = matrixFromColumns.apply(void 0, (0, _toConsumableArray2[\"default\"])(vectors));\n    }\n    return {\n      values: values,\n      vectors: vectors\n    };\n  }\n\n  /**\n   * @param {number[][]} arr\n   * @param {number} N\n   * @param {number} prec\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {number[][]}\n   */\n  function balance(arr, N, prec, type, findVectors) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var realzero = big ? bignumber(0) : 0;\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n    var realone = big ? bignumber(1) : 1;\n\n    // base of the floating-point arithmetic\n    var radix = big ? bignumber(10) : 2;\n    var radixSq = multiplyScalar(radix, radix);\n\n    // the diagonal transformation matrix R\n    var Rdiag;\n    if (findVectors) {\n      Rdiag = Array(N).fill(one);\n    }\n\n    // this isn't the only time we loop thru the matrix...\n    var last = false;\n    while (!last) {\n      // ...haha I'm joking! unless...\n      last = true;\n      for (var i = 0; i < N; i++) {\n        // compute the taxicab norm of i-th column and row\n        // TODO optimize for complex numbers\n        var colNorm = realzero;\n        var rowNorm = realzero;\n        for (var j = 0; j < N; j++) {\n          if (i === j) continue;\n          var c = abs(arr[i][j]); // should be real\n          colNorm = addScalar(colNorm, c);\n          rowNorm = addScalar(rowNorm, c);\n        }\n        if (!equal(colNorm, 0) && !equal(rowNorm, 0)) {\n          // find integer power closest to balancing the matrix\n          // (we want to scale only by integer powers of radix,\n          // so that we don't lose any precision due to round-off)\n\n          var f = realone;\n          var _c = colNorm;\n          var rowDivRadix = divideScalar(rowNorm, radix);\n          var rowMulRadix = multiplyScalar(rowNorm, radix);\n          while (smaller(_c, rowDivRadix)) {\n            _c = multiplyScalar(_c, radixSq);\n            f = multiplyScalar(f, radix);\n          }\n          while (larger(_c, rowMulRadix)) {\n            _c = divideScalar(_c, radixSq);\n            f = divideScalar(f, radix);\n          }\n\n          // check whether balancing is needed\n          // condition = (c + rowNorm) / f < 0.95 * (colNorm + rowNorm)\n          var condition = smaller(divideScalar(addScalar(_c, rowNorm), f), multiplyScalar(addScalar(colNorm, rowNorm), 0.95));\n\n          // apply balancing similarity transformation\n          if (condition) {\n            // we should loop once again to check whether\n            // another rebalancing is needed\n            last = false;\n            var g = divideScalar(1, f);\n            for (var _j = 0; _j < N; _j++) {\n              if (i === _j) {\n                continue;\n              }\n              arr[i][_j] = multiplyScalar(arr[i][_j], f);\n              arr[_j][i] = multiplyScalar(arr[_j][i], g);\n            }\n\n            // keep track of transformations\n            if (findVectors) {\n              Rdiag[i] = multiplyScalar(Rdiag[i], f);\n            }\n          }\n        }\n      }\n    }\n\n    // return the diagonal row transformation matrix\n    return diag(Rdiag);\n  }\n\n  /**\n   * @param {number[][]} arr\n   * @param {number} N\n   * @param {number} prec\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @param {boolean} findVectors\n   * @param {number[][]} R the row transformation matrix that will be modified\n   */\n  function reduceToHessenberg(arr, N, prec, type, findVectors, R) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n    if (big) {\n      prec = bignumber(prec);\n    }\n    for (var i = 0; i < N - 2; i++) {\n      // Find the largest subdiag element in the i-th col\n\n      var maxIndex = 0;\n      var max = zero;\n      for (var j = i + 1; j < N; j++) {\n        var el = arr[j][i];\n        if (smaller(abs(max), abs(el))) {\n          max = el;\n          maxIndex = j;\n        }\n      }\n\n      // This col is pivoted, no need to do anything\n      if (smaller(abs(max), prec)) {\n        continue;\n      }\n      if (maxIndex !== i + 1) {\n        // Interchange maxIndex-th and (i+1)-th row\n        var tmp1 = arr[maxIndex];\n        arr[maxIndex] = arr[i + 1];\n        arr[i + 1] = tmp1;\n\n        // Interchange maxIndex-th and (i+1)-th column\n        for (var _j2 = 0; _j2 < N; _j2++) {\n          var tmp2 = arr[_j2][maxIndex];\n          arr[_j2][maxIndex] = arr[_j2][i + 1];\n          arr[_j2][i + 1] = tmp2;\n        }\n\n        // keep track of transformations\n        if (findVectors) {\n          var tmp3 = R[maxIndex];\n          R[maxIndex] = R[i + 1];\n          R[i + 1] = tmp3;\n        }\n      }\n\n      // Reduce following rows and columns\n      for (var _j3 = i + 2; _j3 < N; _j3++) {\n        var n = divideScalar(arr[_j3][i], max);\n        if (n === 0) {\n          continue;\n        }\n\n        // from j-th row subtract n-times (i+1)th row\n        for (var k = 0; k < N; k++) {\n          arr[_j3][k] = subtract(arr[_j3][k], multiplyScalar(n, arr[i + 1][k]));\n        }\n\n        // to (i+1)th column add n-times j-th column\n        for (var _k = 0; _k < N; _k++) {\n          arr[_k][i + 1] = addScalar(arr[_k][i + 1], multiplyScalar(n, arr[_k][_j3]));\n        }\n\n        // keep track of transformations\n        if (findVectors) {\n          for (var _k2 = 0; _k2 < N; _k2++) {\n            R[_j3][_k2] = subtract(R[_j3][_k2], multiplyScalar(n, R[i + 1][_k2]));\n          }\n        }\n      }\n    }\n    return R;\n  }\n\n  /**\n   * @returns {{values: values, C: Matrix}}\n   * @see Press, Wiliams: Numerical recipes in Fortran 77\n   * @see https://en.wikipedia.org/wiki/QR_algorithm\n   */\n  function iterateUntilTriangular(A, N, prec, type, findVectors) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n    if (big) {\n      prec = bignumber(prec);\n    }\n\n    // The Francis Algorithm\n    // The core idea of this algorithm is that doing successive\n    // A' = Q⁺AQ transformations will eventually converge to block-\n    // upper-triangular with diagonal blocks either 1x1 or 2x2.\n    // The Q here is the one from the QR decomposition, A = QR.\n    // Since the eigenvalues of a block-upper-triangular matrix are\n    // the eigenvalues of its diagonal blocks and we know how to find\n    // eigenvalues of a 2x2 matrix, we know the eigenvalues of A.\n\n    var arr = (0, _object.clone)(A);\n\n    // the list of converged eigenvalues\n    var lambdas = [];\n\n    // size of arr, which will get smaller as eigenvalues converge\n    var n = N;\n\n    // the diagonal of the block-diagonal matrix that turns\n    // converged 2x2 matrices into upper triangular matrices\n    var Sdiag = [];\n\n    // N×N matrix describing the overall transformation done during the QR algorithm\n    var Qtotal = findVectors ? diag(Array(N).fill(one)) : undefined;\n\n    // n×n matrix describing the QR transformations done since last convergence\n    var Qpartial = findVectors ? diag(Array(n).fill(one)) : undefined;\n\n    // last eigenvalue converged before this many steps\n    var lastConvergenceBefore = 0;\n    while (lastConvergenceBefore <= 100) {\n      lastConvergenceBefore += 1;\n\n      // TODO if the convergence is slow, do something clever\n\n      // Perform the factorization\n\n      var k = 0; // TODO set close to an eigenvalue\n\n      for (var i = 0; i < n; i++) {\n        arr[i][i] = subtract(arr[i][i], k);\n      }\n\n      // TODO do an implicit QR transformation\n      var _qr = qr(arr),\n        Q = _qr.Q,\n        R = _qr.R;\n      arr = multiply(R, Q);\n      for (var _i = 0; _i < n; _i++) {\n        arr[_i][_i] = addScalar(arr[_i][_i], k);\n      }\n\n      // keep track of transformations\n      if (findVectors) {\n        Qpartial = multiply(Qpartial, Q);\n      }\n\n      // The rightmost diagonal element converged to an eigenvalue\n      if (n === 1 || smaller(abs(arr[n - 1][n - 2]), prec)) {\n        lastConvergenceBefore = 0;\n        lambdas.push(arr[n - 1][n - 1]);\n\n        // keep track of transformations\n        if (findVectors) {\n          Sdiag.unshift([[1]]);\n          inflateMatrix(Qpartial, N);\n          Qtotal = multiply(Qtotal, Qpartial);\n          if (n > 1) {\n            Qpartial = diag(Array(n - 1).fill(one));\n          }\n        }\n\n        // reduce the matrix size\n        n -= 1;\n        arr.pop();\n        for (var _i2 = 0; _i2 < n; _i2++) {\n          arr[_i2].pop();\n        }\n\n        // The rightmost diagonal 2x2 block converged\n      } else if (n === 2 || smaller(abs(arr[n - 2][n - 3]), prec)) {\n        lastConvergenceBefore = 0;\n        var ll = eigenvalues2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1]);\n        lambdas.push.apply(lambdas, (0, _toConsumableArray2[\"default\"])(ll));\n\n        // keep track of transformations\n        if (findVectors) {\n          Sdiag.unshift(jordanBase2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1], ll[0], ll[1], prec, type));\n          inflateMatrix(Qpartial, N);\n          Qtotal = multiply(Qtotal, Qpartial);\n          if (n > 2) {\n            Qpartial = diag(Array(n - 2).fill(one));\n          }\n        }\n\n        // reduce the matrix size\n        n -= 2;\n        arr.pop();\n        arr.pop();\n        for (var _i3 = 0; _i3 < n; _i3++) {\n          arr[_i3].pop();\n          arr[_i3].pop();\n        }\n      }\n      if (n === 0) {\n        break;\n      }\n    }\n\n    // standard sorting\n    lambdas.sort(function (a, b) {\n      return +subtract(abs(a), abs(b));\n    });\n\n    // the algorithm didn't converge\n    if (lastConvergenceBefore > 100) {\n      var err = Error('The eigenvalues failed to converge. Only found these eigenvalues: ' + lambdas.join(', '));\n      err.values = lambdas;\n      err.vectors = [];\n      throw err;\n    }\n\n    // combine the overall QR transformation Qtotal with the subsequent\n    // transformation S that turns the diagonal 2x2 blocks to upper triangular\n    var C = findVectors ? multiply(Qtotal, blockDiag(Sdiag, N)) : undefined;\n    return {\n      values: lambdas,\n      C: C\n    };\n  }\n\n  /**\n   * @param {Matrix} A hessenberg-form matrix\n   * @param {number} N size of A\n   * @param {Matrix} C column transformation matrix that turns A into upper triangular\n   * @param {Matrix} R similarity that turns original matrix into A\n   * @param {number[]} values array of eigenvalues of A\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {number[][]} eigenvalues\n   */\n  function findEigenvectors(A, N, C, R, values, prec, type) {\n    var Cinv = inv(C);\n    var U = multiply(Cinv, A, C);\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n\n    // turn values into a kind of \"multiset\"\n    // this way it is easier to find eigenvectors\n    var uniqueValues = [];\n    var multiplicities = [];\n    var _iterator = _createForOfIteratorHelper(values),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var λ = _step.value;\n        var _i4 = indexOf(uniqueValues, λ, equal);\n        if (_i4 === -1) {\n          uniqueValues.push(λ);\n          multiplicities.push(1);\n        } else {\n          multiplicities[_i4] += 1;\n        }\n      }\n\n      // find eigenvectors by solving U − λE = 0\n      // TODO replace with an iterative eigenvector algorithm\n      // (this one might fail for imprecise eigenvalues)\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var vectors = [];\n    var len = uniqueValues.length;\n    var b = Array(N).fill(zero);\n    var E = diag(Array(N).fill(one));\n\n    // eigenvalues for which usolve failed (due to numerical error)\n    var failedLambdas = [];\n    var _loop = function _loop(i) {\n      var λ = uniqueValues[i];\n      var S = subtract(U, multiply(λ, E)); // the characteristic matrix\n\n      var solutions = usolveAll(S, b);\n      solutions.shift(); // ignore the null vector\n\n      // looks like we missed something, try inverse iteration\n      while (solutions.length < multiplicities[i]) {\n        var approxVec = inverseIterate(S, N, solutions, prec, type);\n        if (approxVec == null) {\n          // no more vectors were found\n          failedLambdas.push(λ);\n          break;\n        }\n        solutions.push(approxVec);\n      }\n\n      // Transform back into original array coordinates\n      var correction = multiply(inv(R), C);\n      solutions = solutions.map(function (v) {\n        return multiply(correction, v);\n      });\n      vectors.push.apply(vectors, (0, _toConsumableArray2[\"default\"])(solutions.map(function (v) {\n        return flatten(v);\n      })));\n    };\n    for (var i = 0; i < len; i++) {\n      _loop(i);\n    }\n    if (failedLambdas.length !== 0) {\n      var err = new Error('Failed to find eigenvectors for the following eigenvalues: ' + failedLambdas.join(', '));\n      err.values = values;\n      err.vectors = vectors;\n      throw err;\n    }\n    return vectors;\n  }\n\n  /**\n   * Compute the eigenvalues of an 2x2 matrix\n   * @return {[number,number]}\n   */\n  function eigenvalues2x2(a, b, c, d) {\n    // λ± = ½ trA ± ½ √( tr²A - 4 detA )\n    var trA = addScalar(a, d);\n    var detA = subtract(multiplyScalar(a, d), multiplyScalar(b, c));\n    var x = multiplyScalar(trA, 0.5);\n    var y = multiplyScalar(sqrt(subtract(multiplyScalar(trA, trA), multiplyScalar(4, detA))), 0.5);\n    return [addScalar(x, y), subtract(x, y)];\n  }\n\n  /**\n   * For an 2x2 matrix compute the transformation matrix S,\n   * so that SAS⁻¹ is an upper triangular matrix\n   * @return {[[number,number],[number,number]]}\n   * @see https://math.berkeley.edu/~ogus/old/Math_54-05/webfoils/jordan.pdf\n   * @see http://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html\n   */\n  function jordanBase2x2(a, b, c, d, l1, l2, prec, type) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n\n    // matrix is already upper triangular\n    // return an identity matrix\n    if (smaller(abs(c), prec)) {\n      return [[one, zero], [zero, one]];\n    }\n\n    // matrix is diagonalizable\n    // return its eigenvectors as columns\n    if (larger(abs(subtract(l1, l2)), prec)) {\n      return [[subtract(l1, d), subtract(l2, d)], [c, c]];\n    }\n\n    // matrix is not diagonalizable\n    // compute off-diagonal elements of N = A - λI\n    // N₁₂ = 0 ⇒ S = ( N⃗₁, I⃗₁ )\n    // N₁₂ ≠ 0 ⇒ S = ( N⃗₂, I⃗₂ )\n\n    var na = subtract(a, l1);\n    var nb = subtract(b, l1);\n    var nc = subtract(c, l1);\n    var nd = subtract(d, l1);\n    if (smaller(abs(nb), prec)) {\n      return [[na, one], [nc, zero]];\n    } else {\n      return [[nb, zero], [nd, one]];\n    }\n  }\n\n  /**\n   * Enlarge the matrix from n×n to N×N, setting the new\n   * elements to 1 on diagonal and 0 elsewhere\n   */\n  function inflateMatrix(arr, N) {\n    // add columns\n    for (var i = 0; i < arr.length; i++) {\n      var _arr$i;\n      (_arr$i = arr[i]).push.apply(_arr$i, (0, _toConsumableArray2[\"default\"])(Array(N - arr[i].length).fill(0)));\n    }\n\n    // add rows\n    for (var _i5 = arr.length; _i5 < N; _i5++) {\n      arr.push(Array(N).fill(0));\n      arr[_i5][_i5] = 1;\n    }\n    return arr;\n  }\n\n  /**\n   * Create a block-diagonal matrix with the given square matrices on the diagonal\n   * @param {Matrix[] | number[][][]} arr array of matrices to be placed on the diagonal\n   * @param {number} N the size of the resulting matrix\n   */\n  function blockDiag(arr, N) {\n    var M = [];\n    for (var i = 0; i < N; i++) {\n      M[i] = Array(N).fill(0);\n    }\n    var I = 0;\n    var _iterator2 = _createForOfIteratorHelper(arr),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var sub = _step2.value;\n        var n = sub.length;\n        for (var _i6 = 0; _i6 < n; _i6++) {\n          for (var j = 0; j < n; j++) {\n            M[I + _i6][I + j] = sub[_i6][j];\n          }\n        }\n        I += n;\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    return M;\n  }\n\n  /**\n   * Finds the index of an element in an array using a custom equality function\n   * @template T\n   * @param {Array<T>} arr array in which to search\n   * @param {T} el the element to find\n   * @param {function(T, T): boolean} fn the equality function, first argument is an element of `arr`, the second is always `el`\n   * @returns {number} the index of `el`, or -1 when it's not in `arr`\n   */\n  function indexOf(arr, el, fn) {\n    for (var i = 0; i < arr.length; i++) {\n      if (fn(arr[i], el)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Provided a near-singular upper-triangular matrix A and a list of vectors,\n   * finds an eigenvector of A with the smallest eigenvalue, which is orthogonal\n   * to each vector in the list\n   * @template T\n   * @param {T[][]} A near-singular square matrix\n   * @param {number} N dimension\n   * @param {T[][]} orthog list of vectors\n   * @param {number} prec epsilon\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @return {T[] | null} eigenvector\n   *\n   * @see Numerical Recipes for Fortran 77 – 11.7 Eigenvalues or Eigenvectors by Inverse Iteration\n   */\n  function inverseIterate(A, N, orthog, prec, type) {\n    var largeNum = type === 'BigNumber' ? bignumber(1000) : 1000;\n    var b; // the vector\n\n    // you better choose a random vector before I count to five\n    var i = 0;\n    while (true) {\n      b = randomOrthogonalVector(N, orthog, type);\n      b = usolve(A, b);\n      if (larger(norm(b), largeNum)) {\n        break;\n      }\n      if (++i >= 5) {\n        return null;\n      }\n    }\n\n    // you better converge before I count to ten\n    i = 0;\n    while (true) {\n      var c = usolve(A, b);\n      if (smaller(norm(orthogonalComplement(b, [c])), prec)) {\n        break;\n      }\n      if (++i >= 10) {\n        return null;\n      }\n      b = normalize(c);\n    }\n    return b;\n  }\n\n  /**\n   * Generates a random unit vector of dimension N, orthogonal to each vector in the list\n   * @template T\n   * @param {number} N dimension\n   * @param {T[][]} orthog list of vectors\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {T[]} random vector\n   */\n  function randomOrthogonalVector(N, orthog, type) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n\n    // generate random vector with the correct type\n    var v = Array(N).fill(0).map(function (_) {\n      return 2 * Math.random() - 1;\n    });\n    if (big) {\n      v = v.map(function (n) {\n        return bignumber(n);\n      });\n    }\n    if (cplx) {\n      v = v.map(function (n) {\n        return complex(n);\n      });\n    }\n\n    // project to orthogonal complement\n    v = orthogonalComplement(v, orthog);\n\n    // normalize\n    return normalize(v, type);\n  }\n\n  /**\n   * Project vector v to the orthogonal complement of an array of vectors\n   */\n  function orthogonalComplement(v, orthog) {\n    var _iterator3 = _createForOfIteratorHelper(orthog),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var w = _step3.value;\n        // v := v − (w, v)/∥w∥² w\n        v = subtract(v, multiply(divideScalar(dot(w, v), dot(w, w)), w));\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    return v;\n  }\n\n  /**\n   * Calculate the norm of a vector.\n   * We can't use math.norm because factory can't handle circular dependency.\n   * Seriously, I'm really fed up with factory.\n   */\n  function norm(v) {\n    return abs(sqrt(dot(v, v)));\n  }\n\n  /**\n   * Normalize a vector\n   * @template T\n   * @param {T[]} v\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {T[]} normalized vec\n   */\n  function normalize(v, type) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n    return multiply(divideScalar(one, norm(v)), v);\n  }\n  return complexEigs;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}