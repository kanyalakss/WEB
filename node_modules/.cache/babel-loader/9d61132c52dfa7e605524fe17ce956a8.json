{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createDenseMatrixClass = void 0;\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\nvar _is = require(\"../../utils/is.js\");\nvar _array = require(\"../../utils/array.js\");\nvar _string = require(\"../../utils/string.js\");\nvar _number = require(\"../../utils/number.js\");\nvar _object = require(\"../../utils/object.js\");\nvar _DimensionError = require(\"../../error/DimensionError.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar _function = require(\"../../utils/function.js\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nvar name = 'DenseMatrix';\nvar dependencies = ['Matrix'];\nvar createDenseMatrixClass = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var Matrix = _ref.Matrix;\n  /**\n   * Dense Matrix implementation. A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.\n   * @class DenseMatrix\n   * @enum {{ value, index: number[] }}\n   */\n  function DenseMatrix(data, datatype) {\n    if (!(this instanceof DenseMatrix)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n    if (datatype && !(0, _is.isString)(datatype)) {\n      throw new Error('Invalid datatype: ' + datatype);\n    }\n    if ((0, _is.isMatrix)(data)) {\n      // check data is a DenseMatrix\n      if (data.type === 'DenseMatrix') {\n        // clone data & size\n        this._data = (0, _object.clone)(data._data);\n        this._size = (0, _object.clone)(data._size);\n        this._datatype = datatype || data._datatype;\n      } else {\n        // build data from existing matrix\n        this._data = data.toArray();\n        this._size = data.size();\n        this._datatype = datatype || data._datatype;\n      }\n    } else if (data && (0, _is.isArray)(data.data) && (0, _is.isArray)(data.size)) {\n      // initialize fields from JSON representation\n      this._data = data.data;\n      this._size = data.size;\n      // verify the dimensions of the array\n      (0, _array.validate)(this._data, this._size);\n      this._datatype = datatype || data.datatype;\n    } else if ((0, _is.isArray)(data)) {\n      // replace nested Matrices with Arrays\n      this._data = preprocess(data);\n      // get the dimensions of the array\n      this._size = (0, _array.arraySize)(this._data);\n      // verify the dimensions of the array, TODO: compute size while processing array\n      (0, _array.validate)(this._data, this._size);\n      // data type unknown\n      this._datatype = datatype;\n    } else if (data) {\n      // unsupported type\n      throw new TypeError('Unsupported type of data (' + (0, _is.typeOf)(data) + ')');\n    } else {\n      // nothing provided\n      this._data = [];\n      this._size = [0];\n      this._datatype = datatype;\n    }\n  }\n  DenseMatrix.prototype = new Matrix();\n\n  /**\n   * Create a new DenseMatrix\n   */\n  DenseMatrix.prototype.createDenseMatrix = function (data, datatype) {\n    return new DenseMatrix(data, datatype);\n  };\n\n  /**\n   * Attach type information\n   */\n  Object.defineProperty(DenseMatrix, 'name', {\n    value: 'DenseMatrix'\n  });\n  DenseMatrix.prototype.constructor = DenseMatrix;\n  DenseMatrix.prototype.type = 'DenseMatrix';\n  DenseMatrix.prototype.isDenseMatrix = true;\n\n  /**\n   * Get the matrix type\n   *\n   * Usage:\n   *    const matrixType = matrix.getDataType()  // retrieves the matrix type\n   *\n   * @memberOf DenseMatrix\n   * @return {string}   type information; if multiple types are found from the Matrix, it will return \"mixed\"\n   */\n  DenseMatrix.prototype.getDataType = function () {\n    return (0, _array.getArrayDataType)(this._data, _is.typeOf);\n  };\n\n  /**\n   * Get the storage format used by the matrix.\n   *\n   * Usage:\n   *     const format = matrix.storage()  // retrieve storage format\n   *\n   * @memberof DenseMatrix\n   * @return {string}           The storage format.\n   */\n  DenseMatrix.prototype.storage = function () {\n    return 'dense';\n  };\n\n  /**\n   * Get the datatype of the data stored in the matrix.\n   *\n   * Usage:\n   *     const format = matrix.datatype()   // retrieve matrix datatype\n   *\n   * @memberof DenseMatrix\n   * @return {string}           The datatype.\n   */\n  DenseMatrix.prototype.datatype = function () {\n    return this._datatype;\n  };\n\n  /**\n   * Create a new DenseMatrix\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @param {string} [datatype]\n   */\n  DenseMatrix.prototype.create = function (data, datatype) {\n    return new DenseMatrix(data, datatype);\n  };\n\n  /**\n   * Get a subset of the matrix, or replace a subset of the matrix.\n   *\n   * Usage:\n   *     const subset = matrix.subset(index)               // retrieve subset\n   *     const value = matrix.subset(index, replacement)   // replace subset\n   *\n   * @memberof DenseMatrix\n   * @param {Index} index\n   * @param {Array | Matrix | *} [replacement]\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be filled with zeros.\n   */\n  DenseMatrix.prototype.subset = function (index, replacement, defaultValue) {\n    switch (arguments.length) {\n      case 1:\n        return _get(this, index);\n\n      // intentional fall through\n      case 2:\n      case 3:\n        return _set(this, index, replacement, defaultValue);\n      default:\n        throw new SyntaxError('Wrong number of arguments');\n    }\n  };\n\n  /**\n   * Get a single element from the matrix.\n   * @memberof DenseMatrix\n   * @param {number[]} index   Zero-based index\n   * @return {*} value\n   */\n  DenseMatrix.prototype.get = function (index) {\n    if (!(0, _is.isArray)(index)) {\n      throw new TypeError('Array expected');\n    }\n    if (index.length !== this._size.length) {\n      throw new _DimensionError.DimensionError(index.length, this._size.length);\n    }\n\n    // check index\n    for (var x = 0; x < index.length; x++) {\n      (0, _array.validateIndex)(index[x], this._size[x]);\n    }\n    var data = this._data;\n    for (var i = 0, ii = index.length; i < ii; i++) {\n      var indexI = index[i];\n      (0, _array.validateIndex)(indexI, data.length);\n      data = data[indexI];\n    }\n    return data;\n  };\n\n  /**\n   * Replace a single element in the matrix.\n   * @memberof DenseMatrix\n   * @param {number[]} index   Zero-based index\n   * @param {*} value\n   * @param {*} [defaultValue]        Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be left undefined.\n   * @return {DenseMatrix} self\n   */\n  DenseMatrix.prototype.set = function (index, value, defaultValue) {\n    if (!(0, _is.isArray)(index)) {\n      throw new TypeError('Array expected');\n    }\n    if (index.length < this._size.length) {\n      throw new _DimensionError.DimensionError(index.length, this._size.length, '<');\n    }\n    var i, ii, indexI;\n\n    // enlarge matrix when needed\n    var size = index.map(function (i) {\n      return i + 1;\n    });\n    _fit(this, size, defaultValue);\n\n    // traverse over the dimensions\n    var data = this._data;\n    for (i = 0, ii = index.length - 1; i < ii; i++) {\n      indexI = index[i];\n      (0, _array.validateIndex)(indexI, data.length);\n      data = data[indexI];\n    }\n\n    // set new value\n    indexI = index[index.length - 1];\n    (0, _array.validateIndex)(indexI, data.length);\n    data[indexI] = value;\n    return this;\n  };\n\n  /**\n   * Get a submatrix of this matrix\n   * @memberof DenseMatrix\n   * @param {DenseMatrix} matrix\n   * @param {Index} index   Zero-based index\n   * @private\n   */\n  function _get(matrix, index) {\n    if (!(0, _is.isIndex)(index)) {\n      throw new TypeError('Invalid index');\n    }\n    var isScalar = index.isScalar();\n    if (isScalar) {\n      // return a scalar\n      return matrix.get(index.min());\n    } else {\n      // validate dimensions\n      var size = index.size();\n      if (size.length !== matrix._size.length) {\n        throw new _DimensionError.DimensionError(size.length, matrix._size.length);\n      }\n\n      // validate if any of the ranges in the index is out of range\n      var min = index.min();\n      var max = index.max();\n      for (var i = 0, ii = matrix._size.length; i < ii; i++) {\n        (0, _array.validateIndex)(min[i], matrix._size[i]);\n        (0, _array.validateIndex)(max[i], matrix._size[i]);\n      }\n\n      // retrieve submatrix\n      // TODO: more efficient when creating an empty matrix and setting _data and _size manually\n      return new DenseMatrix(_getSubmatrix(matrix._data, index, size.length, 0), matrix._datatype);\n    }\n  }\n\n  /**\n   * Recursively get a submatrix of a multi dimensional matrix.\n   * Index is not checked for correct number or length of dimensions.\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @param {Index} index\n   * @param {number} dims   Total number of dimensions\n   * @param {number} dim    Current dimension\n   * @return {Array} submatrix\n   * @private\n   */\n  function _getSubmatrix(data, index, dims, dim) {\n    var last = dim === dims - 1;\n    var range = index.dimension(dim);\n    if (last) {\n      return range.map(function (i) {\n        (0, _array.validateIndex)(i, data.length);\n        return data[i];\n      }).valueOf();\n    } else {\n      return range.map(function (i) {\n        (0, _array.validateIndex)(i, data.length);\n        var child = data[i];\n        return _getSubmatrix(child, index, dims, dim + 1);\n      }).valueOf();\n    }\n  }\n\n  /**\n   * Replace a submatrix in this matrix\n   * Indexes are zero-based.\n   * @memberof DenseMatrix\n   * @param {DenseMatrix} matrix\n   * @param {Index} index\n   * @param {DenseMatrix | Array | *} submatrix\n   * @param {*} defaultValue          Default value, filled in on new entries when\n   *                                  the matrix is resized.\n   * @return {DenseMatrix} matrix\n   * @private\n   */\n  function _set(matrix, index, submatrix, defaultValue) {\n    if (!index || index.isIndex !== true) {\n      throw new TypeError('Invalid index');\n    }\n\n    // get index size and check whether the index contains a single value\n    var iSize = index.size();\n    var isScalar = index.isScalar();\n\n    // calculate the size of the submatrix, and convert it into an Array if needed\n    var sSize;\n    if ((0, _is.isMatrix)(submatrix)) {\n      sSize = submatrix.size();\n      submatrix = submatrix.valueOf();\n    } else {\n      sSize = (0, _array.arraySize)(submatrix);\n    }\n    if (isScalar) {\n      // set a scalar\n\n      // check whether submatrix is a scalar\n      if (sSize.length !== 0) {\n        throw new TypeError('Scalar expected');\n      }\n      matrix.set(index.min(), submatrix, defaultValue);\n    } else {\n      // set a submatrix\n\n      // validate dimensions\n      if (iSize.length < matrix._size.length) {\n        throw new _DimensionError.DimensionError(iSize.length, matrix._size.length, '<');\n      }\n      if (sSize.length < iSize.length) {\n        // calculate number of missing outer dimensions\n        var i = 0;\n        var outer = 0;\n        while (iSize[i] === 1 && sSize[i] === 1) {\n          i++;\n        }\n        while (iSize[i] === 1) {\n          outer++;\n          i++;\n        }\n\n        // unsqueeze both outer and inner dimensions\n        submatrix = (0, _array.unsqueeze)(submatrix, iSize.length, outer, sSize);\n      }\n\n      // check whether the size of the submatrix matches the index size\n      if (!(0, _object.deepStrictEqual)(iSize, sSize)) {\n        throw new _DimensionError.DimensionError(iSize, sSize, '>');\n      }\n\n      // enlarge matrix when needed\n      var size = index.max().map(function (i) {\n        return i + 1;\n      });\n      _fit(matrix, size, defaultValue);\n\n      // insert the sub matrix\n      var dims = iSize.length;\n      var dim = 0;\n      _setSubmatrix(matrix._data, index, submatrix, dims, dim);\n    }\n    return matrix;\n  }\n\n  /**\n   * Replace a submatrix of a multi dimensional matrix.\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @param {Index} index\n   * @param {Array} submatrix\n   * @param {number} dims   Total number of dimensions\n   * @param {number} dim\n   * @private\n   */\n  function _setSubmatrix(data, index, submatrix, dims, dim) {\n    var last = dim === dims - 1;\n    var range = index.dimension(dim);\n    if (last) {\n      range.forEach(function (dataIndex, subIndex) {\n        (0, _array.validateIndex)(dataIndex);\n        data[dataIndex] = submatrix[subIndex[0]];\n      });\n    } else {\n      range.forEach(function (dataIndex, subIndex) {\n        (0, _array.validateIndex)(dataIndex);\n        _setSubmatrix(data[dataIndex], index, submatrix[subIndex[0]], dims, dim + 1);\n      });\n    }\n  }\n\n  /**\n   * Resize the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (resize in place).\n   *\n   * @memberof DenseMatrix\n   * @param {number[] || Matrix} size The new size the matrix should have.\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries.\n   *                                  If not provided, the matrix elements will\n   *                                  be filled with zeros.\n   * @param {boolean} [copy]          Return a resized copy of the matrix\n   *\n   * @return {Matrix}                 The resized matrix\n   */\n  DenseMatrix.prototype.resize = function (size, defaultValue, copy) {\n    // validate arguments\n    if (!(0, _is.isCollection)(size)) {\n      throw new TypeError('Array or Matrix expected');\n    }\n\n    // SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector\n    var sizeArray = size.valueOf().map(function (value) {\n      return Array.isArray(value) && value.length === 1 ? value[0] : value;\n    });\n\n    // matrix to resize\n    var m = copy ? this.clone() : this;\n    // resize matrix\n    return _resize(m, sizeArray, defaultValue);\n  };\n  function _resize(matrix, size, defaultValue) {\n    // check size\n    if (size.length === 0) {\n      // first value in matrix\n      var v = matrix._data;\n      // go deep\n      while ((0, _is.isArray)(v)) {\n        v = v[0];\n      }\n      return v;\n    }\n    // resize matrix\n    matrix._size = size.slice(0); // copy the array\n    matrix._data = (0, _array.resize)(matrix._data, matrix._size, defaultValue);\n    // return matrix\n    return matrix;\n  }\n\n  /**\n   * Reshape the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (reshape in place).\n   *\n   * NOTE: This might be better suited to copy by default, instead of modifying\n   *       in place. For now, it operates in place to remain consistent with\n   *       resize().\n   *\n   * @memberof DenseMatrix\n   * @param {number[]} size           The new size the matrix should have.\n   * @param {boolean} [copy]          Return a reshaped copy of the matrix\n   *\n   * @return {Matrix}                 The reshaped matrix\n   */\n  DenseMatrix.prototype.reshape = function (size, copy) {\n    var m = copy ? this.clone() : this;\n    m._data = (0, _array.reshape)(m._data, size);\n    var currentLength = m._size.reduce(function (length, size) {\n      return length * size;\n    });\n    m._size = (0, _array.processSizesWildcard)(size, currentLength);\n    return m;\n  };\n\n  /**\n   * Enlarge the matrix when it is smaller than given size.\n   * If the matrix is larger or equal sized, nothing is done.\n   * @memberof DenseMatrix\n   * @param {DenseMatrix} matrix           The matrix to be resized\n   * @param {number[]} size\n   * @param {*} defaultValue          Default value, filled in on new entries.\n   * @private\n   */\n  function _fit(matrix, size, defaultValue) {\n    var\n    // copy the array\n    newSize = matrix._size.slice(0);\n    var changed = false;\n\n    // add dimensions when needed\n    while (newSize.length < size.length) {\n      newSize.push(0);\n      changed = true;\n    }\n\n    // enlarge size when needed\n    for (var i = 0, ii = size.length; i < ii; i++) {\n      if (size[i] > newSize[i]) {\n        newSize[i] = size[i];\n        changed = true;\n      }\n    }\n    if (changed) {\n      // resize only when size is changed\n      _resize(matrix, newSize, defaultValue);\n    }\n  }\n\n  /**\n   * Create a clone of the matrix\n   * @memberof DenseMatrix\n   * @return {DenseMatrix} clone\n   */\n  DenseMatrix.prototype.clone = function () {\n    var m = new DenseMatrix({\n      data: (0, _object.clone)(this._data),\n      size: (0, _object.clone)(this._size),\n      datatype: this._datatype\n    });\n    return m;\n  };\n\n  /**\n   * Retrieve the size of the matrix.\n   * @memberof DenseMatrix\n   * @returns {number[]} size\n   */\n  DenseMatrix.prototype.size = function () {\n    return this._size.slice(0); // return a clone of _size\n  };\n\n  /**\n   * Create a new matrix with the results of the callback function executed on\n   * each entry of the matrix.\n   * @memberof DenseMatrix\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   *\n   * @return {DenseMatrix} matrix\n   */\n  DenseMatrix.prototype.map = function (callback) {\n    // matrix instance\n    var me = this;\n    var args = (0, _function.maxArgumentCount)(callback);\n    var recurse = function recurse(value, index) {\n      if ((0, _is.isArray)(value)) {\n        return value.map(function (child, i) {\n          return recurse(child, index.concat(i));\n        });\n      } else {\n        // invoke the callback function with the right number of arguments\n        if (args === 1) {\n          return callback(value);\n        } else if (args === 2) {\n          return callback(value, index);\n        } else {\n          // 3 or -1\n          return callback(value, index, me);\n        }\n      }\n    };\n\n    // determine the new datatype when the original matrix has datatype defined\n    // TODO: should be done in matrix constructor instead\n    var data = recurse(this._data, []);\n    var datatype = this._datatype !== undefined ? (0, _array.getArrayDataType)(data, _is.typeOf) : undefined;\n    return new DenseMatrix(data, datatype);\n  };\n\n  /**\n   * Execute a callback function on each entry of the matrix.\n   * @memberof DenseMatrix\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   */\n  DenseMatrix.prototype.forEach = function (callback) {\n    // matrix instance\n    var me = this;\n    var recurse = function recurse(value, index) {\n      if ((0, _is.isArray)(value)) {\n        value.forEach(function (child, i) {\n          recurse(child, index.concat(i));\n        });\n      } else {\n        callback(value, index, me);\n      }\n    };\n    recurse(this._data, []);\n  };\n\n  /**\n   * Iterate over the matrix elements\n   * @return {Iterable<{ value, index: number[] }>}\n   */\n  DenseMatrix.prototype[Symbol.iterator] = /*#__PURE__*/_regenerator[\"default\"].mark(function _callee() {\n    var recurse;\n    return _regenerator[\"default\"].wrap(function _callee$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            recurse = /*#__PURE__*/_regenerator[\"default\"].mark(function recurse(value, index) {\n              var i;\n              return _regenerator[\"default\"].wrap(function recurse$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      if (!(0, _is.isArray)(value)) {\n                        _context.next = 9;\n                        break;\n                      }\n                      i = 0;\n                    case 2:\n                      if (!(i < value.length)) {\n                        _context.next = 7;\n                        break;\n                      }\n                      return _context.delegateYield(recurse(value[i], index.concat(i)), \"t0\", 4);\n                    case 4:\n                      i++;\n                      _context.next = 2;\n                      break;\n                    case 7:\n                      _context.next = 11;\n                      break;\n                    case 9:\n                      _context.next = 11;\n                      return {\n                        value: value,\n                        index: index\n                      };\n                    case 11:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, recurse);\n            });\n            return _context2.delegateYield(recurse(this._data, []), \"t0\", 2);\n          case 2:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee, this);\n  });\n\n  /**\n   * Returns an array containing the rows of a 2D matrix\n   * @returns {Array<Matrix>}\n   */\n  DenseMatrix.prototype.rows = function () {\n    var result = [];\n    var s = this.size();\n    if (s.length !== 2) {\n      throw new TypeError('Rows can only be returned for a 2D matrix.');\n    }\n    var data = this._data;\n    var _iterator = _createForOfIteratorHelper(data),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var row = _step.value;\n        result.push(new DenseMatrix([row], this._datatype));\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return result;\n  };\n\n  /**\n   * Returns an array containing the columns of a 2D matrix\n   * @returns {Array<Matrix>}\n   */\n  DenseMatrix.prototype.columns = function () {\n    var _this = this;\n    var result = [];\n    var s = this.size();\n    if (s.length !== 2) {\n      throw new TypeError('Rows can only be returned for a 2D matrix.');\n    }\n    var data = this._data;\n    var _loop = function _loop(i) {\n      var col = data.map(function (row) {\n        return [row[i]];\n      });\n      result.push(new DenseMatrix(col, _this._datatype));\n    };\n    for (var i = 0; i < s[1]; i++) {\n      _loop(i);\n    }\n    return result;\n  };\n\n  /**\n   * Create an Array with a copy of the data of the DenseMatrix\n   * @memberof DenseMatrix\n   * @returns {Array} array\n   */\n  DenseMatrix.prototype.toArray = function () {\n    return (0, _object.clone)(this._data);\n  };\n\n  /**\n   * Get the primitive value of the DenseMatrix: a multidimensional array\n   * @memberof DenseMatrix\n   * @returns {Array} array\n   */\n  DenseMatrix.prototype.valueOf = function () {\n    return this._data;\n  };\n\n  /**\n   * Get a string representation of the matrix, with optional formatting options.\n   * @memberof DenseMatrix\n   * @param {Object | number | Function} [options]  Formatting options. See\n   *                                                lib/utils/number:format for a\n   *                                                description of the available\n   *                                                options.\n   * @returns {string} str\n   */\n  DenseMatrix.prototype.format = function (options) {\n    return (0, _string.format)(this._data, options);\n  };\n\n  /**\n   * Get a string representation of the matrix\n   * @memberof DenseMatrix\n   * @returns {string} str\n   */\n  DenseMatrix.prototype.toString = function () {\n    return (0, _string.format)(this._data);\n  };\n\n  /**\n   * Get a JSON representation of the matrix\n   * @memberof DenseMatrix\n   * @returns {Object}\n   */\n  DenseMatrix.prototype.toJSON = function () {\n    return {\n      mathjs: 'DenseMatrix',\n      data: this._data,\n      size: this._size,\n      datatype: this._datatype\n    };\n  };\n\n  /**\n   * Get the kth Matrix diagonal.\n   *\n   * @memberof DenseMatrix\n   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.\n   *\n   * @returns {Matrix}                     The matrix with the diagonal values.\n   */\n  DenseMatrix.prototype.diagonal = function (k) {\n    // validate k if any\n    if (k) {\n      // convert BigNumber to a number\n      if ((0, _is.isBigNumber)(k)) {\n        k = k.toNumber();\n      }\n      // is must be an integer\n      if (!(0, _is.isNumber)(k) || !(0, _number.isInteger)(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    }\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0;\n\n    // rows & columns\n    var rows = this._size[0];\n    var columns = this._size[1];\n\n    // number diagonal values\n    var n = Math.min(rows - kSub, columns - kSuper);\n\n    // x is a matrix get diagonal from matrix\n    var data = [];\n\n    // loop rows\n    for (var i = 0; i < n; i++) {\n      data[i] = this._data[i + kSub][i + kSuper];\n    }\n\n    // create DenseMatrix\n    return new DenseMatrix({\n      data: data,\n      size: [n],\n      datatype: this._datatype\n    });\n  };\n\n  /**\n   * Create a diagonal matrix.\n   *\n   * @memberof DenseMatrix\n   * @param {Array} size                     The matrix size.\n   * @param {number | Matrix | Array } value The values for the diagonal.\n   * @param {number | BigNumber} [k=0]       The kth diagonal where the vector will be filled in.\n   * @param {number} [defaultValue]          The default value for non-diagonal\n   * @param {string} [datatype]              The datatype for the diagonal\n   *\n   * @returns {DenseMatrix}\n   */\n  DenseMatrix.diagonal = function (size, value, k, defaultValue) {\n    if (!(0, _is.isArray)(size)) {\n      throw new TypeError('Array expected, size parameter');\n    }\n    if (size.length !== 2) {\n      throw new Error('Only two dimensions matrix are supported');\n    }\n\n    // map size & validate\n    size = size.map(function (s) {\n      // check it is a big number\n      if ((0, _is.isBigNumber)(s)) {\n        // convert it\n        s = s.toNumber();\n      }\n      // validate arguments\n      if (!(0, _is.isNumber)(s) || !(0, _number.isInteger)(s) || s < 1) {\n        throw new Error('Size values must be positive integers');\n      }\n      return s;\n    });\n\n    // validate k if any\n    if (k) {\n      // convert BigNumber to a number\n      if ((0, _is.isBigNumber)(k)) {\n        k = k.toNumber();\n      }\n      // is must be an integer\n      if (!(0, _is.isNumber)(k) || !(0, _number.isInteger)(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    }\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0;\n\n    // rows and columns\n    var rows = size[0];\n    var columns = size[1];\n\n    // number of non-zero items\n    var n = Math.min(rows - kSub, columns - kSuper);\n\n    // value extraction function\n    var _value;\n\n    // check value\n    if ((0, _is.isArray)(value)) {\n      // validate array\n      if (value.length !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid value array length');\n      }\n      // define function\n      _value = function _value(i) {\n        // return value @ i\n        return value[i];\n      };\n    } else if ((0, _is.isMatrix)(value)) {\n      // matrix size\n      var ms = value.size();\n      // validate matrix\n      if (ms.length !== 1 || ms[0] !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid matrix length');\n      }\n      // define function\n      _value = function _value(i) {\n        // return value @ i\n        return value.get([i]);\n      };\n    } else {\n      // define function\n      _value = function _value() {\n        // return value\n        return value;\n      };\n    }\n\n    // discover default value if needed\n    if (!defaultValue) {\n      // check first value in array\n      defaultValue = (0, _is.isBigNumber)(_value(0)) ? _value(0).mul(0) // trick to create a BigNumber with value zero\n      : 0;\n    }\n\n    // empty array\n    var data = [];\n\n    // check we need to resize array\n    if (size.length > 0) {\n      // resize array\n      data = (0, _array.resize)(data, size, defaultValue);\n      // fill diagonal\n      for (var d = 0; d < n; d++) {\n        data[d + kSub][d + kSuper] = _value(d);\n      }\n    }\n\n    // create DenseMatrix\n    return new DenseMatrix({\n      data: data,\n      size: [rows, columns]\n    });\n  };\n\n  /**\n   * Generate a matrix from a JSON object\n   * @memberof DenseMatrix\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"DenseMatrix\", data: [], size: []}`,\n   *                       where mathjs is optional\n   * @returns {DenseMatrix}\n   */\n  DenseMatrix.fromJSON = function (json) {\n    return new DenseMatrix(json);\n  };\n\n  /**\n   * Swap rows i and j in Matrix.\n   *\n   * @memberof DenseMatrix\n   * @param {number} i       Matrix row index 1\n   * @param {number} j       Matrix row index 2\n   *\n   * @return {Matrix}        The matrix reference\n   */\n  DenseMatrix.prototype.swapRows = function (i, j) {\n    // check index\n    if (!(0, _is.isNumber)(i) || !(0, _number.isInteger)(i) || !(0, _is.isNumber)(j) || !(0, _number.isInteger)(j)) {\n      throw new Error('Row index must be positive integers');\n    }\n    // check dimensions\n    if (this._size.length !== 2) {\n      throw new Error('Only two dimensional matrix is supported');\n    }\n    // validate index\n    (0, _array.validateIndex)(i, this._size[0]);\n    (0, _array.validateIndex)(j, this._size[0]);\n\n    // swap rows\n    DenseMatrix._swapRows(i, j, this._data);\n    // return current instance\n    return this;\n  };\n\n  /**\n   * Swap rows i and j in Dense Matrix data structure.\n   *\n   * @param {number} i       Matrix row index 1\n   * @param {number} j       Matrix row index 2\n   * @param {Array} data     Matrix data\n   */\n  DenseMatrix._swapRows = function (i, j, data) {\n    // swap values i <-> j\n    var vi = data[i];\n    data[i] = data[j];\n    data[j] = vi;\n  };\n\n  /**\n   * Preprocess data, which can be an Array or DenseMatrix with nested Arrays and\n   * Matrices. Replaces all nested Matrices with Arrays\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @return {Array} data\n   */\n  function preprocess(data) {\n    for (var i = 0, ii = data.length; i < ii; i++) {\n      var elem = data[i];\n      if ((0, _is.isArray)(elem)) {\n        data[i] = preprocess(elem);\n      } else if (elem && elem.isMatrix === true) {\n        data[i] = preprocess(elem.valueOf());\n      }\n    }\n    return data;\n  }\n  return DenseMatrix;\n}, {\n  isClass: true\n});\nexports.createDenseMatrixClass = createDenseMatrixClass;","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","createDenseMatrixClass","_regenerator","_is","_array","_string","_number","_object","_DimensionError","_factory","_function","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","length","i","F","s","n","done","e","_e","f","TypeError","normalCompletion","didErr","err","call","step","next","_e2","minLen","_arrayLikeToArray","prototype","toString","slice","constructor","name","from","test","arr","len","arr2","dependencies","factory","_ref","Matrix","DenseMatrix","data","datatype","SyntaxError","isString","Error","isMatrix","type","_data","clone","_size","_datatype","toArray","size","validate","preprocess","arraySize","typeOf","createDenseMatrix","isDenseMatrix","getDataType","getArrayDataType","storage","create","subset","index","replacement","defaultValue","arguments","_get","_set","get","DimensionError","x","validateIndex","ii","indexI","set","map","_fit","matrix","isIndex","isScalar","min","max","_getSubmatrix","dims","dim","last","range","dimension","valueOf","child","submatrix","iSize","sSize","outer","unsqueeze","deepStrictEqual","_setSubmatrix","forEach","dataIndex","subIndex","resize","copy","isCollection","sizeArray","m","_resize","v","reshape","currentLength","reduce","processSizesWildcard","newSize","changed","push","callback","me","args","maxArgumentCount","recurse","concat","undefined","mark","_callee","wrap","_callee$","_context2","prev","recurse$","_context","delegateYield","stop","rows","result","_iterator","_step","row","columns","_this","_loop","col","format","options","toJSON","mathjs","diagonal","k","isBigNumber","toNumber","isNumber","isInteger","kSuper","kSub","Math","_value","ms","mul","d","fromJSON","json","swapRows","j","_swapRows","vi","elem","isClass"],"sources":["C:/Users/Admin/Desktop/React-Web-main/node_modules/mathjs/lib/cjs/type/matrix/DenseMatrix.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createDenseMatrixClass = void 0;\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\nvar _is = require(\"../../utils/is.js\");\nvar _array = require(\"../../utils/array.js\");\nvar _string = require(\"../../utils/string.js\");\nvar _number = require(\"../../utils/number.js\");\nvar _object = require(\"../../utils/object.js\");\nvar _DimensionError = require(\"../../error/DimensionError.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar _function = require(\"../../utils/function.js\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar name = 'DenseMatrix';\nvar dependencies = ['Matrix'];\nvar createDenseMatrixClass = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var Matrix = _ref.Matrix;\n  /**\n   * Dense Matrix implementation. A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.\n   * @class DenseMatrix\n   * @enum {{ value, index: number[] }}\n   */\n  function DenseMatrix(data, datatype) {\n    if (!(this instanceof DenseMatrix)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n    if (datatype && !(0, _is.isString)(datatype)) {\n      throw new Error('Invalid datatype: ' + datatype);\n    }\n    if ((0, _is.isMatrix)(data)) {\n      // check data is a DenseMatrix\n      if (data.type === 'DenseMatrix') {\n        // clone data & size\n        this._data = (0, _object.clone)(data._data);\n        this._size = (0, _object.clone)(data._size);\n        this._datatype = datatype || data._datatype;\n      } else {\n        // build data from existing matrix\n        this._data = data.toArray();\n        this._size = data.size();\n        this._datatype = datatype || data._datatype;\n      }\n    } else if (data && (0, _is.isArray)(data.data) && (0, _is.isArray)(data.size)) {\n      // initialize fields from JSON representation\n      this._data = data.data;\n      this._size = data.size;\n      // verify the dimensions of the array\n      (0, _array.validate)(this._data, this._size);\n      this._datatype = datatype || data.datatype;\n    } else if ((0, _is.isArray)(data)) {\n      // replace nested Matrices with Arrays\n      this._data = preprocess(data);\n      // get the dimensions of the array\n      this._size = (0, _array.arraySize)(this._data);\n      // verify the dimensions of the array, TODO: compute size while processing array\n      (0, _array.validate)(this._data, this._size);\n      // data type unknown\n      this._datatype = datatype;\n    } else if (data) {\n      // unsupported type\n      throw new TypeError('Unsupported type of data (' + (0, _is.typeOf)(data) + ')');\n    } else {\n      // nothing provided\n      this._data = [];\n      this._size = [0];\n      this._datatype = datatype;\n    }\n  }\n  DenseMatrix.prototype = new Matrix();\n\n  /**\n   * Create a new DenseMatrix\n   */\n  DenseMatrix.prototype.createDenseMatrix = function (data, datatype) {\n    return new DenseMatrix(data, datatype);\n  };\n\n  /**\n   * Attach type information\n   */\n  Object.defineProperty(DenseMatrix, 'name', {\n    value: 'DenseMatrix'\n  });\n  DenseMatrix.prototype.constructor = DenseMatrix;\n  DenseMatrix.prototype.type = 'DenseMatrix';\n  DenseMatrix.prototype.isDenseMatrix = true;\n\n  /**\n   * Get the matrix type\n   *\n   * Usage:\n   *    const matrixType = matrix.getDataType()  // retrieves the matrix type\n   *\n   * @memberOf DenseMatrix\n   * @return {string}   type information; if multiple types are found from the Matrix, it will return \"mixed\"\n   */\n  DenseMatrix.prototype.getDataType = function () {\n    return (0, _array.getArrayDataType)(this._data, _is.typeOf);\n  };\n\n  /**\n   * Get the storage format used by the matrix.\n   *\n   * Usage:\n   *     const format = matrix.storage()  // retrieve storage format\n   *\n   * @memberof DenseMatrix\n   * @return {string}           The storage format.\n   */\n  DenseMatrix.prototype.storage = function () {\n    return 'dense';\n  };\n\n  /**\n   * Get the datatype of the data stored in the matrix.\n   *\n   * Usage:\n   *     const format = matrix.datatype()   // retrieve matrix datatype\n   *\n   * @memberof DenseMatrix\n   * @return {string}           The datatype.\n   */\n  DenseMatrix.prototype.datatype = function () {\n    return this._datatype;\n  };\n\n  /**\n   * Create a new DenseMatrix\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @param {string} [datatype]\n   */\n  DenseMatrix.prototype.create = function (data, datatype) {\n    return new DenseMatrix(data, datatype);\n  };\n\n  /**\n   * Get a subset of the matrix, or replace a subset of the matrix.\n   *\n   * Usage:\n   *     const subset = matrix.subset(index)               // retrieve subset\n   *     const value = matrix.subset(index, replacement)   // replace subset\n   *\n   * @memberof DenseMatrix\n   * @param {Index} index\n   * @param {Array | Matrix | *} [replacement]\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be filled with zeros.\n   */\n  DenseMatrix.prototype.subset = function (index, replacement, defaultValue) {\n    switch (arguments.length) {\n      case 1:\n        return _get(this, index);\n\n      // intentional fall through\n      case 2:\n      case 3:\n        return _set(this, index, replacement, defaultValue);\n      default:\n        throw new SyntaxError('Wrong number of arguments');\n    }\n  };\n\n  /**\n   * Get a single element from the matrix.\n   * @memberof DenseMatrix\n   * @param {number[]} index   Zero-based index\n   * @return {*} value\n   */\n  DenseMatrix.prototype.get = function (index) {\n    if (!(0, _is.isArray)(index)) {\n      throw new TypeError('Array expected');\n    }\n    if (index.length !== this._size.length) {\n      throw new _DimensionError.DimensionError(index.length, this._size.length);\n    }\n\n    // check index\n    for (var x = 0; x < index.length; x++) {\n      (0, _array.validateIndex)(index[x], this._size[x]);\n    }\n    var data = this._data;\n    for (var i = 0, ii = index.length; i < ii; i++) {\n      var indexI = index[i];\n      (0, _array.validateIndex)(indexI, data.length);\n      data = data[indexI];\n    }\n    return data;\n  };\n\n  /**\n   * Replace a single element in the matrix.\n   * @memberof DenseMatrix\n   * @param {number[]} index   Zero-based index\n   * @param {*} value\n   * @param {*} [defaultValue]        Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be left undefined.\n   * @return {DenseMatrix} self\n   */\n  DenseMatrix.prototype.set = function (index, value, defaultValue) {\n    if (!(0, _is.isArray)(index)) {\n      throw new TypeError('Array expected');\n    }\n    if (index.length < this._size.length) {\n      throw new _DimensionError.DimensionError(index.length, this._size.length, '<');\n    }\n    var i, ii, indexI;\n\n    // enlarge matrix when needed\n    var size = index.map(function (i) {\n      return i + 1;\n    });\n    _fit(this, size, defaultValue);\n\n    // traverse over the dimensions\n    var data = this._data;\n    for (i = 0, ii = index.length - 1; i < ii; i++) {\n      indexI = index[i];\n      (0, _array.validateIndex)(indexI, data.length);\n      data = data[indexI];\n    }\n\n    // set new value\n    indexI = index[index.length - 1];\n    (0, _array.validateIndex)(indexI, data.length);\n    data[indexI] = value;\n    return this;\n  };\n\n  /**\n   * Get a submatrix of this matrix\n   * @memberof DenseMatrix\n   * @param {DenseMatrix} matrix\n   * @param {Index} index   Zero-based index\n   * @private\n   */\n  function _get(matrix, index) {\n    if (!(0, _is.isIndex)(index)) {\n      throw new TypeError('Invalid index');\n    }\n    var isScalar = index.isScalar();\n    if (isScalar) {\n      // return a scalar\n      return matrix.get(index.min());\n    } else {\n      // validate dimensions\n      var size = index.size();\n      if (size.length !== matrix._size.length) {\n        throw new _DimensionError.DimensionError(size.length, matrix._size.length);\n      }\n\n      // validate if any of the ranges in the index is out of range\n      var min = index.min();\n      var max = index.max();\n      for (var i = 0, ii = matrix._size.length; i < ii; i++) {\n        (0, _array.validateIndex)(min[i], matrix._size[i]);\n        (0, _array.validateIndex)(max[i], matrix._size[i]);\n      }\n\n      // retrieve submatrix\n      // TODO: more efficient when creating an empty matrix and setting _data and _size manually\n      return new DenseMatrix(_getSubmatrix(matrix._data, index, size.length, 0), matrix._datatype);\n    }\n  }\n\n  /**\n   * Recursively get a submatrix of a multi dimensional matrix.\n   * Index is not checked for correct number or length of dimensions.\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @param {Index} index\n   * @param {number} dims   Total number of dimensions\n   * @param {number} dim    Current dimension\n   * @return {Array} submatrix\n   * @private\n   */\n  function _getSubmatrix(data, index, dims, dim) {\n    var last = dim === dims - 1;\n    var range = index.dimension(dim);\n    if (last) {\n      return range.map(function (i) {\n        (0, _array.validateIndex)(i, data.length);\n        return data[i];\n      }).valueOf();\n    } else {\n      return range.map(function (i) {\n        (0, _array.validateIndex)(i, data.length);\n        var child = data[i];\n        return _getSubmatrix(child, index, dims, dim + 1);\n      }).valueOf();\n    }\n  }\n\n  /**\n   * Replace a submatrix in this matrix\n   * Indexes are zero-based.\n   * @memberof DenseMatrix\n   * @param {DenseMatrix} matrix\n   * @param {Index} index\n   * @param {DenseMatrix | Array | *} submatrix\n   * @param {*} defaultValue          Default value, filled in on new entries when\n   *                                  the matrix is resized.\n   * @return {DenseMatrix} matrix\n   * @private\n   */\n  function _set(matrix, index, submatrix, defaultValue) {\n    if (!index || index.isIndex !== true) {\n      throw new TypeError('Invalid index');\n    }\n\n    // get index size and check whether the index contains a single value\n    var iSize = index.size();\n    var isScalar = index.isScalar();\n\n    // calculate the size of the submatrix, and convert it into an Array if needed\n    var sSize;\n    if ((0, _is.isMatrix)(submatrix)) {\n      sSize = submatrix.size();\n      submatrix = submatrix.valueOf();\n    } else {\n      sSize = (0, _array.arraySize)(submatrix);\n    }\n    if (isScalar) {\n      // set a scalar\n\n      // check whether submatrix is a scalar\n      if (sSize.length !== 0) {\n        throw new TypeError('Scalar expected');\n      }\n      matrix.set(index.min(), submatrix, defaultValue);\n    } else {\n      // set a submatrix\n\n      // validate dimensions\n      if (iSize.length < matrix._size.length) {\n        throw new _DimensionError.DimensionError(iSize.length, matrix._size.length, '<');\n      }\n      if (sSize.length < iSize.length) {\n        // calculate number of missing outer dimensions\n        var i = 0;\n        var outer = 0;\n        while (iSize[i] === 1 && sSize[i] === 1) {\n          i++;\n        }\n        while (iSize[i] === 1) {\n          outer++;\n          i++;\n        }\n\n        // unsqueeze both outer and inner dimensions\n        submatrix = (0, _array.unsqueeze)(submatrix, iSize.length, outer, sSize);\n      }\n\n      // check whether the size of the submatrix matches the index size\n      if (!(0, _object.deepStrictEqual)(iSize, sSize)) {\n        throw new _DimensionError.DimensionError(iSize, sSize, '>');\n      }\n\n      // enlarge matrix when needed\n      var size = index.max().map(function (i) {\n        return i + 1;\n      });\n      _fit(matrix, size, defaultValue);\n\n      // insert the sub matrix\n      var dims = iSize.length;\n      var dim = 0;\n      _setSubmatrix(matrix._data, index, submatrix, dims, dim);\n    }\n    return matrix;\n  }\n\n  /**\n   * Replace a submatrix of a multi dimensional matrix.\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @param {Index} index\n   * @param {Array} submatrix\n   * @param {number} dims   Total number of dimensions\n   * @param {number} dim\n   * @private\n   */\n  function _setSubmatrix(data, index, submatrix, dims, dim) {\n    var last = dim === dims - 1;\n    var range = index.dimension(dim);\n    if (last) {\n      range.forEach(function (dataIndex, subIndex) {\n        (0, _array.validateIndex)(dataIndex);\n        data[dataIndex] = submatrix[subIndex[0]];\n      });\n    } else {\n      range.forEach(function (dataIndex, subIndex) {\n        (0, _array.validateIndex)(dataIndex);\n        _setSubmatrix(data[dataIndex], index, submatrix[subIndex[0]], dims, dim + 1);\n      });\n    }\n  }\n\n  /**\n   * Resize the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (resize in place).\n   *\n   * @memberof DenseMatrix\n   * @param {number[] || Matrix} size The new size the matrix should have.\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries.\n   *                                  If not provided, the matrix elements will\n   *                                  be filled with zeros.\n   * @param {boolean} [copy]          Return a resized copy of the matrix\n   *\n   * @return {Matrix}                 The resized matrix\n   */\n  DenseMatrix.prototype.resize = function (size, defaultValue, copy) {\n    // validate arguments\n    if (!(0, _is.isCollection)(size)) {\n      throw new TypeError('Array or Matrix expected');\n    }\n\n    // SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector\n    var sizeArray = size.valueOf().map(function (value) {\n      return Array.isArray(value) && value.length === 1 ? value[0] : value;\n    });\n\n    // matrix to resize\n    var m = copy ? this.clone() : this;\n    // resize matrix\n    return _resize(m, sizeArray, defaultValue);\n  };\n  function _resize(matrix, size, defaultValue) {\n    // check size\n    if (size.length === 0) {\n      // first value in matrix\n      var v = matrix._data;\n      // go deep\n      while ((0, _is.isArray)(v)) {\n        v = v[0];\n      }\n      return v;\n    }\n    // resize matrix\n    matrix._size = size.slice(0); // copy the array\n    matrix._data = (0, _array.resize)(matrix._data, matrix._size, defaultValue);\n    // return matrix\n    return matrix;\n  }\n\n  /**\n   * Reshape the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (reshape in place).\n   *\n   * NOTE: This might be better suited to copy by default, instead of modifying\n   *       in place. For now, it operates in place to remain consistent with\n   *       resize().\n   *\n   * @memberof DenseMatrix\n   * @param {number[]} size           The new size the matrix should have.\n   * @param {boolean} [copy]          Return a reshaped copy of the matrix\n   *\n   * @return {Matrix}                 The reshaped matrix\n   */\n  DenseMatrix.prototype.reshape = function (size, copy) {\n    var m = copy ? this.clone() : this;\n    m._data = (0, _array.reshape)(m._data, size);\n    var currentLength = m._size.reduce(function (length, size) {\n      return length * size;\n    });\n    m._size = (0, _array.processSizesWildcard)(size, currentLength);\n    return m;\n  };\n\n  /**\n   * Enlarge the matrix when it is smaller than given size.\n   * If the matrix is larger or equal sized, nothing is done.\n   * @memberof DenseMatrix\n   * @param {DenseMatrix} matrix           The matrix to be resized\n   * @param {number[]} size\n   * @param {*} defaultValue          Default value, filled in on new entries.\n   * @private\n   */\n  function _fit(matrix, size, defaultValue) {\n    var\n    // copy the array\n    newSize = matrix._size.slice(0);\n    var changed = false;\n\n    // add dimensions when needed\n    while (newSize.length < size.length) {\n      newSize.push(0);\n      changed = true;\n    }\n\n    // enlarge size when needed\n    for (var i = 0, ii = size.length; i < ii; i++) {\n      if (size[i] > newSize[i]) {\n        newSize[i] = size[i];\n        changed = true;\n      }\n    }\n    if (changed) {\n      // resize only when size is changed\n      _resize(matrix, newSize, defaultValue);\n    }\n  }\n\n  /**\n   * Create a clone of the matrix\n   * @memberof DenseMatrix\n   * @return {DenseMatrix} clone\n   */\n  DenseMatrix.prototype.clone = function () {\n    var m = new DenseMatrix({\n      data: (0, _object.clone)(this._data),\n      size: (0, _object.clone)(this._size),\n      datatype: this._datatype\n    });\n    return m;\n  };\n\n  /**\n   * Retrieve the size of the matrix.\n   * @memberof DenseMatrix\n   * @returns {number[]} size\n   */\n  DenseMatrix.prototype.size = function () {\n    return this._size.slice(0); // return a clone of _size\n  };\n\n  /**\n   * Create a new matrix with the results of the callback function executed on\n   * each entry of the matrix.\n   * @memberof DenseMatrix\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   *\n   * @return {DenseMatrix} matrix\n   */\n  DenseMatrix.prototype.map = function (callback) {\n    // matrix instance\n    var me = this;\n    var args = (0, _function.maxArgumentCount)(callback);\n    var recurse = function recurse(value, index) {\n      if ((0, _is.isArray)(value)) {\n        return value.map(function (child, i) {\n          return recurse(child, index.concat(i));\n        });\n      } else {\n        // invoke the callback function with the right number of arguments\n        if (args === 1) {\n          return callback(value);\n        } else if (args === 2) {\n          return callback(value, index);\n        } else {\n          // 3 or -1\n          return callback(value, index, me);\n        }\n      }\n    };\n\n    // determine the new datatype when the original matrix has datatype defined\n    // TODO: should be done in matrix constructor instead\n    var data = recurse(this._data, []);\n    var datatype = this._datatype !== undefined ? (0, _array.getArrayDataType)(data, _is.typeOf) : undefined;\n    return new DenseMatrix(data, datatype);\n  };\n\n  /**\n   * Execute a callback function on each entry of the matrix.\n   * @memberof DenseMatrix\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   */\n  DenseMatrix.prototype.forEach = function (callback) {\n    // matrix instance\n    var me = this;\n    var recurse = function recurse(value, index) {\n      if ((0, _is.isArray)(value)) {\n        value.forEach(function (child, i) {\n          recurse(child, index.concat(i));\n        });\n      } else {\n        callback(value, index, me);\n      }\n    };\n    recurse(this._data, []);\n  };\n\n  /**\n   * Iterate over the matrix elements\n   * @return {Iterable<{ value, index: number[] }>}\n   */\n  DenseMatrix.prototype[Symbol.iterator] = /*#__PURE__*/_regenerator[\"default\"].mark(function _callee() {\n    var recurse;\n    return _regenerator[\"default\"].wrap(function _callee$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            recurse = /*#__PURE__*/_regenerator[\"default\"].mark(function recurse(value, index) {\n              var i;\n              return _regenerator[\"default\"].wrap(function recurse$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      if (!(0, _is.isArray)(value)) {\n                        _context.next = 9;\n                        break;\n                      }\n                      i = 0;\n                    case 2:\n                      if (!(i < value.length)) {\n                        _context.next = 7;\n                        break;\n                      }\n                      return _context.delegateYield(recurse(value[i], index.concat(i)), \"t0\", 4);\n                    case 4:\n                      i++;\n                      _context.next = 2;\n                      break;\n                    case 7:\n                      _context.next = 11;\n                      break;\n                    case 9:\n                      _context.next = 11;\n                      return {\n                        value: value,\n                        index: index\n                      };\n                    case 11:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, recurse);\n            });\n            return _context2.delegateYield(recurse(this._data, []), \"t0\", 2);\n          case 2:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee, this);\n  });\n\n  /**\n   * Returns an array containing the rows of a 2D matrix\n   * @returns {Array<Matrix>}\n   */\n  DenseMatrix.prototype.rows = function () {\n    var result = [];\n    var s = this.size();\n    if (s.length !== 2) {\n      throw new TypeError('Rows can only be returned for a 2D matrix.');\n    }\n    var data = this._data;\n    var _iterator = _createForOfIteratorHelper(data),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var row = _step.value;\n        result.push(new DenseMatrix([row], this._datatype));\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return result;\n  };\n\n  /**\n   * Returns an array containing the columns of a 2D matrix\n   * @returns {Array<Matrix>}\n   */\n  DenseMatrix.prototype.columns = function () {\n    var _this = this;\n    var result = [];\n    var s = this.size();\n    if (s.length !== 2) {\n      throw new TypeError('Rows can only be returned for a 2D matrix.');\n    }\n    var data = this._data;\n    var _loop = function _loop(i) {\n      var col = data.map(function (row) {\n        return [row[i]];\n      });\n      result.push(new DenseMatrix(col, _this._datatype));\n    };\n    for (var i = 0; i < s[1]; i++) {\n      _loop(i);\n    }\n    return result;\n  };\n\n  /**\n   * Create an Array with a copy of the data of the DenseMatrix\n   * @memberof DenseMatrix\n   * @returns {Array} array\n   */\n  DenseMatrix.prototype.toArray = function () {\n    return (0, _object.clone)(this._data);\n  };\n\n  /**\n   * Get the primitive value of the DenseMatrix: a multidimensional array\n   * @memberof DenseMatrix\n   * @returns {Array} array\n   */\n  DenseMatrix.prototype.valueOf = function () {\n    return this._data;\n  };\n\n  /**\n   * Get a string representation of the matrix, with optional formatting options.\n   * @memberof DenseMatrix\n   * @param {Object | number | Function} [options]  Formatting options. See\n   *                                                lib/utils/number:format for a\n   *                                                description of the available\n   *                                                options.\n   * @returns {string} str\n   */\n  DenseMatrix.prototype.format = function (options) {\n    return (0, _string.format)(this._data, options);\n  };\n\n  /**\n   * Get a string representation of the matrix\n   * @memberof DenseMatrix\n   * @returns {string} str\n   */\n  DenseMatrix.prototype.toString = function () {\n    return (0, _string.format)(this._data);\n  };\n\n  /**\n   * Get a JSON representation of the matrix\n   * @memberof DenseMatrix\n   * @returns {Object}\n   */\n  DenseMatrix.prototype.toJSON = function () {\n    return {\n      mathjs: 'DenseMatrix',\n      data: this._data,\n      size: this._size,\n      datatype: this._datatype\n    };\n  };\n\n  /**\n   * Get the kth Matrix diagonal.\n   *\n   * @memberof DenseMatrix\n   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.\n   *\n   * @returns {Matrix}                     The matrix with the diagonal values.\n   */\n  DenseMatrix.prototype.diagonal = function (k) {\n    // validate k if any\n    if (k) {\n      // convert BigNumber to a number\n      if ((0, _is.isBigNumber)(k)) {\n        k = k.toNumber();\n      }\n      // is must be an integer\n      if (!(0, _is.isNumber)(k) || !(0, _number.isInteger)(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    }\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0;\n\n    // rows & columns\n    var rows = this._size[0];\n    var columns = this._size[1];\n\n    // number diagonal values\n    var n = Math.min(rows - kSub, columns - kSuper);\n\n    // x is a matrix get diagonal from matrix\n    var data = [];\n\n    // loop rows\n    for (var i = 0; i < n; i++) {\n      data[i] = this._data[i + kSub][i + kSuper];\n    }\n\n    // create DenseMatrix\n    return new DenseMatrix({\n      data: data,\n      size: [n],\n      datatype: this._datatype\n    });\n  };\n\n  /**\n   * Create a diagonal matrix.\n   *\n   * @memberof DenseMatrix\n   * @param {Array} size                     The matrix size.\n   * @param {number | Matrix | Array } value The values for the diagonal.\n   * @param {number | BigNumber} [k=0]       The kth diagonal where the vector will be filled in.\n   * @param {number} [defaultValue]          The default value for non-diagonal\n   * @param {string} [datatype]              The datatype for the diagonal\n   *\n   * @returns {DenseMatrix}\n   */\n  DenseMatrix.diagonal = function (size, value, k, defaultValue) {\n    if (!(0, _is.isArray)(size)) {\n      throw new TypeError('Array expected, size parameter');\n    }\n    if (size.length !== 2) {\n      throw new Error('Only two dimensions matrix are supported');\n    }\n\n    // map size & validate\n    size = size.map(function (s) {\n      // check it is a big number\n      if ((0, _is.isBigNumber)(s)) {\n        // convert it\n        s = s.toNumber();\n      }\n      // validate arguments\n      if (!(0, _is.isNumber)(s) || !(0, _number.isInteger)(s) || s < 1) {\n        throw new Error('Size values must be positive integers');\n      }\n      return s;\n    });\n\n    // validate k if any\n    if (k) {\n      // convert BigNumber to a number\n      if ((0, _is.isBigNumber)(k)) {\n        k = k.toNumber();\n      }\n      // is must be an integer\n      if (!(0, _is.isNumber)(k) || !(0, _number.isInteger)(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    }\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0;\n\n    // rows and columns\n    var rows = size[0];\n    var columns = size[1];\n\n    // number of non-zero items\n    var n = Math.min(rows - kSub, columns - kSuper);\n\n    // value extraction function\n    var _value;\n\n    // check value\n    if ((0, _is.isArray)(value)) {\n      // validate array\n      if (value.length !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid value array length');\n      }\n      // define function\n      _value = function _value(i) {\n        // return value @ i\n        return value[i];\n      };\n    } else if ((0, _is.isMatrix)(value)) {\n      // matrix size\n      var ms = value.size();\n      // validate matrix\n      if (ms.length !== 1 || ms[0] !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid matrix length');\n      }\n      // define function\n      _value = function _value(i) {\n        // return value @ i\n        return value.get([i]);\n      };\n    } else {\n      // define function\n      _value = function _value() {\n        // return value\n        return value;\n      };\n    }\n\n    // discover default value if needed\n    if (!defaultValue) {\n      // check first value in array\n      defaultValue = (0, _is.isBigNumber)(_value(0)) ? _value(0).mul(0) // trick to create a BigNumber with value zero\n      : 0;\n    }\n\n    // empty array\n    var data = [];\n\n    // check we need to resize array\n    if (size.length > 0) {\n      // resize array\n      data = (0, _array.resize)(data, size, defaultValue);\n      // fill diagonal\n      for (var d = 0; d < n; d++) {\n        data[d + kSub][d + kSuper] = _value(d);\n      }\n    }\n\n    // create DenseMatrix\n    return new DenseMatrix({\n      data: data,\n      size: [rows, columns]\n    });\n  };\n\n  /**\n   * Generate a matrix from a JSON object\n   * @memberof DenseMatrix\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"DenseMatrix\", data: [], size: []}`,\n   *                       where mathjs is optional\n   * @returns {DenseMatrix}\n   */\n  DenseMatrix.fromJSON = function (json) {\n    return new DenseMatrix(json);\n  };\n\n  /**\n   * Swap rows i and j in Matrix.\n   *\n   * @memberof DenseMatrix\n   * @param {number} i       Matrix row index 1\n   * @param {number} j       Matrix row index 2\n   *\n   * @return {Matrix}        The matrix reference\n   */\n  DenseMatrix.prototype.swapRows = function (i, j) {\n    // check index\n    if (!(0, _is.isNumber)(i) || !(0, _number.isInteger)(i) || !(0, _is.isNumber)(j) || !(0, _number.isInteger)(j)) {\n      throw new Error('Row index must be positive integers');\n    }\n    // check dimensions\n    if (this._size.length !== 2) {\n      throw new Error('Only two dimensional matrix is supported');\n    }\n    // validate index\n    (0, _array.validateIndex)(i, this._size[0]);\n    (0, _array.validateIndex)(j, this._size[0]);\n\n    // swap rows\n    DenseMatrix._swapRows(i, j, this._data);\n    // return current instance\n    return this;\n  };\n\n  /**\n   * Swap rows i and j in Dense Matrix data structure.\n   *\n   * @param {number} i       Matrix row index 1\n   * @param {number} j       Matrix row index 2\n   * @param {Array} data     Matrix data\n   */\n  DenseMatrix._swapRows = function (i, j, data) {\n    // swap values i <-> j\n    var vi = data[i];\n    data[i] = data[j];\n    data[j] = vi;\n  };\n\n  /**\n   * Preprocess data, which can be an Array or DenseMatrix with nested Arrays and\n   * Matrices. Replaces all nested Matrices with Arrays\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @return {Array} data\n   */\n  function preprocess(data) {\n    for (var i = 0, ii = data.length; i < ii; i++) {\n      var elem = data[i];\n      if ((0, _is.isArray)(elem)) {\n        data[i] = preprocess(elem);\n      } else if (elem && elem.isMatrix === true) {\n        data[i] = preprocess(elem.valueOf());\n      }\n    }\n    return data;\n  }\n  return DenseMatrix;\n}, {\n  isClass: true\n});\nexports.createDenseMatrixClass = createDenseMatrixClass;"],"mappings":"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"},"metadata":{},"sourceType":"script"}