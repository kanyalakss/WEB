{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSimplifyCore = void 0;\nvar _is = require(\"../../utils/is.js\");\nvar _operators = require(\"../../expression/operators.js\");\nvar _util = require(\"./simplify/util.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar name = 'simplifyCore';\nvar dependencies = ['typed', 'parse', 'equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\nvar createSimplifyCore = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n    parse = _ref.parse,\n    equal = _ref.equal,\n    isZero = _ref.isZero,\n    add = _ref.add,\n    subtract = _ref.subtract,\n    multiply = _ref.multiply,\n    divide = _ref.divide,\n    pow = _ref.pow,\n    AccessorNode = _ref.AccessorNode,\n    ArrayNode = _ref.ArrayNode,\n    ConstantNode = _ref.ConstantNode,\n    FunctionNode = _ref.FunctionNode,\n    IndexNode = _ref.IndexNode,\n    ObjectNode = _ref.ObjectNode,\n    OperatorNode = _ref.OperatorNode,\n    ParenthesisNode = _ref.ParenthesisNode,\n    SymbolNode = _ref.SymbolNode;\n  var node0 = new ConstantNode(0);\n  var node1 = new ConstantNode(1);\n  var nodeT = new ConstantNode(true);\n  var nodeF = new ConstantNode(false);\n  // test if a node will always have a boolean value (true/false)\n  // not sure if this list is complete\n  function isAlwaysBoolean(node) {\n    return (0, _is.isOperatorNode)(node) && ['and', 'not', 'or'].includes(node.op);\n  }\n  var _createUtil = (0, _util.createUtil)({\n      FunctionNode: FunctionNode,\n      OperatorNode: OperatorNode,\n      SymbolNode: SymbolNode\n    }),\n    hasProperty = _createUtil.hasProperty,\n    isCommutative = _createUtil.isCommutative;\n  /**\n   * simplifyCore() performs single pass simplification suitable for\n   * applications requiring ultimate performance. To roughly summarize,\n   * it handles cases along the lines of simplifyConstant() but where\n   * knowledge of a single argument is sufficient to determine the value.\n   * In contrast, simplify() extends simplifyCore() with additional passes\n   * to provide deeper simplification (such as gathering like terms).\n   *\n   * Specifically, simplifyCore:\n   *\n   * * Converts all function calls with operator equivalents to their\n   *   operator forms.\n   * * Removes operators or function calls that are guaranteed to have no\n   *   effect (such as unary '+').\n   * * Removes double unary '-', '~', and 'not'\n   * * Eliminates addition/subtraction of 0 and multiplication/division/powers\n   *   by 1 or 0.\n   * * Converts addition of a negation into subtraction.\n   * * Eliminates logical operations with constant true or false leading\n   *   arguments.\n   * * Puts constants on the left of a product, if multiplication is\n   *   considered commutative by the options (which is the default)\n   *\n   * Syntax:\n   *\n   *     simplifyCore(expr)\n   *     simplifyCore(expr, options)\n   *\n   * Examples:\n   *\n   *     const f = math.parse('2 * 1 * x ^ (1 - 0)')\n   *     math.simplifyCore(f)                          // Node \"2 * x\"\n   *     math.simplify('2 * 1 * x ^ (1 - 0)', [math.simplifyCore]) // Node \"2 * x\"\n   *\n   * See also:\n   *\n   *     simplify, simplifyConstant, resolve, derivative\n   *\n   * @param {Node | string} node\n   *     The expression to be simplified\n   * @param {Object} options\n   *     Simplification options, as per simplify()\n   * @return {Node} Returns expression with basic simplifications applied\n   */\n  function _simplifyCore(nodeToSimplify) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var context = options ? options.context : undefined;\n    if (hasProperty(nodeToSimplify, 'trivial', context)) {\n      // This node does nothing if it has only one argument, so if so,\n      // return that argument simplified\n      if ((0, _is.isFunctionNode)(nodeToSimplify) && nodeToSimplify.args.length === 1) {\n        return _simplifyCore(nodeToSimplify.args[0], options);\n      }\n      // For other node types, we try the generic methods\n      var simpChild = false;\n      var childCount = 0;\n      nodeToSimplify.forEach(function (c) {\n        ++childCount;\n        if (childCount === 1) {\n          simpChild = _simplifyCore(c, options);\n        }\n      });\n      if (childCount === 1) {\n        return simpChild;\n      }\n    }\n    var node = nodeToSimplify;\n    if ((0, _is.isFunctionNode)(node)) {\n      var op = (0, _operators.getOperator)(node.name);\n      if (op) {\n        // Replace FunctionNode with a new OperatorNode\n        if (node.args.length > 2 && hasProperty(node, 'associative', context)) {\n          // unflatten into binary operations since that's what simplifyCore handles\n          while (node.args.length > 2) {\n            var last = node.args.pop();\n            var seclast = node.args.pop();\n            node.args.push(new OperatorNode(op, node.name, [last, seclast]));\n          }\n        }\n        node = new OperatorNode(op, node.name, node.args);\n      } else {\n        return new FunctionNode(_simplifyCore(node.fn), node.args.map(function (n) {\n          return _simplifyCore(n, options);\n        }));\n      }\n    }\n    if ((0, _is.isOperatorNode)(node) && node.isUnary()) {\n      var a0 = _simplifyCore(node.args[0], options);\n      if (node.op === '~') {\n        // bitwise not\n        if ((0, _is.isOperatorNode)(a0) && a0.isUnary() && a0.op === '~') {\n          return a0.args[0];\n        }\n      }\n      if (node.op === 'not') {\n        // logical not\n        if ((0, _is.isOperatorNode)(a0) && a0.isUnary() && a0.op === 'not') {\n          // Has the effect of turning the argument into a boolean\n          // So can only eliminate the double negation if\n          // the inside is already boolean\n          if (isAlwaysBoolean(a0.args[0])) {\n            return a0.args[0];\n          }\n        }\n      }\n      var finish = true;\n      if (node.op === '-') {\n        // unary minus\n        if ((0, _is.isOperatorNode)(a0)) {\n          if (a0.isBinary() && a0.fn === 'subtract') {\n            node = new OperatorNode('-', 'subtract', [a0.args[1], a0.args[0]]);\n            finish = false; // continue to process the new binary node\n          }\n\n          if (a0.isUnary() && a0.op === '-') {\n            return a0.args[0];\n          }\n        }\n      }\n      if (finish) return new OperatorNode(node.op, node.fn, [a0]);\n    }\n    if ((0, _is.isOperatorNode)(node) && node.isBinary()) {\n      var _a = _simplifyCore(node.args[0], options);\n      var a1 = _simplifyCore(node.args[1], options);\n      if (node.op === '+') {\n        if ((0, _is.isConstantNode)(_a) && isZero(_a.value)) {\n          return a1;\n        }\n        if ((0, _is.isConstantNode)(a1) && isZero(a1.value)) {\n          return _a;\n        }\n        if ((0, _is.isOperatorNode)(a1) && a1.isUnary() && a1.op === '-') {\n          a1 = a1.args[0];\n          node = new OperatorNode('-', 'subtract', [_a, a1]);\n        }\n      }\n      if (node.op === '-') {\n        if ((0, _is.isOperatorNode)(a1) && a1.isUnary() && a1.op === '-') {\n          return _simplifyCore(new OperatorNode('+', 'add', [_a, a1.args[0]]), options);\n        }\n        if ((0, _is.isConstantNode)(_a) && isZero(_a.value)) {\n          return _simplifyCore(new OperatorNode('-', 'unaryMinus', [a1]));\n        }\n        if ((0, _is.isConstantNode)(a1) && isZero(a1.value)) {\n          return _a;\n        }\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      }\n      if (node.op === '*') {\n        if ((0, _is.isConstantNode)(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (equal(_a.value, 1)) {\n            return a1;\n          }\n        }\n        if ((0, _is.isConstantNode)(a1)) {\n          if (isZero(a1.value)) {\n            return node0;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          }\n          if (isCommutative(node, context)) {\n            return new OperatorNode(node.op, node.fn, [a1, _a], node.implicit); // constants on left\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);\n      }\n      if (node.op === '/') {\n        if ((0, _is.isConstantNode)(_a) && isZero(_a.value)) {\n          return node0;\n        }\n        if ((0, _is.isConstantNode)(a1) && equal(a1.value, 1)) {\n          return _a;\n        }\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      }\n      if (node.op === '^') {\n        if ((0, _is.isConstantNode)(a1)) {\n          if (isZero(a1.value)) {\n            return node1;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          }\n        }\n      }\n      if (node.op === 'and') {\n        if ((0, _is.isConstantNode)(_a)) {\n          if (_a.value) {\n            if (isAlwaysBoolean(a1)) return a1;\n          } else {\n            return nodeF;\n          }\n        }\n        if ((0, _is.isConstantNode)(a1)) {\n          if (a1.value) {\n            if (isAlwaysBoolean(_a)) return _a;\n          } else {\n            return nodeF;\n          }\n        }\n      }\n      if (node.op === 'or') {\n        if ((0, _is.isConstantNode)(_a)) {\n          if (_a.value) {\n            return nodeT;\n          } else {\n            if (isAlwaysBoolean(a1)) return a1;\n          }\n        }\n        if ((0, _is.isConstantNode)(a1)) {\n          if (a1.value) {\n            return nodeT;\n          } else {\n            if (isAlwaysBoolean(_a)) return _a;\n          }\n        }\n      }\n      return new OperatorNode(node.op, node.fn, [_a, a1]);\n    }\n    if ((0, _is.isOperatorNode)(node)) {\n      return new OperatorNode(node.op, node.fn, node.args.map(function (a) {\n        return _simplifyCore(a, options);\n      }));\n    }\n    if ((0, _is.isArrayNode)(node)) {\n      return new ArrayNode(node.items.map(function (n) {\n        return _simplifyCore(n, options);\n      }));\n    }\n    if ((0, _is.isAccessorNode)(node)) {\n      return new AccessorNode(_simplifyCore(node.object, options), _simplifyCore(node.index, options));\n    }\n    if ((0, _is.isIndexNode)(node)) {\n      return new IndexNode(node.dimensions.map(function (n) {\n        return _simplifyCore(n, options);\n      }));\n    }\n    if ((0, _is.isObjectNode)(node)) {\n      var newProps = {};\n      for (var prop in node.properties) {\n        newProps[prop] = _simplifyCore(node.properties[prop], options);\n      }\n      return new ObjectNode(newProps);\n    }\n    // cannot simplify\n    return node;\n  }\n  return typed(name, {\n    Node: _simplifyCore,\n    'Node,Object': _simplifyCore\n  });\n});\nexports.createSimplifyCore = createSimplifyCore;","map":{"version":3,"names":["Object","defineProperty","exports","value","createSimplifyCore","_is","require","_operators","_util","_factory","name","dependencies","factory","_ref","typed","parse","equal","isZero","add","subtract","multiply","divide","pow","AccessorNode","ArrayNode","ConstantNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","ParenthesisNode","SymbolNode","node0","node1","nodeT","nodeF","isAlwaysBoolean","node","isOperatorNode","includes","op","_createUtil","createUtil","hasProperty","isCommutative","_simplifyCore","nodeToSimplify","options","arguments","length","undefined","context","isFunctionNode","args","simpChild","childCount","forEach","c","getOperator","last","pop","seclast","push","fn","map","n","isUnary","a0","finish","isBinary","_a","a1","isConstantNode","implicit","a","isArrayNode","items","isAccessorNode","object","index","isIndexNode","dimensions","isObjectNode","newProps","prop","properties","Node"],"sources":["C:/Users/Admin/Desktop/React-Web-main/node_modules/mathjs/lib/cjs/function/algebra/simplifyCore.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSimplifyCore = void 0;\nvar _is = require(\"../../utils/is.js\");\nvar _operators = require(\"../../expression/operators.js\");\nvar _util = require(\"./simplify/util.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar name = 'simplifyCore';\nvar dependencies = ['typed', 'parse', 'equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\nvar createSimplifyCore = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n    parse = _ref.parse,\n    equal = _ref.equal,\n    isZero = _ref.isZero,\n    add = _ref.add,\n    subtract = _ref.subtract,\n    multiply = _ref.multiply,\n    divide = _ref.divide,\n    pow = _ref.pow,\n    AccessorNode = _ref.AccessorNode,\n    ArrayNode = _ref.ArrayNode,\n    ConstantNode = _ref.ConstantNode,\n    FunctionNode = _ref.FunctionNode,\n    IndexNode = _ref.IndexNode,\n    ObjectNode = _ref.ObjectNode,\n    OperatorNode = _ref.OperatorNode,\n    ParenthesisNode = _ref.ParenthesisNode,\n    SymbolNode = _ref.SymbolNode;\n  var node0 = new ConstantNode(0);\n  var node1 = new ConstantNode(1);\n  var nodeT = new ConstantNode(true);\n  var nodeF = new ConstantNode(false);\n  // test if a node will always have a boolean value (true/false)\n  // not sure if this list is complete\n  function isAlwaysBoolean(node) {\n    return (0, _is.isOperatorNode)(node) && ['and', 'not', 'or'].includes(node.op);\n  }\n  var _createUtil = (0, _util.createUtil)({\n      FunctionNode: FunctionNode,\n      OperatorNode: OperatorNode,\n      SymbolNode: SymbolNode\n    }),\n    hasProperty = _createUtil.hasProperty,\n    isCommutative = _createUtil.isCommutative;\n  /**\n   * simplifyCore() performs single pass simplification suitable for\n   * applications requiring ultimate performance. To roughly summarize,\n   * it handles cases along the lines of simplifyConstant() but where\n   * knowledge of a single argument is sufficient to determine the value.\n   * In contrast, simplify() extends simplifyCore() with additional passes\n   * to provide deeper simplification (such as gathering like terms).\n   *\n   * Specifically, simplifyCore:\n   *\n   * * Converts all function calls with operator equivalents to their\n   *   operator forms.\n   * * Removes operators or function calls that are guaranteed to have no\n   *   effect (such as unary '+').\n   * * Removes double unary '-', '~', and 'not'\n   * * Eliminates addition/subtraction of 0 and multiplication/division/powers\n   *   by 1 or 0.\n   * * Converts addition of a negation into subtraction.\n   * * Eliminates logical operations with constant true or false leading\n   *   arguments.\n   * * Puts constants on the left of a product, if multiplication is\n   *   considered commutative by the options (which is the default)\n   *\n   * Syntax:\n   *\n   *     simplifyCore(expr)\n   *     simplifyCore(expr, options)\n   *\n   * Examples:\n   *\n   *     const f = math.parse('2 * 1 * x ^ (1 - 0)')\n   *     math.simplifyCore(f)                          // Node \"2 * x\"\n   *     math.simplify('2 * 1 * x ^ (1 - 0)', [math.simplifyCore]) // Node \"2 * x\"\n   *\n   * See also:\n   *\n   *     simplify, simplifyConstant, resolve, derivative\n   *\n   * @param {Node | string} node\n   *     The expression to be simplified\n   * @param {Object} options\n   *     Simplification options, as per simplify()\n   * @return {Node} Returns expression with basic simplifications applied\n   */\n  function _simplifyCore(nodeToSimplify) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var context = options ? options.context : undefined;\n    if (hasProperty(nodeToSimplify, 'trivial', context)) {\n      // This node does nothing if it has only one argument, so if so,\n      // return that argument simplified\n      if ((0, _is.isFunctionNode)(nodeToSimplify) && nodeToSimplify.args.length === 1) {\n        return _simplifyCore(nodeToSimplify.args[0], options);\n      }\n      // For other node types, we try the generic methods\n      var simpChild = false;\n      var childCount = 0;\n      nodeToSimplify.forEach(function (c) {\n        ++childCount;\n        if (childCount === 1) {\n          simpChild = _simplifyCore(c, options);\n        }\n      });\n      if (childCount === 1) {\n        return simpChild;\n      }\n    }\n    var node = nodeToSimplify;\n    if ((0, _is.isFunctionNode)(node)) {\n      var op = (0, _operators.getOperator)(node.name);\n      if (op) {\n        // Replace FunctionNode with a new OperatorNode\n        if (node.args.length > 2 && hasProperty(node, 'associative', context)) {\n          // unflatten into binary operations since that's what simplifyCore handles\n          while (node.args.length > 2) {\n            var last = node.args.pop();\n            var seclast = node.args.pop();\n            node.args.push(new OperatorNode(op, node.name, [last, seclast]));\n          }\n        }\n        node = new OperatorNode(op, node.name, node.args);\n      } else {\n        return new FunctionNode(_simplifyCore(node.fn), node.args.map(function (n) {\n          return _simplifyCore(n, options);\n        }));\n      }\n    }\n    if ((0, _is.isOperatorNode)(node) && node.isUnary()) {\n      var a0 = _simplifyCore(node.args[0], options);\n      if (node.op === '~') {\n        // bitwise not\n        if ((0, _is.isOperatorNode)(a0) && a0.isUnary() && a0.op === '~') {\n          return a0.args[0];\n        }\n      }\n      if (node.op === 'not') {\n        // logical not\n        if ((0, _is.isOperatorNode)(a0) && a0.isUnary() && a0.op === 'not') {\n          // Has the effect of turning the argument into a boolean\n          // So can only eliminate the double negation if\n          // the inside is already boolean\n          if (isAlwaysBoolean(a0.args[0])) {\n            return a0.args[0];\n          }\n        }\n      }\n      var finish = true;\n      if (node.op === '-') {\n        // unary minus\n        if ((0, _is.isOperatorNode)(a0)) {\n          if (a0.isBinary() && a0.fn === 'subtract') {\n            node = new OperatorNode('-', 'subtract', [a0.args[1], a0.args[0]]);\n            finish = false; // continue to process the new binary node\n          }\n\n          if (a0.isUnary() && a0.op === '-') {\n            return a0.args[0];\n          }\n        }\n      }\n      if (finish) return new OperatorNode(node.op, node.fn, [a0]);\n    }\n    if ((0, _is.isOperatorNode)(node) && node.isBinary()) {\n      var _a = _simplifyCore(node.args[0], options);\n      var a1 = _simplifyCore(node.args[1], options);\n      if (node.op === '+') {\n        if ((0, _is.isConstantNode)(_a) && isZero(_a.value)) {\n          return a1;\n        }\n        if ((0, _is.isConstantNode)(a1) && isZero(a1.value)) {\n          return _a;\n        }\n        if ((0, _is.isOperatorNode)(a1) && a1.isUnary() && a1.op === '-') {\n          a1 = a1.args[0];\n          node = new OperatorNode('-', 'subtract', [_a, a1]);\n        }\n      }\n      if (node.op === '-') {\n        if ((0, _is.isOperatorNode)(a1) && a1.isUnary() && a1.op === '-') {\n          return _simplifyCore(new OperatorNode('+', 'add', [_a, a1.args[0]]), options);\n        }\n        if ((0, _is.isConstantNode)(_a) && isZero(_a.value)) {\n          return _simplifyCore(new OperatorNode('-', 'unaryMinus', [a1]));\n        }\n        if ((0, _is.isConstantNode)(a1) && isZero(a1.value)) {\n          return _a;\n        }\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      }\n      if (node.op === '*') {\n        if ((0, _is.isConstantNode)(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (equal(_a.value, 1)) {\n            return a1;\n          }\n        }\n        if ((0, _is.isConstantNode)(a1)) {\n          if (isZero(a1.value)) {\n            return node0;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          }\n          if (isCommutative(node, context)) {\n            return new OperatorNode(node.op, node.fn, [a1, _a], node.implicit); // constants on left\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);\n      }\n      if (node.op === '/') {\n        if ((0, _is.isConstantNode)(_a) && isZero(_a.value)) {\n          return node0;\n        }\n        if ((0, _is.isConstantNode)(a1) && equal(a1.value, 1)) {\n          return _a;\n        }\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      }\n      if (node.op === '^') {\n        if ((0, _is.isConstantNode)(a1)) {\n          if (isZero(a1.value)) {\n            return node1;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          }\n        }\n      }\n      if (node.op === 'and') {\n        if ((0, _is.isConstantNode)(_a)) {\n          if (_a.value) {\n            if (isAlwaysBoolean(a1)) return a1;\n          } else {\n            return nodeF;\n          }\n        }\n        if ((0, _is.isConstantNode)(a1)) {\n          if (a1.value) {\n            if (isAlwaysBoolean(_a)) return _a;\n          } else {\n            return nodeF;\n          }\n        }\n      }\n      if (node.op === 'or') {\n        if ((0, _is.isConstantNode)(_a)) {\n          if (_a.value) {\n            return nodeT;\n          } else {\n            if (isAlwaysBoolean(a1)) return a1;\n          }\n        }\n        if ((0, _is.isConstantNode)(a1)) {\n          if (a1.value) {\n            return nodeT;\n          } else {\n            if (isAlwaysBoolean(_a)) return _a;\n          }\n        }\n      }\n      return new OperatorNode(node.op, node.fn, [_a, a1]);\n    }\n    if ((0, _is.isOperatorNode)(node)) {\n      return new OperatorNode(node.op, node.fn, node.args.map(function (a) {\n        return _simplifyCore(a, options);\n      }));\n    }\n    if ((0, _is.isArrayNode)(node)) {\n      return new ArrayNode(node.items.map(function (n) {\n        return _simplifyCore(n, options);\n      }));\n    }\n    if ((0, _is.isAccessorNode)(node)) {\n      return new AccessorNode(_simplifyCore(node.object, options), _simplifyCore(node.index, options));\n    }\n    if ((0, _is.isIndexNode)(node)) {\n      return new IndexNode(node.dimensions.map(function (n) {\n        return _simplifyCore(n, options);\n      }));\n    }\n    if ((0, _is.isObjectNode)(node)) {\n      var newProps = {};\n      for (var prop in node.properties) {\n        newProps[prop] = _simplifyCore(node.properties[prop], options);\n      }\n      return new ObjectNode(newProps);\n    }\n    // cannot simplify\n    return node;\n  }\n  return typed(name, {\n    Node: _simplifyCore,\n    'Node,Object': _simplifyCore\n  });\n});\nexports.createSimplifyCore = createSimplifyCore;"],"mappings":"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"},"metadata":{},"sourceType":"script"}