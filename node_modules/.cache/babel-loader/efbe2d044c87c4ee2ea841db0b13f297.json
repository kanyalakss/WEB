{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSimplify = void 0;\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\nvar _is = require(\"../../utils/is.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar _util = require(\"./simplify/util.js\");\nvar _object = require(\"../../utils/object.js\");\nvar _map = require(\"../../utils/map.js\");\nvar name = 'simplify';\nvar dependencies = ['config', 'typed', 'parse', 'add', 'subtract', 'multiply', 'divide', 'pow', 'isZero', 'equal', 'resolve', 'simplifyConstant', 'simplifyCore', '?fraction', '?bignumber', 'mathWithTransform', 'matrix', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\nvar createSimplify = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var config = _ref.config,\n    typed = _ref.typed,\n    parse = _ref.parse,\n    add = _ref.add,\n    subtract = _ref.subtract,\n    multiply = _ref.multiply,\n    divide = _ref.divide,\n    pow = _ref.pow,\n    isZero = _ref.isZero,\n    equal = _ref.equal,\n    resolve = _ref.resolve,\n    simplifyConstant = _ref.simplifyConstant,\n    simplifyCore = _ref.simplifyCore,\n    fraction = _ref.fraction,\n    bignumber = _ref.bignumber,\n    mathWithTransform = _ref.mathWithTransform,\n    matrix = _ref.matrix,\n    AccessorNode = _ref.AccessorNode,\n    ArrayNode = _ref.ArrayNode,\n    ConstantNode = _ref.ConstantNode,\n    FunctionNode = _ref.FunctionNode,\n    IndexNode = _ref.IndexNode,\n    ObjectNode = _ref.ObjectNode,\n    OperatorNode = _ref.OperatorNode,\n    ParenthesisNode = _ref.ParenthesisNode,\n    SymbolNode = _ref.SymbolNode;\n  var _createUtil = (0, _util.createUtil)({\n      FunctionNode: FunctionNode,\n      OperatorNode: OperatorNode,\n      SymbolNode: SymbolNode\n    }),\n    hasProperty = _createUtil.hasProperty,\n    isCommutative = _createUtil.isCommutative,\n    isAssociative = _createUtil.isAssociative,\n    mergeContext = _createUtil.mergeContext,\n    flatten = _createUtil.flatten,\n    unflattenr = _createUtil.unflattenr,\n    unflattenl = _createUtil.unflattenl,\n    createMakeNodeFunction = _createUtil.createMakeNodeFunction,\n    defaultContext = _createUtil.defaultContext,\n    realContext = _createUtil.realContext,\n    positiveContext = _createUtil.positiveContext;\n\n  /**\n   * Simplify an expression tree.\n   *\n   * A list of rules are applied to an expression, repeating over the list until\n   * no further changes are made.\n   * It's possible to pass a custom set of rules to the function as second\n   * argument. A rule can be specified as an object, string, or function:\n   *\n   *     const rules = [\n   *       { l: 'n1*n3 + n2*n3', r: '(n1+n2)*n3' },\n   *       'n1*n3 + n2*n3 -> (n1+n2)*n3',\n   *       function (node) {\n   *         // ... return a new node or return the node unchanged\n   *         return node\n   *       }\n   *     ]\n   *\n   * String and object rules consist of a left and right pattern. The left is\n   * used to match against the expression and the right determines what matches\n   * are replaced with. The main difference between a pattern and a normal\n   * expression is that variables starting with the following characters are\n   * interpreted as wildcards:\n   *\n   * - 'n' - matches any Node\n   * - 'c' - matches any ConstantNode\n   * - 'v' - matches any Node that is not a ConstantNode\n   *\n   * The default list of rules is exposed on the function as `simplify.rules`\n   * and can be used as a basis to built a set of custom rules. Note that since\n   * the `simplifyCore` function is in the default list of rules, by default\n   * simplify will convert any function calls in the expression that have\n   * operator equivalents to their operator forms.\n   *\n   * To specify a rule as a string, separate the left and right pattern by '->'\n   * When specifying a rule as an object, the following keys are meaningful:\n   * - l - the left pattern\n   * - r - the right pattern\n   * - s - in lieu of l and r, the string form that is broken at -> to give them\n   * - repeat - whether to repeat this rule until the expression stabilizes\n   * - assuming - gives a context object, as in the 'context' option to\n   *     simplify. Every property in the context object must match the current\n   *     context in order, or else the rule will not be applied.\n   * - imposeContext - gives a context object, as in the 'context' option to\n   *     simplify. Any settings specified will override the incoming context\n   *     for all matches of this rule.\n   *\n   * For more details on the theory, see:\n   *\n   * - [Strategies for simplifying math expressions (Stackoverflow)](https://stackoverflow.com/questions/7540227/strategies-for-simplifying-math-expressions)\n   * - [Symbolic computation - Simplification (Wikipedia)](https://en.wikipedia.org/wiki/Symbolic_computation#Simplification)\n   *\n   *  An optional `options` argument can be passed as last argument of `simplify`.\n   *  Currently available options (defaults in parentheses):\n   *  - `consoleDebug` (false): whether to write the expression being simplified\n   *    and any changes to it, along with the rule responsible, to console\n   *  - `context` (simplify.defaultContext): an object giving properties of\n   *    each operator, which determine what simplifications are allowed. The\n   *    currently meaningful properties are commutative, associative,\n   *    total (whether the operation is defined for all arguments), and\n   *    trivial (whether the operation applied to a single argument leaves\n   *    that argument unchanged). The default context is very permissive and\n   *    allows almost all simplifications. Only properties differing from\n   *    the default need to be specified; the default context is used as a\n   *    fallback. Additional contexts `simplify.realContext` and\n   *    `simplify.positiveContext` are supplied to cause simplify to perform\n   *    just simplifications guaranteed to preserve all values of the expression\n   *    assuming all variables and subexpressions are real numbers or\n   *    positive real numbers, respectively. (Note that these are in some cases\n   *    more restrictive than the default context; for example, the default\n   *    context will allow `x/x` to simplify to 1, whereas\n   *    `simplify.realContext` will not, as `0/0` is not equal to 1.)\n   *  - `exactFractions` (true): whether to try to convert all constants to\n   *    exact rational numbers.\n   *  - `fractionsLimit` (10000): when `exactFractions` is true, constants will\n   *    be expressed as fractions only when both numerator and denominator\n   *    are smaller than `fractionsLimit`.\n   *\n   * Syntax:\n   *\n   *     simplify(expr)\n   *     simplify(expr, rules)\n   *     simplify(expr, rules)\n   *     simplify(expr, rules, scope)\n   *     simplify(expr, rules, scope, options)\n   *     simplify(expr, scope)\n   *     simplify(expr, scope, options)\n   *\n   * Examples:\n   *\n   *     math.simplify('2 * 1 * x ^ (2 - 1)')      // Node \"2 * x\"\n   *     math.simplify('2 * 3 * x', {x: 4})        // Node \"24\"\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\n   *     math.simplify(f)                          // Node \"2 * x\"\n   *     math.simplify('0.4 * x', {}, {exactFractions: true})  // Node \"x * 2 / 5\"\n   *     math.simplify('0.4 * x', {}, {exactFractions: false}) // Node \"0.4 * x\"\n   *\n   * See also:\n   *\n   *     simplifyCore, derivative, evaluate, parse, rationalize, resolve\n   *\n   * @param {Node | string} expr\n   *            The expression to be simplified\n   * @param {SimplifyRule[]} [rules]\n   *            Optional list with custom rules\n   * @param {Object} [scope] Optional scope with variables\n   * @param {SimplifyOptions} [options] Optional configuration settings\n   * @return {Node} Returns the simplified form of `expr`\n   */\n  typed.addConversion({\n    from: 'Object',\n    to: 'Map',\n    convert: _map.createMap\n  });\n  var simplify = typed('simplify', {\n    Node: _simplify,\n    'Node, Map': function NodeMap(expr, scope) {\n      return _simplify(expr, false, scope);\n    },\n    'Node, Map, Object': function NodeMapObject(expr, scope, options) {\n      return _simplify(expr, false, scope, options);\n    },\n    'Node, Array': _simplify,\n    'Node, Array, Map': _simplify,\n    'Node, Array, Map, Object': _simplify\n  });\n  typed.removeConversion({\n    from: 'Object',\n    to: 'Map',\n    convert: _map.createMap\n  });\n  simplify.defaultContext = defaultContext;\n  simplify.realContext = realContext;\n  simplify.positiveContext = positiveContext;\n  function removeParens(node) {\n    return node.transform(function (node, path, parent) {\n      return (0, _is.isParenthesisNode)(node) ? removeParens(node.content) : node;\n    });\n  }\n\n  // All constants that are allowed in rules\n  var SUPPORTED_CONSTANTS = {\n    \"true\": true,\n    \"false\": true,\n    e: true,\n    i: true,\n    Infinity: true,\n    LN2: true,\n    LN10: true,\n    LOG2E: true,\n    LOG10E: true,\n    NaN: true,\n    phi: true,\n    pi: true,\n    SQRT1_2: true,\n    SQRT2: true,\n    tau: true\n    // null: false,\n    // undefined: false,\n    // version: false,\n  };\n\n  // Array of strings, used to build the ruleSet.\n  // Each l (left side) and r (right side) are parsed by\n  // the expression parser into a node tree.\n  // Left hand sides are matched to subtrees within the\n  // expression to be parsed and replaced with the right\n  // hand side.\n  // TODO: Add support for constraints on constants (either in the form of a '=' expression or a callback [callback allows things like comparing symbols alphabetically])\n  // To evaluate lhs constants for rhs constants, use: { l: 'c1+c2', r: 'c3', evaluate: 'c3 = c1 + c2' }. Multiple assignments are separated by ';' in block format.\n  // It is possible to get into an infinite loop with conflicting rules\n  simplify.rules = [simplifyCore,\n  // { l: 'n+0', r: 'n' },     // simplifyCore\n  // { l: 'n^0', r: '1' },     // simplifyCore\n  // { l: '0*n', r: '0' },     // simplifyCore\n  // { l: 'n/n', r: '1'},      // simplifyCore\n  // { l: 'n^1', r: 'n' },     // simplifyCore\n  // { l: '+n1', r:'n1' },     // simplifyCore\n  // { l: 'n--n1', r:'n+n1' }, // simplifyCore\n  {\n    l: 'log(e)',\n    r: '1'\n  },\n  // temporary rules\n  // Note initially we tend constants to the right because like-term\n  // collection prefers the left, and we would rather collect nonconstants\n  {\n    s: 'n-n1 -> n+-n1',\n    // temporarily replace 'subtract' so we can further flatten the 'add' operator\n    assuming: {\n      subtract: {\n        total: true\n      }\n    }\n  }, {\n    s: 'n-n -> 0',\n    // partial alternative when we can't always subtract\n    assuming: {\n      subtract: {\n        total: false\n      }\n    }\n  }, {\n    s: '-(c*v) -> v * (-c)',\n    // make non-constant terms positive\n    assuming: {\n      multiply: {\n        commutative: true\n      },\n      subtract: {\n        total: true\n      }\n    }\n  }, {\n    s: '-(c*v) -> (-c) * v',\n    // non-commutative version, part 1\n    assuming: {\n      multiply: {\n        commutative: false\n      },\n      subtract: {\n        total: true\n      }\n    }\n  }, {\n    s: '-(v*c) -> v * (-c)',\n    // non-commutative version, part 2\n    assuming: {\n      multiply: {\n        commutative: false\n      },\n      subtract: {\n        total: true\n      }\n    }\n  }, {\n    l: '-(n1/n2)',\n    r: '-n1/n2'\n  }, {\n    l: '-v',\n    r: 'v * (-1)'\n  },\n  // finish making non-constant terms positive\n  {\n    l: '(n1 + n2)*(-1)',\n    r: 'n1*(-1) + n2*(-1)',\n    repeat: true\n  },\n  // expand negations to achieve as much sign cancellation as possible\n  {\n    l: 'n/n1^n2',\n    r: 'n*n1^-n2'\n  },\n  // temporarily replace 'divide' so we can further flatten the 'multiply' operator\n  {\n    l: 'n/n1',\n    r: 'n*n1^-1'\n  }, {\n    s: '(n1*n2)^n3 -> n1^n3 * n2^n3',\n    assuming: {\n      multiply: {\n        commutative: true\n      }\n    }\n  }, {\n    s: '(n1*n2)^(-1) -> n2^(-1) * n1^(-1)',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  },\n  // expand nested exponentiation\n  {\n    s: '(n ^ n1) ^ n2 -> n ^ (n1 * n2)',\n    assuming: {\n      divide: {\n        total: true\n      }\n    } // 1/(1/n) = n needs 1/n to exist\n  },\n  // collect like factors; into a sum, only do this for nonconstants\n  {\n    l: ' v   * ( v   * n1 + n2)',\n    r: 'v^2       * n1 +  v   * n2'\n  }, {\n    s: ' v   * (v^n4 * n1 + n2)   ->  v^(1+n4)  * n1 +  v   * n2',\n    assuming: {\n      divide: {\n        total: true\n      }\n    } // v*1/v = v^(1+-1) needs 1/v\n  }, {\n    s: 'v^n3 * ( v   * n1 + n2)   ->  v^(n3+1)  * n1 + v^n3 * n2',\n    assuming: {\n      divide: {\n        total: true\n      }\n    }\n  }, {\n    s: 'v^n3 * (v^n4 * n1 + n2)   ->  v^(n3+n4) * n1 + v^n3 * n2',\n    assuming: {\n      divide: {\n        total: true\n      }\n    }\n  }, {\n    l: 'n*n',\n    r: 'n^2'\n  }, {\n    s: 'n * n^n1 -> n^(n1+1)',\n    assuming: {\n      divide: {\n        total: true\n      }\n    } // n*1/n = n^(-1+1) needs 1/n\n  }, {\n    s: 'n^n1 * n^n2 -> n^(n1+n2)',\n    assuming: {\n      divide: {\n        total: true\n      }\n    } // ditto for n^2*1/n^2\n  },\n  // Unfortunately, to deal with more complicated cancellations, it\n  // becomes necessary to simplify constants twice per pass. It's not\n  // terribly expensive compared to matching rules, so this should not\n  // pose a performance problem.\n  simplifyConstant,\n  // First: before collecting like terms\n\n  // collect like terms\n  {\n    s: 'n+n -> 2*n',\n    assuming: {\n      add: {\n        total: true\n      }\n    } // 2 = 1 + 1 needs to exist\n  }, {\n    l: 'n+-n',\n    r: '0'\n  }, {\n    l: 'v*n + v',\n    r: 'v*(n+1)'\n  },\n  // NOTE: leftmost position is special:\n  {\n    l: 'n3*n1 + n3*n2',\n    r: 'n3*(n1+n2)'\n  },\n  // All sub-monomials tried there.\n  {\n    l: 'n3^(-n4)*n1 +   n3  * n2',\n    r: 'n3^(-n4)*(n1 + n3^(n4+1) *n2)'\n  }, {\n    l: 'n3^(-n4)*n1 + n3^n5 * n2',\n    r: 'n3^(-n4)*(n1 + n3^(n4+n5)*n2)'\n  }, {\n    s: 'n*v + v -> (n+1)*v',\n    // noncommutative additional cases\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, {\n    s: 'n1*n3 + n2*n3 -> (n1+n2)*n3',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, {\n    s: 'n1*n3^(-n4) + n2 * n3    -> (n1 + n2*n3^(n4 +  1))*n3^(-n4)',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, {\n    s: 'n1*n3^(-n4) + n2 * n3^n5 -> (n1 + n2*n3^(n4 + n5))*n3^(-n4)',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, {\n    l: 'n*c + c',\n    r: '(n+1)*c'\n  }, {\n    s: 'c*n + c -> c*(n+1)',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, simplifyConstant,\n  // Second: before returning expressions to \"standard form\"\n\n  // make factors positive (and undo 'make non-constant terms positive')\n  {\n    s: '(-n)*n1 -> -(n*n1)',\n    assuming: {\n      subtract: {\n        total: true\n      }\n    }\n  }, {\n    s: 'n1*(-n) -> -(n1*n)',\n    // in case * non-commutative\n    assuming: {\n      subtract: {\n        total: true\n      },\n      multiply: {\n        commutative: false\n      }\n    }\n  },\n  // final ordering of constants\n  {\n    s: 'c+v -> v+c',\n    assuming: {\n      add: {\n        commutative: true\n      }\n    },\n    imposeContext: {\n      add: {\n        commutative: false\n      }\n    }\n  }, {\n    s: 'v*c -> c*v',\n    assuming: {\n      multiply: {\n        commutative: true\n      }\n    },\n    imposeContext: {\n      multiply: {\n        commutative: false\n      }\n    }\n  },\n  // undo temporary rules\n  // { l: '(-1) * n', r: '-n' }, // #811 added test which proved this is redundant\n  {\n    l: 'n+-n1',\n    r: 'n-n1'\n  },\n  // undo replace 'subtract'\n  {\n    s: 'n*(n1^-1) -> n/n1',\n    // undo replace 'divide'; for * commutative\n    assuming: {\n      multiply: {\n        commutative: true\n      }\n    } // o.w. / not conventional\n  }, {\n    s: 'n*n1^-n2 -> n/n1^n2',\n    assuming: {\n      multiply: {\n        commutative: true\n      }\n    } // o.w. / not conventional\n  }, {\n    s: 'n^-1 -> 1/n',\n    assuming: {\n      multiply: {\n        commutative: true\n      }\n    } // o.w. / not conventional\n  }, {\n    l: 'n^1',\n    r: 'n'\n  },\n  // can be produced by power cancellation\n  {\n    s: 'n*(n1/n2) -> (n*n1)/n2',\n    // '*' before '/'\n    assuming: {\n      multiply: {\n        associative: true\n      }\n    }\n  }, {\n    s: 'n-(n1+n2) -> n-n1-n2',\n    // '-' before '+'\n    assuming: {\n      addition: {\n        associative: true,\n        commutative: true\n      }\n    }\n  },\n  // { l: '(n1/n2)/n3', r: 'n1/(n2*n3)' },\n  // { l: '(n*n1)/(n*n2)', r: 'n1/n2' },\n\n  // simplifyConstant can leave an extra factor of 1, which can always\n  // be eliminated, since the identity always commutes\n  {\n    l: '1*n',\n    r: 'n',\n    imposeContext: {\n      multiply: {\n        commutative: true\n      }\n    }\n  }, {\n    s: 'n1/(n2/n3) -> (n1*n3)/n2',\n    assuming: {\n      multiply: {\n        associative: true\n      }\n    }\n  }, {\n    l: 'n1/(-n2)',\n    r: '-n1/n2'\n  }];\n\n  /**\n   * Takes any rule object as allowed by the specification in simplify\n   * and puts it in a standard form used by applyRule\n   */\n  function _canonicalizeRule(ruleObject, context) {\n    var newRule = {};\n    if (ruleObject.s) {\n      var lr = ruleObject.s.split('->');\n      if (lr.length === 2) {\n        newRule.l = lr[0];\n        newRule.r = lr[1];\n      } else {\n        throw SyntaxError('Could not parse rule: ' + ruleObject.s);\n      }\n    } else {\n      newRule.l = ruleObject.l;\n      newRule.r = ruleObject.r;\n    }\n    newRule.l = removeParens(parse(newRule.l));\n    newRule.r = removeParens(parse(newRule.r));\n    for (var _i = 0, _arr = ['imposeContext', 'repeat', 'assuming']; _i < _arr.length; _i++) {\n      var prop = _arr[_i];\n      if (prop in ruleObject) {\n        newRule[prop] = ruleObject[prop];\n      }\n    }\n    if (ruleObject.evaluate) {\n      newRule.evaluate = parse(ruleObject.evaluate);\n    }\n    if (isAssociative(newRule.l, context)) {\n      var makeNode = createMakeNodeFunction(newRule.l);\n      var expandsym = _getExpandPlaceholderSymbol();\n      newRule.expanded = {};\n      newRule.expanded.l = makeNode([newRule.l.clone(), expandsym]);\n      // Push the expandsym into the deepest possible branch.\n      // This helps to match the newRule against nodes returned from getSplits() later on.\n      flatten(newRule.expanded.l, context);\n      unflattenr(newRule.expanded.l, context);\n      newRule.expanded.r = makeNode([newRule.r, expandsym]);\n    }\n    return newRule;\n  }\n\n  /**\n   * Parse the string array of rules into nodes\n   *\n   * Example syntax for rules:\n   *\n   * Position constants to the left in a product:\n   * { l: 'n1 * c1', r: 'c1 * n1' }\n   * n1 is any Node, and c1 is a ConstantNode.\n   *\n   * Apply difference of squares formula:\n   * { l: '(n1 - n2) * (n1 + n2)', r: 'n1^2 - n2^2' }\n   * n1, n2 mean any Node.\n   *\n   * Short hand notation:\n   * 'n1 * c1 -> c1 * n1'\n   */\n  function _buildRules(rules, context) {\n    // Array of rules to be used to simplify expressions\n    var ruleSet = [];\n    for (var i = 0; i < rules.length; i++) {\n      var rule = rules[i];\n      var newRule = void 0;\n      var ruleType = (0, _typeof2[\"default\"])(rule);\n      switch (ruleType) {\n        case 'string':\n          rule = {\n            s: rule\n          };\n        /* falls through */\n        case 'object':\n          newRule = _canonicalizeRule(rule, context);\n          break;\n        case 'function':\n          newRule = rule;\n          break;\n        default:\n          throw TypeError('Unsupported type of rule: ' + ruleType);\n      }\n      // console.log('Adding rule: ' + rules[i])\n      // console.log(newRule)\n      ruleSet.push(newRule);\n    }\n    return ruleSet;\n  }\n  var _lastsym = 0;\n  function _getExpandPlaceholderSymbol() {\n    return new SymbolNode('_p' + _lastsym++);\n  }\n  function _simplify(expr, rules) {\n    var scope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (0, _map.createEmptyMap)();\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var debug = options.consoleDebug;\n    rules = _buildRules(rules || simplify.rules, options.context);\n    var res = resolve(expr, scope);\n    res = removeParens(res);\n    var visited = {};\n    var str = res.toString({\n      parenthesis: 'all'\n    });\n    while (!visited[str]) {\n      visited[str] = true;\n      _lastsym = 0; // counter for placeholder symbols\n      var laststr = str;\n      if (debug) console.log('Working on: ', str);\n      for (var i = 0; i < rules.length; i++) {\n        var rulestr = '';\n        if (typeof rules[i] === 'function') {\n          res = rules[i](res, options);\n          if (debug) rulestr = rules[i].name;\n        } else {\n          flatten(res, options.context);\n          res = applyRule(res, rules[i], options.context);\n          if (debug) {\n            rulestr = \"\".concat(rules[i].l.toString(), \" -> \").concat(rules[i].r.toString());\n          }\n        }\n        if (debug) {\n          var newstr = res.toString({\n            parenthesis: 'all'\n          });\n          if (newstr !== laststr) {\n            console.log('Applying', rulestr, 'produced', newstr);\n            laststr = newstr;\n          }\n        }\n        /* Use left-heavy binary tree internally,\n         * since custom rule functions may expect it\n         */\n        unflattenl(res, options.context);\n      }\n      str = res.toString({\n        parenthesis: 'all'\n      });\n    }\n    return res;\n  }\n  function mapRule(nodes, rule, context) {\n    var resNodes = nodes;\n    if (nodes) {\n      for (var i = 0; i < nodes.length; ++i) {\n        var newNode = applyRule(nodes[i], rule, context);\n        if (newNode !== nodes[i]) {\n          if (resNodes === nodes) {\n            resNodes = nodes.slice();\n          }\n          resNodes[i] = newNode;\n        }\n      }\n    }\n    return resNodes;\n  }\n\n  /**\n   * Returns a simplfied form of node, or the original node if no simplification was possible.\n   *\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @param  {Object | Function} rule\n   * @param  {Object} context -- information about assumed properties of operators\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} The simplified form of `expr`, or the original node if no simplification was possible.\n   */\n  function applyRule(node, rule, context) {\n    //    console.log('Entering applyRule(\"', rule.l.toString({parenthesis:'all'}), '->', rule.r.toString({parenthesis:'all'}), '\",', node.toString({parenthesis:'all'}),')')\n\n    // check that the assumptions for this rule are satisfied by the current\n    // context:\n    if (rule.assuming) {\n      for (var symbol in rule.assuming) {\n        for (var property in rule.assuming[symbol]) {\n          if (hasProperty(symbol, property, context) !== rule.assuming[symbol][property]) {\n            return node;\n          }\n        }\n      }\n    }\n    var mergedContext = mergeContext(rule.imposeContext, context);\n\n    // Do not clone node unless we find a match\n    var res = node;\n\n    // First replace our child nodes with their simplified versions\n    // If a child could not be simplified, applying the rule to it\n    // will have no effect since the node is returned unchanged\n    if (res instanceof OperatorNode || res instanceof FunctionNode) {\n      var newArgs = mapRule(res.args, rule, context);\n      if (newArgs !== res.args) {\n        res = res.clone();\n        res.args = newArgs;\n      }\n    } else if (res instanceof ParenthesisNode) {\n      if (res.content) {\n        var newContent = applyRule(res.content, rule, context);\n        if (newContent !== res.content) {\n          res = new ParenthesisNode(newContent);\n        }\n      }\n    } else if (res instanceof ArrayNode) {\n      var newItems = mapRule(res.items, rule, context);\n      if (newItems !== res.items) {\n        res = new ArrayNode(newItems);\n      }\n    } else if (res instanceof AccessorNode) {\n      var newObj = res.object;\n      if (res.object) {\n        newObj = applyRule(res.object, rule, context);\n      }\n      var newIndex = res.index;\n      if (res.index) {\n        newIndex = applyRule(res.index, rule, context);\n      }\n      if (newObj !== res.object || newIndex !== res.index) {\n        res = new AccessorNode(newObj, newIndex);\n      }\n    } else if (res instanceof IndexNode) {\n      var newDims = mapRule(res.dimensions, rule, context);\n      if (newDims !== res.dimensions) {\n        res = new IndexNode(newDims);\n      }\n    } else if (res instanceof ObjectNode) {\n      var changed = false;\n      var newProps = {};\n      for (var prop in res.properties) {\n        newProps[prop] = applyRule(res.properties[prop], rule, context);\n        if (newProps[prop] !== res.properties[prop]) {\n          changed = true;\n        }\n      }\n      if (changed) {\n        res = new ObjectNode(newProps);\n      }\n    }\n\n    // Try to match a rule against this node\n    var repl = rule.r;\n    var matches = _ruleMatch(rule.l, res, mergedContext)[0];\n\n    // If the rule is associative operator, we can try matching it while allowing additional terms.\n    // This allows us to match rules like 'n+n' to the expression '(1+x)+x' or even 'x+1+x' if the operator is commutative.\n    if (!matches && rule.expanded) {\n      repl = rule.expanded.r;\n      matches = _ruleMatch(rule.expanded.l, res, mergedContext)[0];\n    }\n    if (matches) {\n      // const before = res.toString({parenthesis: 'all'})\n\n      // Create a new node by cloning the rhs of the matched rule\n      // we keep any implicit multiplication state if relevant\n      var implicit = res.implicit;\n      res = repl.clone();\n      if (implicit && 'implicit' in repl) {\n        res.implicit = true;\n      }\n\n      // Replace placeholders with their respective nodes without traversing deeper into the replaced nodes\n      res = res.transform(function (node) {\n        if (node.isSymbolNode && (0, _object.hasOwnProperty)(matches.placeholders, node.name)) {\n          return matches.placeholders[node.name].clone();\n        } else {\n          return node;\n        }\n      });\n\n      // const after = res.toString({parenthesis: 'all'})\n      // console.log('Simplified ' + before + ' to ' + after)\n    }\n\n    if (rule.repeat && res !== node) {\n      res = applyRule(res, rule, context);\n    }\n    return res;\n  }\n\n  /**\n   * Get (binary) combinations of a flattened binary node\n   * e.g. +(node1, node2, node3) -> [\n   *        +(node1,  +(node2, node3)),\n   *        +(node2,  +(node1, node3)),\n   *        +(node3,  +(node1, node2))]\n   *\n   */\n  function getSplits(node, context) {\n    var res = [];\n    var right, rightArgs;\n    var makeNode = createMakeNodeFunction(node);\n    if (isCommutative(node, context)) {\n      for (var i = 0; i < node.args.length; i++) {\n        rightArgs = node.args.slice(0);\n        rightArgs.splice(i, 1);\n        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\n        res.push(makeNode([node.args[i], right]));\n      }\n    } else {\n      // Keep order, but try all parenthesizations\n      for (var _i2 = 1; _i2 < node.args.length; _i2++) {\n        var left = node.args[0];\n        if (_i2 > 1) {\n          left = makeNode(node.args.slice(0, _i2));\n        }\n        rightArgs = node.args.slice(_i2);\n        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\n        res.push(makeNode([left, right]));\n      }\n    }\n    return res;\n  }\n\n  /**\n   * Returns the set union of two match-placeholders or null if there is a conflict.\n   */\n  function mergeMatch(match1, match2) {\n    var res = {\n      placeholders: {}\n    };\n\n    // Some matches may not have placeholders; this is OK\n    if (!match1.placeholders && !match2.placeholders) {\n      return res;\n    } else if (!match1.placeholders) {\n      return match2;\n    } else if (!match2.placeholders) {\n      return match1;\n    }\n\n    // Placeholders with the same key must match exactly\n    for (var key in match1.placeholders) {\n      if ((0, _object.hasOwnProperty)(match1.placeholders, key)) {\n        res.placeholders[key] = match1.placeholders[key];\n        if ((0, _object.hasOwnProperty)(match2.placeholders, key)) {\n          if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {\n            return null;\n          }\n        }\n      }\n    }\n    for (var _key in match2.placeholders) {\n      if ((0, _object.hasOwnProperty)(match2.placeholders, _key)) {\n        res.placeholders[_key] = match2.placeholders[_key];\n      }\n    }\n    return res;\n  }\n\n  /**\n   * Combine two lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\n   * Each list represents matches found in one child of a node.\n   */\n  function combineChildMatches(list1, list2) {\n    var res = [];\n    if (list1.length === 0 || list2.length === 0) {\n      return res;\n    }\n    var merged;\n    for (var i1 = 0; i1 < list1.length; i1++) {\n      for (var i2 = 0; i2 < list2.length; i2++) {\n        merged = mergeMatch(list1[i1], list2[i2]);\n        if (merged) {\n          res.push(merged);\n        }\n      }\n    }\n    return res;\n  }\n\n  /**\n   * Combine multiple lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\n   * Each list represents matches found in one child of a node.\n   * Returns a list of unique matches.\n   */\n  function mergeChildMatches(childMatches) {\n    if (childMatches.length === 0) {\n      return childMatches;\n    }\n    var sets = childMatches.reduce(combineChildMatches);\n    var uniqueSets = [];\n    var unique = {};\n    for (var i = 0; i < sets.length; i++) {\n      var s = JSON.stringify(sets[i]);\n      if (!unique[s]) {\n        unique[s] = true;\n        uniqueSets.push(sets[i]);\n      }\n    }\n    return uniqueSets;\n  }\n\n  /**\n   * Determines whether node matches rule.\n   *\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} rule\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @param {Object} context -- provides assumed properties of operators\n   * @param {Boolean} isSplit -- whether we are in process of splitting an\n   *                    n-ary operator node into possible binary combinations.\n   *                    Defaults to false.\n   * @return {Object} Information about the match, if it exists.\n   */\n  function _ruleMatch(rule, node, context, isSplit) {\n    //    console.log('Entering _ruleMatch(' + JSON.stringify(rule) + ', ' + JSON.stringify(node) + ')')\n    //    console.log('rule = ' + rule)\n    //    console.log('node = ' + node)\n\n    //    console.log('Entering _ruleMatch(', rule.toString({parenthesis:'all'}), ', ', node.toString({parenthesis:'all'}), ', ', context, ')')\n    var res = [{\n      placeholders: {}\n    }];\n    if (rule instanceof OperatorNode && node instanceof OperatorNode || rule instanceof FunctionNode && node instanceof FunctionNode) {\n      // If the rule is an OperatorNode or a FunctionNode, then node must match exactly\n      if (rule instanceof OperatorNode) {\n        if (rule.op !== node.op || rule.fn !== node.fn) {\n          return [];\n        }\n      } else if (rule instanceof FunctionNode) {\n        if (rule.name !== node.name) {\n          return [];\n        }\n      }\n\n      // rule and node match. Search the children of rule and node.\n      if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node, context) && node.args.length === rule.args.length || isSplit) {\n        // Expect non-associative operators to match exactly,\n        // except in any order if operator is commutative\n        var childMatches = [];\n        for (var i = 0; i < rule.args.length; i++) {\n          var childMatch = _ruleMatch(rule.args[i], node.args[i], context);\n          if (childMatch.length === 0) {\n            // Child did not match, so stop searching immediately\n            break;\n          }\n          // The child matched, so add the information returned from the child to our result\n          childMatches.push(childMatch);\n        }\n        if (childMatches.length !== rule.args.length) {\n          if (!isCommutative(node, context) ||\n          // exact match in order needed\n          rule.args.length === 1) {\n            // nothing to commute\n            return [];\n          }\n          if (rule.args.length > 2) {\n            /* Need to generate all permutations and try them.\n             * It's a bit complicated, and unlikely to come up since there\n             * are very few ternary or higher operators. So punt for now.\n             */\n            throw new Error('permuting >2 commutative non-associative rule arguments not yet implemented');\n          }\n          /* Exactly two arguments, try them reversed */\n          var leftMatch = _ruleMatch(rule.args[0], node.args[1], context);\n          if (leftMatch.length === 0) {\n            return [];\n          }\n          var rightMatch = _ruleMatch(rule.args[1], node.args[0], context);\n          if (rightMatch.length === 0) {\n            return [];\n          }\n          childMatches = [leftMatch, rightMatch];\n        }\n        res = mergeChildMatches(childMatches);\n      } else if (node.args.length >= 2 && rule.args.length === 2) {\n        // node is flattened, rule is not\n        // Associative operators/functions can be split in different ways so we check if the rule matches each\n        // them and return their union.\n        var splits = getSplits(node, context);\n        var splitMatches = [];\n        for (var _i3 = 0; _i3 < splits.length; _i3++) {\n          var matchSet = _ruleMatch(rule, splits[_i3], context, true); // recursing at the same tree depth here\n          splitMatches = splitMatches.concat(matchSet);\n        }\n        return splitMatches;\n      } else if (rule.args.length > 2) {\n        throw Error('Unexpected non-binary associative function: ' + rule.toString());\n      } else {\n        // Incorrect number of arguments in rule and node, so no match\n        return [];\n      }\n    } else if (rule instanceof SymbolNode) {\n      // If the rule is a SymbolNode, then it carries a special meaning\n      // according to the first character of the symbol node name.\n      // c.* matches a ConstantNode\n      // n.* matches any node\n      if (rule.name.length === 0) {\n        throw new Error('Symbol in rule has 0 length...!?');\n      }\n      if (SUPPORTED_CONSTANTS[rule.name]) {\n        // built-in constant must match exactly\n        if (rule.name !== node.name) {\n          return [];\n        }\n      } else if (rule.name[0] === 'n' || rule.name.substring(0, 2) === '_p') {\n        // rule matches _anything_, so assign this node to the rule.name placeholder\n        // Assign node to the rule.name placeholder.\n        // Our parent will check for matches among placeholders.\n        res[0].placeholders[rule.name] = node;\n      } else if (rule.name[0] === 'v') {\n        // rule matches any variable thing (not a ConstantNode)\n        if (!(0, _is.isConstantNode)(node)) {\n          res[0].placeholders[rule.name] = node;\n        } else {\n          // Mis-match: rule was expecting something other than a ConstantNode\n          return [];\n        }\n      } else if (rule.name[0] === 'c') {\n        // rule matches any ConstantNode\n        if (node instanceof ConstantNode) {\n          res[0].placeholders[rule.name] = node;\n        } else {\n          // Mis-match: rule was expecting a ConstantNode\n          return [];\n        }\n      } else {\n        throw new Error('Invalid symbol in rule: ' + rule.name);\n      }\n    } else if (rule instanceof ConstantNode) {\n      // Literal constant must match exactly\n      if (!equal(rule.value, node.value)) {\n        return [];\n      }\n    } else {\n      // Some other node was encountered which we aren't prepared for, so no match\n      return [];\n    }\n\n    // It's a match!\n\n    // console.log('_ruleMatch(' + rule.toString() + ', ' + node.toString() + ') found a match')\n    return res;\n  }\n\n  /**\n   * Determines whether p and q (and all their children nodes) are identical.\n   *\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} p\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} q\n   * @return {Object} Information about the match, if it exists.\n   */\n  function _exactMatch(p, q) {\n    if (p instanceof ConstantNode && q instanceof ConstantNode) {\n      if (!equal(p.value, q.value)) {\n        return false;\n      }\n    } else if (p instanceof SymbolNode && q instanceof SymbolNode) {\n      if (p.name !== q.name) {\n        return false;\n      }\n    } else if (p instanceof OperatorNode && q instanceof OperatorNode || p instanceof FunctionNode && q instanceof FunctionNode) {\n      if (p instanceof OperatorNode) {\n        if (p.op !== q.op || p.fn !== q.fn) {\n          return false;\n        }\n      } else if (p instanceof FunctionNode) {\n        if (p.name !== q.name) {\n          return false;\n        }\n      }\n      if (p.args.length !== q.args.length) {\n        return false;\n      }\n      for (var i = 0; i < p.args.length; i++) {\n        if (!_exactMatch(p.args[i], q.args[i])) {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n    return true;\n  }\n  return simplify;\n});\nexports.createSimplify = createSimplify;","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","createSimplify","_typeof2","_is","_factory","_util","_object","_map","name","dependencies","factory","_ref","config","typed","parse","add","subtract","multiply","divide","pow","isZero","equal","resolve","simplifyConstant","simplifyCore","fraction","bignumber","mathWithTransform","matrix","AccessorNode","ArrayNode","ConstantNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","ParenthesisNode","SymbolNode","_createUtil","createUtil","hasProperty","isCommutative","isAssociative","mergeContext","flatten","unflattenr","unflattenl","createMakeNodeFunction","defaultContext","realContext","positiveContext","addConversion","from","to","convert","createMap","simplify","Node","_simplify","NodeMap","expr","scope","NodeMapObject","options","removeConversion","removeParens","node","transform","path","parent","isParenthesisNode","content","SUPPORTED_CONSTANTS","e","i","Infinity","LN2","LN10","LOG2E","LOG10E","NaN","phi","pi","SQRT1_2","SQRT2","tau","rules","l","r","s","assuming","total","commutative","repeat","imposeContext","associative","addition","_canonicalizeRule","ruleObject","context","newRule","lr","split","length","SyntaxError","_i","_arr","prop","evaluate","makeNode","expandsym","_getExpandPlaceholderSymbol","expanded","clone","_buildRules","ruleSet","rule","ruleType","TypeError","push","_lastsym","arguments","undefined","createEmptyMap","debug","consoleDebug","res","visited","str","toString","parenthesis","laststr","console","log","rulestr","applyRule","concat","newstr","mapRule","nodes","resNodes","newNode","slice","symbol","property","mergedContext","newArgs","args","newContent","newItems","items","newObj","object","newIndex","index","newDims","dimensions","changed","newProps","properties","repl","matches","_ruleMatch","implicit","isSymbolNode","hasOwnProperty","placeholders","getSplits","right","rightArgs","splice","_i2","left","mergeMatch","match1","match2","key","_exactMatch","_key","combineChildMatches","list1","list2","merged","i1","i2","mergeChildMatches","childMatches","sets","reduce","uniqueSets","unique","JSON","stringify","isSplit","op","fn","childMatch","Error","leftMatch","rightMatch","splits","splitMatches","_i3","matchSet","substring","isConstantNode","p","q"],"sources":["C:/Users/Admin/Desktop/React-Web-main/node_modules/mathjs/lib/cjs/function/algebra/simplify.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSimplify = void 0;\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\nvar _is = require(\"../../utils/is.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar _util = require(\"./simplify/util.js\");\nvar _object = require(\"../../utils/object.js\");\nvar _map = require(\"../../utils/map.js\");\nvar name = 'simplify';\nvar dependencies = ['config', 'typed', 'parse', 'add', 'subtract', 'multiply', 'divide', 'pow', 'isZero', 'equal', 'resolve', 'simplifyConstant', 'simplifyCore', '?fraction', '?bignumber', 'mathWithTransform', 'matrix', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\nvar createSimplify = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var config = _ref.config,\n    typed = _ref.typed,\n    parse = _ref.parse,\n    add = _ref.add,\n    subtract = _ref.subtract,\n    multiply = _ref.multiply,\n    divide = _ref.divide,\n    pow = _ref.pow,\n    isZero = _ref.isZero,\n    equal = _ref.equal,\n    resolve = _ref.resolve,\n    simplifyConstant = _ref.simplifyConstant,\n    simplifyCore = _ref.simplifyCore,\n    fraction = _ref.fraction,\n    bignumber = _ref.bignumber,\n    mathWithTransform = _ref.mathWithTransform,\n    matrix = _ref.matrix,\n    AccessorNode = _ref.AccessorNode,\n    ArrayNode = _ref.ArrayNode,\n    ConstantNode = _ref.ConstantNode,\n    FunctionNode = _ref.FunctionNode,\n    IndexNode = _ref.IndexNode,\n    ObjectNode = _ref.ObjectNode,\n    OperatorNode = _ref.OperatorNode,\n    ParenthesisNode = _ref.ParenthesisNode,\n    SymbolNode = _ref.SymbolNode;\n  var _createUtil = (0, _util.createUtil)({\n      FunctionNode: FunctionNode,\n      OperatorNode: OperatorNode,\n      SymbolNode: SymbolNode\n    }),\n    hasProperty = _createUtil.hasProperty,\n    isCommutative = _createUtil.isCommutative,\n    isAssociative = _createUtil.isAssociative,\n    mergeContext = _createUtil.mergeContext,\n    flatten = _createUtil.flatten,\n    unflattenr = _createUtil.unflattenr,\n    unflattenl = _createUtil.unflattenl,\n    createMakeNodeFunction = _createUtil.createMakeNodeFunction,\n    defaultContext = _createUtil.defaultContext,\n    realContext = _createUtil.realContext,\n    positiveContext = _createUtil.positiveContext;\n\n  /**\n   * Simplify an expression tree.\n   *\n   * A list of rules are applied to an expression, repeating over the list until\n   * no further changes are made.\n   * It's possible to pass a custom set of rules to the function as second\n   * argument. A rule can be specified as an object, string, or function:\n   *\n   *     const rules = [\n   *       { l: 'n1*n3 + n2*n3', r: '(n1+n2)*n3' },\n   *       'n1*n3 + n2*n3 -> (n1+n2)*n3',\n   *       function (node) {\n   *         // ... return a new node or return the node unchanged\n   *         return node\n   *       }\n   *     ]\n   *\n   * String and object rules consist of a left and right pattern. The left is\n   * used to match against the expression and the right determines what matches\n   * are replaced with. The main difference between a pattern and a normal\n   * expression is that variables starting with the following characters are\n   * interpreted as wildcards:\n   *\n   * - 'n' - matches any Node\n   * - 'c' - matches any ConstantNode\n   * - 'v' - matches any Node that is not a ConstantNode\n   *\n   * The default list of rules is exposed on the function as `simplify.rules`\n   * and can be used as a basis to built a set of custom rules. Note that since\n   * the `simplifyCore` function is in the default list of rules, by default\n   * simplify will convert any function calls in the expression that have\n   * operator equivalents to their operator forms.\n   *\n   * To specify a rule as a string, separate the left and right pattern by '->'\n   * When specifying a rule as an object, the following keys are meaningful:\n   * - l - the left pattern\n   * - r - the right pattern\n   * - s - in lieu of l and r, the string form that is broken at -> to give them\n   * - repeat - whether to repeat this rule until the expression stabilizes\n   * - assuming - gives a context object, as in the 'context' option to\n   *     simplify. Every property in the context object must match the current\n   *     context in order, or else the rule will not be applied.\n   * - imposeContext - gives a context object, as in the 'context' option to\n   *     simplify. Any settings specified will override the incoming context\n   *     for all matches of this rule.\n   *\n   * For more details on the theory, see:\n   *\n   * - [Strategies for simplifying math expressions (Stackoverflow)](https://stackoverflow.com/questions/7540227/strategies-for-simplifying-math-expressions)\n   * - [Symbolic computation - Simplification (Wikipedia)](https://en.wikipedia.org/wiki/Symbolic_computation#Simplification)\n   *\n   *  An optional `options` argument can be passed as last argument of `simplify`.\n   *  Currently available options (defaults in parentheses):\n   *  - `consoleDebug` (false): whether to write the expression being simplified\n   *    and any changes to it, along with the rule responsible, to console\n   *  - `context` (simplify.defaultContext): an object giving properties of\n   *    each operator, which determine what simplifications are allowed. The\n   *    currently meaningful properties are commutative, associative,\n   *    total (whether the operation is defined for all arguments), and\n   *    trivial (whether the operation applied to a single argument leaves\n   *    that argument unchanged). The default context is very permissive and\n   *    allows almost all simplifications. Only properties differing from\n   *    the default need to be specified; the default context is used as a\n   *    fallback. Additional contexts `simplify.realContext` and\n   *    `simplify.positiveContext` are supplied to cause simplify to perform\n   *    just simplifications guaranteed to preserve all values of the expression\n   *    assuming all variables and subexpressions are real numbers or\n   *    positive real numbers, respectively. (Note that these are in some cases\n   *    more restrictive than the default context; for example, the default\n   *    context will allow `x/x` to simplify to 1, whereas\n   *    `simplify.realContext` will not, as `0/0` is not equal to 1.)\n   *  - `exactFractions` (true): whether to try to convert all constants to\n   *    exact rational numbers.\n   *  - `fractionsLimit` (10000): when `exactFractions` is true, constants will\n   *    be expressed as fractions only when both numerator and denominator\n   *    are smaller than `fractionsLimit`.\n   *\n   * Syntax:\n   *\n   *     simplify(expr)\n   *     simplify(expr, rules)\n   *     simplify(expr, rules)\n   *     simplify(expr, rules, scope)\n   *     simplify(expr, rules, scope, options)\n   *     simplify(expr, scope)\n   *     simplify(expr, scope, options)\n   *\n   * Examples:\n   *\n   *     math.simplify('2 * 1 * x ^ (2 - 1)')      // Node \"2 * x\"\n   *     math.simplify('2 * 3 * x', {x: 4})        // Node \"24\"\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\n   *     math.simplify(f)                          // Node \"2 * x\"\n   *     math.simplify('0.4 * x', {}, {exactFractions: true})  // Node \"x * 2 / 5\"\n   *     math.simplify('0.4 * x', {}, {exactFractions: false}) // Node \"0.4 * x\"\n   *\n   * See also:\n   *\n   *     simplifyCore, derivative, evaluate, parse, rationalize, resolve\n   *\n   * @param {Node | string} expr\n   *            The expression to be simplified\n   * @param {SimplifyRule[]} [rules]\n   *            Optional list with custom rules\n   * @param {Object} [scope] Optional scope with variables\n   * @param {SimplifyOptions} [options] Optional configuration settings\n   * @return {Node} Returns the simplified form of `expr`\n   */\n  typed.addConversion({\n    from: 'Object',\n    to: 'Map',\n    convert: _map.createMap\n  });\n  var simplify = typed('simplify', {\n    Node: _simplify,\n    'Node, Map': function NodeMap(expr, scope) {\n      return _simplify(expr, false, scope);\n    },\n    'Node, Map, Object': function NodeMapObject(expr, scope, options) {\n      return _simplify(expr, false, scope, options);\n    },\n    'Node, Array': _simplify,\n    'Node, Array, Map': _simplify,\n    'Node, Array, Map, Object': _simplify\n  });\n  typed.removeConversion({\n    from: 'Object',\n    to: 'Map',\n    convert: _map.createMap\n  });\n  simplify.defaultContext = defaultContext;\n  simplify.realContext = realContext;\n  simplify.positiveContext = positiveContext;\n  function removeParens(node) {\n    return node.transform(function (node, path, parent) {\n      return (0, _is.isParenthesisNode)(node) ? removeParens(node.content) : node;\n    });\n  }\n\n  // All constants that are allowed in rules\n  var SUPPORTED_CONSTANTS = {\n    \"true\": true,\n    \"false\": true,\n    e: true,\n    i: true,\n    Infinity: true,\n    LN2: true,\n    LN10: true,\n    LOG2E: true,\n    LOG10E: true,\n    NaN: true,\n    phi: true,\n    pi: true,\n    SQRT1_2: true,\n    SQRT2: true,\n    tau: true\n    // null: false,\n    // undefined: false,\n    // version: false,\n  };\n\n  // Array of strings, used to build the ruleSet.\n  // Each l (left side) and r (right side) are parsed by\n  // the expression parser into a node tree.\n  // Left hand sides are matched to subtrees within the\n  // expression to be parsed and replaced with the right\n  // hand side.\n  // TODO: Add support for constraints on constants (either in the form of a '=' expression or a callback [callback allows things like comparing symbols alphabetically])\n  // To evaluate lhs constants for rhs constants, use: { l: 'c1+c2', r: 'c3', evaluate: 'c3 = c1 + c2' }. Multiple assignments are separated by ';' in block format.\n  // It is possible to get into an infinite loop with conflicting rules\n  simplify.rules = [simplifyCore,\n  // { l: 'n+0', r: 'n' },     // simplifyCore\n  // { l: 'n^0', r: '1' },     // simplifyCore\n  // { l: '0*n', r: '0' },     // simplifyCore\n  // { l: 'n/n', r: '1'},      // simplifyCore\n  // { l: 'n^1', r: 'n' },     // simplifyCore\n  // { l: '+n1', r:'n1' },     // simplifyCore\n  // { l: 'n--n1', r:'n+n1' }, // simplifyCore\n  {\n    l: 'log(e)',\n    r: '1'\n  },\n  // temporary rules\n  // Note initially we tend constants to the right because like-term\n  // collection prefers the left, and we would rather collect nonconstants\n  {\n    s: 'n-n1 -> n+-n1',\n    // temporarily replace 'subtract' so we can further flatten the 'add' operator\n    assuming: {\n      subtract: {\n        total: true\n      }\n    }\n  }, {\n    s: 'n-n -> 0',\n    // partial alternative when we can't always subtract\n    assuming: {\n      subtract: {\n        total: false\n      }\n    }\n  }, {\n    s: '-(c*v) -> v * (-c)',\n    // make non-constant terms positive\n    assuming: {\n      multiply: {\n        commutative: true\n      },\n      subtract: {\n        total: true\n      }\n    }\n  }, {\n    s: '-(c*v) -> (-c) * v',\n    // non-commutative version, part 1\n    assuming: {\n      multiply: {\n        commutative: false\n      },\n      subtract: {\n        total: true\n      }\n    }\n  }, {\n    s: '-(v*c) -> v * (-c)',\n    // non-commutative version, part 2\n    assuming: {\n      multiply: {\n        commutative: false\n      },\n      subtract: {\n        total: true\n      }\n    }\n  }, {\n    l: '-(n1/n2)',\n    r: '-n1/n2'\n  }, {\n    l: '-v',\n    r: 'v * (-1)'\n  },\n  // finish making non-constant terms positive\n  {\n    l: '(n1 + n2)*(-1)',\n    r: 'n1*(-1) + n2*(-1)',\n    repeat: true\n  },\n  // expand negations to achieve as much sign cancellation as possible\n  {\n    l: 'n/n1^n2',\n    r: 'n*n1^-n2'\n  },\n  // temporarily replace 'divide' so we can further flatten the 'multiply' operator\n  {\n    l: 'n/n1',\n    r: 'n*n1^-1'\n  }, {\n    s: '(n1*n2)^n3 -> n1^n3 * n2^n3',\n    assuming: {\n      multiply: {\n        commutative: true\n      }\n    }\n  }, {\n    s: '(n1*n2)^(-1) -> n2^(-1) * n1^(-1)',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  },\n  // expand nested exponentiation\n  {\n    s: '(n ^ n1) ^ n2 -> n ^ (n1 * n2)',\n    assuming: {\n      divide: {\n        total: true\n      }\n    } // 1/(1/n) = n needs 1/n to exist\n  },\n  // collect like factors; into a sum, only do this for nonconstants\n  {\n    l: ' v   * ( v   * n1 + n2)',\n    r: 'v^2       * n1 +  v   * n2'\n  }, {\n    s: ' v   * (v^n4 * n1 + n2)   ->  v^(1+n4)  * n1 +  v   * n2',\n    assuming: {\n      divide: {\n        total: true\n      }\n    } // v*1/v = v^(1+-1) needs 1/v\n  }, {\n    s: 'v^n3 * ( v   * n1 + n2)   ->  v^(n3+1)  * n1 + v^n3 * n2',\n    assuming: {\n      divide: {\n        total: true\n      }\n    }\n  }, {\n    s: 'v^n3 * (v^n4 * n1 + n2)   ->  v^(n3+n4) * n1 + v^n3 * n2',\n    assuming: {\n      divide: {\n        total: true\n      }\n    }\n  }, {\n    l: 'n*n',\n    r: 'n^2'\n  }, {\n    s: 'n * n^n1 -> n^(n1+1)',\n    assuming: {\n      divide: {\n        total: true\n      }\n    } // n*1/n = n^(-1+1) needs 1/n\n  }, {\n    s: 'n^n1 * n^n2 -> n^(n1+n2)',\n    assuming: {\n      divide: {\n        total: true\n      }\n    } // ditto for n^2*1/n^2\n  },\n  // Unfortunately, to deal with more complicated cancellations, it\n  // becomes necessary to simplify constants twice per pass. It's not\n  // terribly expensive compared to matching rules, so this should not\n  // pose a performance problem.\n  simplifyConstant,\n  // First: before collecting like terms\n\n  // collect like terms\n  {\n    s: 'n+n -> 2*n',\n    assuming: {\n      add: {\n        total: true\n      }\n    } // 2 = 1 + 1 needs to exist\n  }, {\n    l: 'n+-n',\n    r: '0'\n  }, {\n    l: 'v*n + v',\n    r: 'v*(n+1)'\n  },\n  // NOTE: leftmost position is special:\n  {\n    l: 'n3*n1 + n3*n2',\n    r: 'n3*(n1+n2)'\n  },\n  // All sub-monomials tried there.\n  {\n    l: 'n3^(-n4)*n1 +   n3  * n2',\n    r: 'n3^(-n4)*(n1 + n3^(n4+1) *n2)'\n  }, {\n    l: 'n3^(-n4)*n1 + n3^n5 * n2',\n    r: 'n3^(-n4)*(n1 + n3^(n4+n5)*n2)'\n  }, {\n    s: 'n*v + v -> (n+1)*v',\n    // noncommutative additional cases\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, {\n    s: 'n1*n3 + n2*n3 -> (n1+n2)*n3',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, {\n    s: 'n1*n3^(-n4) + n2 * n3    -> (n1 + n2*n3^(n4 +  1))*n3^(-n4)',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, {\n    s: 'n1*n3^(-n4) + n2 * n3^n5 -> (n1 + n2*n3^(n4 + n5))*n3^(-n4)',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, {\n    l: 'n*c + c',\n    r: '(n+1)*c'\n  }, {\n    s: 'c*n + c -> c*(n+1)',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, simplifyConstant,\n  // Second: before returning expressions to \"standard form\"\n\n  // make factors positive (and undo 'make non-constant terms positive')\n  {\n    s: '(-n)*n1 -> -(n*n1)',\n    assuming: {\n      subtract: {\n        total: true\n      }\n    }\n  }, {\n    s: 'n1*(-n) -> -(n1*n)',\n    // in case * non-commutative\n    assuming: {\n      subtract: {\n        total: true\n      },\n      multiply: {\n        commutative: false\n      }\n    }\n  },\n  // final ordering of constants\n  {\n    s: 'c+v -> v+c',\n    assuming: {\n      add: {\n        commutative: true\n      }\n    },\n    imposeContext: {\n      add: {\n        commutative: false\n      }\n    }\n  }, {\n    s: 'v*c -> c*v',\n    assuming: {\n      multiply: {\n        commutative: true\n      }\n    },\n    imposeContext: {\n      multiply: {\n        commutative: false\n      }\n    }\n  },\n  // undo temporary rules\n  // { l: '(-1) * n', r: '-n' }, // #811 added test which proved this is redundant\n  {\n    l: 'n+-n1',\n    r: 'n-n1'\n  },\n  // undo replace 'subtract'\n  {\n    s: 'n*(n1^-1) -> n/n1',\n    // undo replace 'divide'; for * commutative\n    assuming: {\n      multiply: {\n        commutative: true\n      }\n    } // o.w. / not conventional\n  }, {\n    s: 'n*n1^-n2 -> n/n1^n2',\n    assuming: {\n      multiply: {\n        commutative: true\n      }\n    } // o.w. / not conventional\n  }, {\n    s: 'n^-1 -> 1/n',\n    assuming: {\n      multiply: {\n        commutative: true\n      }\n    } // o.w. / not conventional\n  }, {\n    l: 'n^1',\n    r: 'n'\n  },\n  // can be produced by power cancellation\n  {\n    s: 'n*(n1/n2) -> (n*n1)/n2',\n    // '*' before '/'\n    assuming: {\n      multiply: {\n        associative: true\n      }\n    }\n  }, {\n    s: 'n-(n1+n2) -> n-n1-n2',\n    // '-' before '+'\n    assuming: {\n      addition: {\n        associative: true,\n        commutative: true\n      }\n    }\n  },\n  // { l: '(n1/n2)/n3', r: 'n1/(n2*n3)' },\n  // { l: '(n*n1)/(n*n2)', r: 'n1/n2' },\n\n  // simplifyConstant can leave an extra factor of 1, which can always\n  // be eliminated, since the identity always commutes\n  {\n    l: '1*n',\n    r: 'n',\n    imposeContext: {\n      multiply: {\n        commutative: true\n      }\n    }\n  }, {\n    s: 'n1/(n2/n3) -> (n1*n3)/n2',\n    assuming: {\n      multiply: {\n        associative: true\n      }\n    }\n  }, {\n    l: 'n1/(-n2)',\n    r: '-n1/n2'\n  }];\n\n  /**\n   * Takes any rule object as allowed by the specification in simplify\n   * and puts it in a standard form used by applyRule\n   */\n  function _canonicalizeRule(ruleObject, context) {\n    var newRule = {};\n    if (ruleObject.s) {\n      var lr = ruleObject.s.split('->');\n      if (lr.length === 2) {\n        newRule.l = lr[0];\n        newRule.r = lr[1];\n      } else {\n        throw SyntaxError('Could not parse rule: ' + ruleObject.s);\n      }\n    } else {\n      newRule.l = ruleObject.l;\n      newRule.r = ruleObject.r;\n    }\n    newRule.l = removeParens(parse(newRule.l));\n    newRule.r = removeParens(parse(newRule.r));\n    for (var _i = 0, _arr = ['imposeContext', 'repeat', 'assuming']; _i < _arr.length; _i++) {\n      var prop = _arr[_i];\n      if (prop in ruleObject) {\n        newRule[prop] = ruleObject[prop];\n      }\n    }\n    if (ruleObject.evaluate) {\n      newRule.evaluate = parse(ruleObject.evaluate);\n    }\n    if (isAssociative(newRule.l, context)) {\n      var makeNode = createMakeNodeFunction(newRule.l);\n      var expandsym = _getExpandPlaceholderSymbol();\n      newRule.expanded = {};\n      newRule.expanded.l = makeNode([newRule.l.clone(), expandsym]);\n      // Push the expandsym into the deepest possible branch.\n      // This helps to match the newRule against nodes returned from getSplits() later on.\n      flatten(newRule.expanded.l, context);\n      unflattenr(newRule.expanded.l, context);\n      newRule.expanded.r = makeNode([newRule.r, expandsym]);\n    }\n    return newRule;\n  }\n\n  /**\n   * Parse the string array of rules into nodes\n   *\n   * Example syntax for rules:\n   *\n   * Position constants to the left in a product:\n   * { l: 'n1 * c1', r: 'c1 * n1' }\n   * n1 is any Node, and c1 is a ConstantNode.\n   *\n   * Apply difference of squares formula:\n   * { l: '(n1 - n2) * (n1 + n2)', r: 'n1^2 - n2^2' }\n   * n1, n2 mean any Node.\n   *\n   * Short hand notation:\n   * 'n1 * c1 -> c1 * n1'\n   */\n  function _buildRules(rules, context) {\n    // Array of rules to be used to simplify expressions\n    var ruleSet = [];\n    for (var i = 0; i < rules.length; i++) {\n      var rule = rules[i];\n      var newRule = void 0;\n      var ruleType = (0, _typeof2[\"default\"])(rule);\n      switch (ruleType) {\n        case 'string':\n          rule = {\n            s: rule\n          };\n        /* falls through */\n        case 'object':\n          newRule = _canonicalizeRule(rule, context);\n          break;\n        case 'function':\n          newRule = rule;\n          break;\n        default:\n          throw TypeError('Unsupported type of rule: ' + ruleType);\n      }\n      // console.log('Adding rule: ' + rules[i])\n      // console.log(newRule)\n      ruleSet.push(newRule);\n    }\n    return ruleSet;\n  }\n  var _lastsym = 0;\n  function _getExpandPlaceholderSymbol() {\n    return new SymbolNode('_p' + _lastsym++);\n  }\n  function _simplify(expr, rules) {\n    var scope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (0, _map.createEmptyMap)();\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var debug = options.consoleDebug;\n    rules = _buildRules(rules || simplify.rules, options.context);\n    var res = resolve(expr, scope);\n    res = removeParens(res);\n    var visited = {};\n    var str = res.toString({\n      parenthesis: 'all'\n    });\n    while (!visited[str]) {\n      visited[str] = true;\n      _lastsym = 0; // counter for placeholder symbols\n      var laststr = str;\n      if (debug) console.log('Working on: ', str);\n      for (var i = 0; i < rules.length; i++) {\n        var rulestr = '';\n        if (typeof rules[i] === 'function') {\n          res = rules[i](res, options);\n          if (debug) rulestr = rules[i].name;\n        } else {\n          flatten(res, options.context);\n          res = applyRule(res, rules[i], options.context);\n          if (debug) {\n            rulestr = \"\".concat(rules[i].l.toString(), \" -> \").concat(rules[i].r.toString());\n          }\n        }\n        if (debug) {\n          var newstr = res.toString({\n            parenthesis: 'all'\n          });\n          if (newstr !== laststr) {\n            console.log('Applying', rulestr, 'produced', newstr);\n            laststr = newstr;\n          }\n        }\n        /* Use left-heavy binary tree internally,\n         * since custom rule functions may expect it\n         */\n        unflattenl(res, options.context);\n      }\n      str = res.toString({\n        parenthesis: 'all'\n      });\n    }\n    return res;\n  }\n  function mapRule(nodes, rule, context) {\n    var resNodes = nodes;\n    if (nodes) {\n      for (var i = 0; i < nodes.length; ++i) {\n        var newNode = applyRule(nodes[i], rule, context);\n        if (newNode !== nodes[i]) {\n          if (resNodes === nodes) {\n            resNodes = nodes.slice();\n          }\n          resNodes[i] = newNode;\n        }\n      }\n    }\n    return resNodes;\n  }\n\n  /**\n   * Returns a simplfied form of node, or the original node if no simplification was possible.\n   *\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @param  {Object | Function} rule\n   * @param  {Object} context -- information about assumed properties of operators\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} The simplified form of `expr`, or the original node if no simplification was possible.\n   */\n  function applyRule(node, rule, context) {\n    //    console.log('Entering applyRule(\"', rule.l.toString({parenthesis:'all'}), '->', rule.r.toString({parenthesis:'all'}), '\",', node.toString({parenthesis:'all'}),')')\n\n    // check that the assumptions for this rule are satisfied by the current\n    // context:\n    if (rule.assuming) {\n      for (var symbol in rule.assuming) {\n        for (var property in rule.assuming[symbol]) {\n          if (hasProperty(symbol, property, context) !== rule.assuming[symbol][property]) {\n            return node;\n          }\n        }\n      }\n    }\n    var mergedContext = mergeContext(rule.imposeContext, context);\n\n    // Do not clone node unless we find a match\n    var res = node;\n\n    // First replace our child nodes with their simplified versions\n    // If a child could not be simplified, applying the rule to it\n    // will have no effect since the node is returned unchanged\n    if (res instanceof OperatorNode || res instanceof FunctionNode) {\n      var newArgs = mapRule(res.args, rule, context);\n      if (newArgs !== res.args) {\n        res = res.clone();\n        res.args = newArgs;\n      }\n    } else if (res instanceof ParenthesisNode) {\n      if (res.content) {\n        var newContent = applyRule(res.content, rule, context);\n        if (newContent !== res.content) {\n          res = new ParenthesisNode(newContent);\n        }\n      }\n    } else if (res instanceof ArrayNode) {\n      var newItems = mapRule(res.items, rule, context);\n      if (newItems !== res.items) {\n        res = new ArrayNode(newItems);\n      }\n    } else if (res instanceof AccessorNode) {\n      var newObj = res.object;\n      if (res.object) {\n        newObj = applyRule(res.object, rule, context);\n      }\n      var newIndex = res.index;\n      if (res.index) {\n        newIndex = applyRule(res.index, rule, context);\n      }\n      if (newObj !== res.object || newIndex !== res.index) {\n        res = new AccessorNode(newObj, newIndex);\n      }\n    } else if (res instanceof IndexNode) {\n      var newDims = mapRule(res.dimensions, rule, context);\n      if (newDims !== res.dimensions) {\n        res = new IndexNode(newDims);\n      }\n    } else if (res instanceof ObjectNode) {\n      var changed = false;\n      var newProps = {};\n      for (var prop in res.properties) {\n        newProps[prop] = applyRule(res.properties[prop], rule, context);\n        if (newProps[prop] !== res.properties[prop]) {\n          changed = true;\n        }\n      }\n      if (changed) {\n        res = new ObjectNode(newProps);\n      }\n    }\n\n    // Try to match a rule against this node\n    var repl = rule.r;\n    var matches = _ruleMatch(rule.l, res, mergedContext)[0];\n\n    // If the rule is associative operator, we can try matching it while allowing additional terms.\n    // This allows us to match rules like 'n+n' to the expression '(1+x)+x' or even 'x+1+x' if the operator is commutative.\n    if (!matches && rule.expanded) {\n      repl = rule.expanded.r;\n      matches = _ruleMatch(rule.expanded.l, res, mergedContext)[0];\n    }\n    if (matches) {\n      // const before = res.toString({parenthesis: 'all'})\n\n      // Create a new node by cloning the rhs of the matched rule\n      // we keep any implicit multiplication state if relevant\n      var implicit = res.implicit;\n      res = repl.clone();\n      if (implicit && 'implicit' in repl) {\n        res.implicit = true;\n      }\n\n      // Replace placeholders with their respective nodes without traversing deeper into the replaced nodes\n      res = res.transform(function (node) {\n        if (node.isSymbolNode && (0, _object.hasOwnProperty)(matches.placeholders, node.name)) {\n          return matches.placeholders[node.name].clone();\n        } else {\n          return node;\n        }\n      });\n\n      // const after = res.toString({parenthesis: 'all'})\n      // console.log('Simplified ' + before + ' to ' + after)\n    }\n\n    if (rule.repeat && res !== node) {\n      res = applyRule(res, rule, context);\n    }\n    return res;\n  }\n\n  /**\n   * Get (binary) combinations of a flattened binary node\n   * e.g. +(node1, node2, node3) -> [\n   *        +(node1,  +(node2, node3)),\n   *        +(node2,  +(node1, node3)),\n   *        +(node3,  +(node1, node2))]\n   *\n   */\n  function getSplits(node, context) {\n    var res = [];\n    var right, rightArgs;\n    var makeNode = createMakeNodeFunction(node);\n    if (isCommutative(node, context)) {\n      for (var i = 0; i < node.args.length; i++) {\n        rightArgs = node.args.slice(0);\n        rightArgs.splice(i, 1);\n        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\n        res.push(makeNode([node.args[i], right]));\n      }\n    } else {\n      // Keep order, but try all parenthesizations\n      for (var _i2 = 1; _i2 < node.args.length; _i2++) {\n        var left = node.args[0];\n        if (_i2 > 1) {\n          left = makeNode(node.args.slice(0, _i2));\n        }\n        rightArgs = node.args.slice(_i2);\n        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\n        res.push(makeNode([left, right]));\n      }\n    }\n    return res;\n  }\n\n  /**\n   * Returns the set union of two match-placeholders or null if there is a conflict.\n   */\n  function mergeMatch(match1, match2) {\n    var res = {\n      placeholders: {}\n    };\n\n    // Some matches may not have placeholders; this is OK\n    if (!match1.placeholders && !match2.placeholders) {\n      return res;\n    } else if (!match1.placeholders) {\n      return match2;\n    } else if (!match2.placeholders) {\n      return match1;\n    }\n\n    // Placeholders with the same key must match exactly\n    for (var key in match1.placeholders) {\n      if ((0, _object.hasOwnProperty)(match1.placeholders, key)) {\n        res.placeholders[key] = match1.placeholders[key];\n        if ((0, _object.hasOwnProperty)(match2.placeholders, key)) {\n          if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {\n            return null;\n          }\n        }\n      }\n    }\n    for (var _key in match2.placeholders) {\n      if ((0, _object.hasOwnProperty)(match2.placeholders, _key)) {\n        res.placeholders[_key] = match2.placeholders[_key];\n      }\n    }\n    return res;\n  }\n\n  /**\n   * Combine two lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\n   * Each list represents matches found in one child of a node.\n   */\n  function combineChildMatches(list1, list2) {\n    var res = [];\n    if (list1.length === 0 || list2.length === 0) {\n      return res;\n    }\n    var merged;\n    for (var i1 = 0; i1 < list1.length; i1++) {\n      for (var i2 = 0; i2 < list2.length; i2++) {\n        merged = mergeMatch(list1[i1], list2[i2]);\n        if (merged) {\n          res.push(merged);\n        }\n      }\n    }\n    return res;\n  }\n\n  /**\n   * Combine multiple lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\n   * Each list represents matches found in one child of a node.\n   * Returns a list of unique matches.\n   */\n  function mergeChildMatches(childMatches) {\n    if (childMatches.length === 0) {\n      return childMatches;\n    }\n    var sets = childMatches.reduce(combineChildMatches);\n    var uniqueSets = [];\n    var unique = {};\n    for (var i = 0; i < sets.length; i++) {\n      var s = JSON.stringify(sets[i]);\n      if (!unique[s]) {\n        unique[s] = true;\n        uniqueSets.push(sets[i]);\n      }\n    }\n    return uniqueSets;\n  }\n\n  /**\n   * Determines whether node matches rule.\n   *\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} rule\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @param {Object} context -- provides assumed properties of operators\n   * @param {Boolean} isSplit -- whether we are in process of splitting an\n   *                    n-ary operator node into possible binary combinations.\n   *                    Defaults to false.\n   * @return {Object} Information about the match, if it exists.\n   */\n  function _ruleMatch(rule, node, context, isSplit) {\n    //    console.log('Entering _ruleMatch(' + JSON.stringify(rule) + ', ' + JSON.stringify(node) + ')')\n    //    console.log('rule = ' + rule)\n    //    console.log('node = ' + node)\n\n    //    console.log('Entering _ruleMatch(', rule.toString({parenthesis:'all'}), ', ', node.toString({parenthesis:'all'}), ', ', context, ')')\n    var res = [{\n      placeholders: {}\n    }];\n    if (rule instanceof OperatorNode && node instanceof OperatorNode || rule instanceof FunctionNode && node instanceof FunctionNode) {\n      // If the rule is an OperatorNode or a FunctionNode, then node must match exactly\n      if (rule instanceof OperatorNode) {\n        if (rule.op !== node.op || rule.fn !== node.fn) {\n          return [];\n        }\n      } else if (rule instanceof FunctionNode) {\n        if (rule.name !== node.name) {\n          return [];\n        }\n      }\n\n      // rule and node match. Search the children of rule and node.\n      if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node, context) && node.args.length === rule.args.length || isSplit) {\n        // Expect non-associative operators to match exactly,\n        // except in any order if operator is commutative\n        var childMatches = [];\n        for (var i = 0; i < rule.args.length; i++) {\n          var childMatch = _ruleMatch(rule.args[i], node.args[i], context);\n          if (childMatch.length === 0) {\n            // Child did not match, so stop searching immediately\n            break;\n          }\n          // The child matched, so add the information returned from the child to our result\n          childMatches.push(childMatch);\n        }\n        if (childMatches.length !== rule.args.length) {\n          if (!isCommutative(node, context) ||\n          // exact match in order needed\n          rule.args.length === 1) {\n            // nothing to commute\n            return [];\n          }\n          if (rule.args.length > 2) {\n            /* Need to generate all permutations and try them.\n             * It's a bit complicated, and unlikely to come up since there\n             * are very few ternary or higher operators. So punt for now.\n             */\n            throw new Error('permuting >2 commutative non-associative rule arguments not yet implemented');\n          }\n          /* Exactly two arguments, try them reversed */\n          var leftMatch = _ruleMatch(rule.args[0], node.args[1], context);\n          if (leftMatch.length === 0) {\n            return [];\n          }\n          var rightMatch = _ruleMatch(rule.args[1], node.args[0], context);\n          if (rightMatch.length === 0) {\n            return [];\n          }\n          childMatches = [leftMatch, rightMatch];\n        }\n        res = mergeChildMatches(childMatches);\n      } else if (node.args.length >= 2 && rule.args.length === 2) {\n        // node is flattened, rule is not\n        // Associative operators/functions can be split in different ways so we check if the rule matches each\n        // them and return their union.\n        var splits = getSplits(node, context);\n        var splitMatches = [];\n        for (var _i3 = 0; _i3 < splits.length; _i3++) {\n          var matchSet = _ruleMatch(rule, splits[_i3], context, true); // recursing at the same tree depth here\n          splitMatches = splitMatches.concat(matchSet);\n        }\n        return splitMatches;\n      } else if (rule.args.length > 2) {\n        throw Error('Unexpected non-binary associative function: ' + rule.toString());\n      } else {\n        // Incorrect number of arguments in rule and node, so no match\n        return [];\n      }\n    } else if (rule instanceof SymbolNode) {\n      // If the rule is a SymbolNode, then it carries a special meaning\n      // according to the first character of the symbol node name.\n      // c.* matches a ConstantNode\n      // n.* matches any node\n      if (rule.name.length === 0) {\n        throw new Error('Symbol in rule has 0 length...!?');\n      }\n      if (SUPPORTED_CONSTANTS[rule.name]) {\n        // built-in constant must match exactly\n        if (rule.name !== node.name) {\n          return [];\n        }\n      } else if (rule.name[0] === 'n' || rule.name.substring(0, 2) === '_p') {\n        // rule matches _anything_, so assign this node to the rule.name placeholder\n        // Assign node to the rule.name placeholder.\n        // Our parent will check for matches among placeholders.\n        res[0].placeholders[rule.name] = node;\n      } else if (rule.name[0] === 'v') {\n        // rule matches any variable thing (not a ConstantNode)\n        if (!(0, _is.isConstantNode)(node)) {\n          res[0].placeholders[rule.name] = node;\n        } else {\n          // Mis-match: rule was expecting something other than a ConstantNode\n          return [];\n        }\n      } else if (rule.name[0] === 'c') {\n        // rule matches any ConstantNode\n        if (node instanceof ConstantNode) {\n          res[0].placeholders[rule.name] = node;\n        } else {\n          // Mis-match: rule was expecting a ConstantNode\n          return [];\n        }\n      } else {\n        throw new Error('Invalid symbol in rule: ' + rule.name);\n      }\n    } else if (rule instanceof ConstantNode) {\n      // Literal constant must match exactly\n      if (!equal(rule.value, node.value)) {\n        return [];\n      }\n    } else {\n      // Some other node was encountered which we aren't prepared for, so no match\n      return [];\n    }\n\n    // It's a match!\n\n    // console.log('_ruleMatch(' + rule.toString() + ', ' + node.toString() + ') found a match')\n    return res;\n  }\n\n  /**\n   * Determines whether p and q (and all their children nodes) are identical.\n   *\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} p\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} q\n   * @return {Object} Information about the match, if it exists.\n   */\n  function _exactMatch(p, q) {\n    if (p instanceof ConstantNode && q instanceof ConstantNode) {\n      if (!equal(p.value, q.value)) {\n        return false;\n      }\n    } else if (p instanceof SymbolNode && q instanceof SymbolNode) {\n      if (p.name !== q.name) {\n        return false;\n      }\n    } else if (p instanceof OperatorNode && q instanceof OperatorNode || p instanceof FunctionNode && q instanceof FunctionNode) {\n      if (p instanceof OperatorNode) {\n        if (p.op !== q.op || p.fn !== q.fn) {\n          return false;\n        }\n      } else if (p instanceof FunctionNode) {\n        if (p.name !== q.name) {\n          return false;\n        }\n      }\n      if (p.args.length !== q.args.length) {\n        return false;\n      }\n      for (var i = 0; i < p.args.length; i++) {\n        if (!_exactMatch(p.args[i], q.args[i])) {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n    return true;\n  }\n  return simplify;\n});\nexports.createSimplify = createSimplify;"],"mappings":"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;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACErC,KAAK,CAACsC,aAAa,CAAC;IAClBC,IAAI,EAAE,QAAQ;IACdC,EAAE,EAAE,KAAK;IACTC,OAAO,EAAE/C,IAAI,CAACgD;EAChB,CAAC,CAAC;EACF,IAAIC,QAAQ,GAAG3C,KAAK,CAAC,UAAU,EAAE;IAC/B4C,IAAI,EAAEC,SAAS;IACf,WAAW,EAAE,SAASC,OAAO,CAACC,IAAI,EAAEC,KAAK,EAAE;MACzC,OAAOH,SAAS,CAACE,IAAI,EAAE,KAAK,EAAEC,KAAK,CAAC;IACtC,CAAC;IACD,mBAAmB,EAAE,SAASC,aAAa,CAACF,IAAI,EAAEC,KAAK,EAAEE,OAAO,EAAE;MAChE,OAAOL,SAAS,CAACE,IAAI,EAAE,KAAK,EAAEC,KAAK,EAAEE,OAAO,CAAC;IAC/C,CAAC;IACD,aAAa,EAAEL,SAAS;IACxB,kBAAkB,EAAEA,SAAS;IAC7B,0BAA0B,EAAEA;EAC9B,CAAC,CAAC;EACF7C,KAAK,CAACmD,gBAAgB,CAAC;IACrBZ,IAAI,EAAE,QAAQ;IACdC,EAAE,EAAE,KAAK;IACTC,OAAO,EAAE/C,IAAI,CAACgD;EAChB,CAAC,CAAC;EACFC,QAAQ,CAACR,cAAc,GAAGA,cAAc;EACxCQ,QAAQ,CAACP,WAAW,GAAGA,WAAW;EAClCO,QAAQ,CAACN,eAAe,GAAG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"},"metadata":{},"sourceType":"script"}