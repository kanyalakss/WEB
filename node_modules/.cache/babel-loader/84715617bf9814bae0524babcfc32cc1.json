{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSparseMatrixClass = void 0;\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\nvar _is = require(\"../../utils/is.js\");\nvar _number = require(\"../../utils/number.js\");\nvar _string = require(\"../../utils/string.js\");\nvar _object = require(\"../../utils/object.js\");\nvar _array = require(\"../../utils/array.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar _DimensionError = require(\"../../error/DimensionError.js\");\nvar _function = require(\"../../utils/function.js\");\nvar name = 'SparseMatrix';\nvar dependencies = ['typed', 'equalScalar', 'Matrix'];\nvar createSparseMatrixClass = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n    equalScalar = _ref.equalScalar,\n    Matrix = _ref.Matrix;\n  /**\n   * Sparse Matrix implementation. This type implements\n   * a [Compressed Column Storage](https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_(CSC_or_CCS))\n   * format for two-dimensional sparse matrices.\n   * @class SparseMatrix\n   */\n  function SparseMatrix(data, datatype) {\n    if (!(this instanceof SparseMatrix)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n    if (datatype && !(0, _is.isString)(datatype)) {\n      throw new Error('Invalid datatype: ' + datatype);\n    }\n    if ((0, _is.isMatrix)(data)) {\n      // create from matrix\n      _createFromMatrix(this, data, datatype);\n    } else if (data && (0, _is.isArray)(data.index) && (0, _is.isArray)(data.ptr) && (0, _is.isArray)(data.size)) {\n      // initialize fields\n      this._values = data.values;\n      this._index = data.index;\n      this._ptr = data.ptr;\n      this._size = data.size;\n      this._datatype = datatype || data.datatype;\n    } else if ((0, _is.isArray)(data)) {\n      // create from array\n      _createFromArray(this, data, datatype);\n    } else if (data) {\n      // unsupported type\n      throw new TypeError('Unsupported type of data (' + (0, _is.typeOf)(data) + ')');\n    } else {\n      // nothing provided\n      this._values = [];\n      this._index = [];\n      this._ptr = [0];\n      this._size = [0, 0];\n      this._datatype = datatype;\n    }\n  }\n  function _createFromMatrix(matrix, source, datatype) {\n    // check matrix type\n    if (source.type === 'SparseMatrix') {\n      // clone arrays\n      matrix._values = source._values ? (0, _object.clone)(source._values) : undefined;\n      matrix._index = (0, _object.clone)(source._index);\n      matrix._ptr = (0, _object.clone)(source._ptr);\n      matrix._size = (0, _object.clone)(source._size);\n      matrix._datatype = datatype || source._datatype;\n    } else {\n      // build from matrix data\n      _createFromArray(matrix, source.valueOf(), datatype || source._datatype);\n    }\n  }\n  function _createFromArray(matrix, data, datatype) {\n    // initialize fields\n    matrix._values = [];\n    matrix._index = [];\n    matrix._ptr = [];\n    matrix._datatype = datatype;\n    // discover rows & columns, do not use math.size() to avoid looping array twice\n    var rows = data.length;\n    var columns = 0;\n\n    // equal signature to use\n    var eq = equalScalar;\n    // zero value\n    var zero = 0;\n    if ((0, _is.isString)(datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar;\n      // convert 0 to the same datatype\n      zero = typed.convert(0, datatype);\n    }\n\n    // check we have rows (empty array)\n    if (rows > 0) {\n      // column index\n      var j = 0;\n      do {\n        // store pointer to values index\n        matrix._ptr.push(matrix._index.length);\n        // loop rows\n        for (var i = 0; i < rows; i++) {\n          // current row\n          var row = data[i];\n          // check row is an array\n          if ((0, _is.isArray)(row)) {\n            // update columns if needed (only on first column)\n            if (j === 0 && columns < row.length) {\n              columns = row.length;\n            }\n            // check row has column\n            if (j < row.length) {\n              // value\n              var v = row[j];\n              // check value != 0\n              if (!eq(v, zero)) {\n                // store value\n                matrix._values.push(v);\n                // index\n                matrix._index.push(i);\n              }\n            }\n          } else {\n            // update columns if needed (only on first column)\n            if (j === 0 && columns < 1) {\n              columns = 1;\n            }\n            // check value != 0 (row is a scalar)\n            if (!eq(row, zero)) {\n              // store value\n              matrix._values.push(row);\n              // index\n              matrix._index.push(i);\n            }\n          }\n        }\n        // increment index\n        j++;\n      } while (j < columns);\n    }\n    // store number of values in ptr\n    matrix._ptr.push(matrix._index.length);\n    // size\n    matrix._size = [rows, columns];\n  }\n  SparseMatrix.prototype = new Matrix();\n\n  /**\n   * Create a new SparseMatrix\n   */\n  SparseMatrix.prototype.createSparseMatrix = function (data, datatype) {\n    return new SparseMatrix(data, datatype);\n  };\n\n  /**\n   * Attach type information\n   */\n  Object.defineProperty(SparseMatrix, 'name', {\n    value: 'SparseMatrix'\n  });\n  SparseMatrix.prototype.constructor = SparseMatrix;\n  SparseMatrix.prototype.type = 'SparseMatrix';\n  SparseMatrix.prototype.isSparseMatrix = true;\n\n  /**\n   * Get the matrix type\n   *\n   * Usage:\n   *    const matrixType = matrix.getDataType()  // retrieves the matrix type\n   *\n   * @memberOf SparseMatrix\n   * @return {string}   type information; if multiple types are found from the Matrix, it will return \"mixed\"\n   */\n  SparseMatrix.prototype.getDataType = function () {\n    return (0, _array.getArrayDataType)(this._values, _is.typeOf);\n  };\n\n  /**\n   * Get the storage format used by the matrix.\n   *\n   * Usage:\n   *     const format = matrix.storage()   // retrieve storage format\n   *\n   * @memberof SparseMatrix\n   * @return {string}           The storage format.\n   */\n  SparseMatrix.prototype.storage = function () {\n    return 'sparse';\n  };\n\n  /**\n   * Get the datatype of the data stored in the matrix.\n   *\n   * Usage:\n   *     const format = matrix.datatype()    // retrieve matrix datatype\n   *\n   * @memberof SparseMatrix\n   * @return {string}           The datatype.\n   */\n  SparseMatrix.prototype.datatype = function () {\n    return this._datatype;\n  };\n\n  /**\n   * Create a new SparseMatrix\n   * @memberof SparseMatrix\n   * @param {Array} data\n   * @param {string} [datatype]\n   */\n  SparseMatrix.prototype.create = function (data, datatype) {\n    return new SparseMatrix(data, datatype);\n  };\n\n  /**\n   * Get the matrix density.\n   *\n   * Usage:\n   *     const density = matrix.density()                   // retrieve matrix density\n   *\n   * @memberof SparseMatrix\n   * @return {number}           The matrix density.\n   */\n  SparseMatrix.prototype.density = function () {\n    // rows & columns\n    var rows = this._size[0];\n    var columns = this._size[1];\n    // calculate density\n    return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;\n  };\n\n  /**\n   * Get a subset of the matrix, or replace a subset of the matrix.\n   *\n   * Usage:\n   *     const subset = matrix.subset(index)               // retrieve subset\n   *     const value = matrix.subset(index, replacement)   // replace subset\n   *\n   * @memberof SparseMatrix\n   * @param {Index} index\n   * @param {Array | Matrix | *} [replacement]\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be filled with zeros.\n   */\n  SparseMatrix.prototype.subset = function (index, replacement, defaultValue) {\n    // check it is a pattern matrix\n    if (!this._values) {\n      throw new Error('Cannot invoke subset on a Pattern only matrix');\n    }\n\n    // check arguments\n    switch (arguments.length) {\n      case 1:\n        return _getsubset(this, index);\n\n      // intentional fall through\n      case 2:\n      case 3:\n        return _setsubset(this, index, replacement, defaultValue);\n      default:\n        throw new SyntaxError('Wrong number of arguments');\n    }\n  };\n  function _getsubset(matrix, idx) {\n    // check idx\n    if (!(0, _is.isIndex)(idx)) {\n      throw new TypeError('Invalid index');\n    }\n    var isScalar = idx.isScalar();\n    if (isScalar) {\n      // return a scalar\n      return matrix.get(idx.min());\n    }\n    // validate dimensions\n    var size = idx.size();\n    if (size.length !== matrix._size.length) {\n      throw new _DimensionError.DimensionError(size.length, matrix._size.length);\n    }\n\n    // vars\n    var i, ii, k, kk;\n\n    // validate if any of the ranges in the index is out of range\n    var min = idx.min();\n    var max = idx.max();\n    for (i = 0, ii = matrix._size.length; i < ii; i++) {\n      (0, _array.validateIndex)(min[i], matrix._size[i]);\n      (0, _array.validateIndex)(max[i], matrix._size[i]);\n    }\n\n    // matrix arrays\n    var mvalues = matrix._values;\n    var mindex = matrix._index;\n    var mptr = matrix._ptr;\n\n    // rows & columns dimensions for result matrix\n    var rows = idx.dimension(0);\n    var columns = idx.dimension(1);\n\n    // workspace & permutation vector\n    var w = [];\n    var pv = [];\n\n    // loop rows in resulting matrix\n    rows.forEach(function (i, r) {\n      // update permutation vector\n      pv[i] = r[0];\n      // mark i in workspace\n      w[i] = true;\n    });\n\n    // result matrix arrays\n    var values = mvalues ? [] : undefined;\n    var index = [];\n    var ptr = [];\n\n    // loop columns in result matrix\n    columns.forEach(function (j) {\n      // update ptr\n      ptr.push(index.length);\n      // loop values in column j\n      for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {\n        // row\n        i = mindex[k];\n        // check row is in result matrix\n        if (w[i] === true) {\n          // push index\n          index.push(pv[i]);\n          // check we need to process values\n          if (values) {\n            values.push(mvalues[k]);\n          }\n        }\n      }\n    });\n    // update ptr\n    ptr.push(index.length);\n\n    // return matrix\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: size,\n      datatype: matrix._datatype\n    });\n  }\n  function _setsubset(matrix, index, submatrix, defaultValue) {\n    // check index\n    if (!index || index.isIndex !== true) {\n      throw new TypeError('Invalid index');\n    }\n\n    // get index size and check whether the index contains a single value\n    var iSize = index.size();\n    var isScalar = index.isScalar();\n\n    // calculate the size of the submatrix, and convert it into an Array if needed\n    var sSize;\n    if ((0, _is.isMatrix)(submatrix)) {\n      // submatrix size\n      sSize = submatrix.size();\n      // use array representation\n      submatrix = submatrix.toArray();\n    } else {\n      // get submatrix size (array, scalar)\n      sSize = (0, _array.arraySize)(submatrix);\n    }\n\n    // check index is a scalar\n    if (isScalar) {\n      // verify submatrix is a scalar\n      if (sSize.length !== 0) {\n        throw new TypeError('Scalar expected');\n      }\n      // set value\n      matrix.set(index.min(), submatrix, defaultValue);\n    } else {\n      // validate dimensions, index size must be one or two dimensions\n      if (iSize.length !== 1 && iSize.length !== 2) {\n        throw new _DimensionError.DimensionError(iSize.length, matrix._size.length, '<');\n      }\n\n      // check submatrix and index have the same dimensions\n      if (sSize.length < iSize.length) {\n        // calculate number of missing outer dimensions\n        var i = 0;\n        var outer = 0;\n        while (iSize[i] === 1 && sSize[i] === 1) {\n          i++;\n        }\n        while (iSize[i] === 1) {\n          outer++;\n          i++;\n        }\n        // unsqueeze both outer and inner dimensions\n        submatrix = (0, _array.unsqueeze)(submatrix, iSize.length, outer, sSize);\n      }\n\n      // check whether the size of the submatrix matches the index size\n      if (!(0, _object.deepStrictEqual)(iSize, sSize)) {\n        throw new _DimensionError.DimensionError(iSize, sSize, '>');\n      }\n\n      // insert the sub matrix\n      if (iSize.length === 1) {\n        // if the replacement index only has 1 dimension, go trough each one and set its value\n        var range = index.dimension(0);\n        range.forEach(function (dataIndex, subIndex) {\n          (0, _array.validateIndex)(dataIndex);\n          matrix.set([dataIndex, 0], submatrix[subIndex[0]], defaultValue);\n        });\n      } else {\n        // if the replacement index has 2 dimensions, go through each one and set the value in the correct index\n        var firstDimensionRange = index.dimension(0);\n        var secondDimensionRange = index.dimension(1);\n        firstDimensionRange.forEach(function (firstDataIndex, firstSubIndex) {\n          (0, _array.validateIndex)(firstDataIndex);\n          secondDimensionRange.forEach(function (secondDataIndex, secondSubIndex) {\n            (0, _array.validateIndex)(secondDataIndex);\n            matrix.set([firstDataIndex, secondDataIndex], submatrix[firstSubIndex[0]][secondSubIndex[0]], defaultValue);\n          });\n        });\n      }\n    }\n    return matrix;\n  }\n\n  /**\n   * Get a single element from the matrix.\n   * @memberof SparseMatrix\n   * @param {number[]} index   Zero-based index\n   * @return {*} value\n   */\n  SparseMatrix.prototype.get = function (index) {\n    if (!(0, _is.isArray)(index)) {\n      throw new TypeError('Array expected');\n    }\n    if (index.length !== this._size.length) {\n      throw new _DimensionError.DimensionError(index.length, this._size.length);\n    }\n\n    // check it is a pattern matrix\n    if (!this._values) {\n      throw new Error('Cannot invoke get on a Pattern only matrix');\n    }\n\n    // row and column\n    var i = index[0];\n    var j = index[1];\n\n    // check i, j are valid\n    (0, _array.validateIndex)(i, this._size[0]);\n    (0, _array.validateIndex)(j, this._size[1]);\n\n    // find value index\n    var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);\n    // check k is prior to next column k and it is in the correct row\n    if (k < this._ptr[j + 1] && this._index[k] === i) {\n      return this._values[k];\n    }\n    return 0;\n  };\n\n  /**\n   * Replace a single element in the matrix.\n   * @memberof SparseMatrix\n   * @param {number[]} index   Zero-based index\n   * @param {*} v\n   * @param {*} [defaultValue]        Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be set to zero.\n   * @return {SparseMatrix} self\n   */\n  SparseMatrix.prototype.set = function (index, v, defaultValue) {\n    if (!(0, _is.isArray)(index)) {\n      throw new TypeError('Array expected');\n    }\n    if (index.length !== this._size.length) {\n      throw new _DimensionError.DimensionError(index.length, this._size.length);\n    }\n\n    // check it is a pattern matrix\n    if (!this._values) {\n      throw new Error('Cannot invoke set on a Pattern only matrix');\n    }\n\n    // row and column\n    var i = index[0];\n    var j = index[1];\n\n    // rows & columns\n    var rows = this._size[0];\n    var columns = this._size[1];\n\n    // equal signature to use\n    var eq = equalScalar;\n    // zero value\n    var zero = 0;\n    if ((0, _is.isString)(this._datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [this._datatype, this._datatype]) || equalScalar;\n      // convert 0 to the same datatype\n      zero = typed.convert(0, this._datatype);\n    }\n\n    // check we need to resize matrix\n    if (i > rows - 1 || j > columns - 1) {\n      // resize matrix\n      _resize(this, Math.max(i + 1, rows), Math.max(j + 1, columns), defaultValue);\n      // update rows & columns\n      rows = this._size[0];\n      columns = this._size[1];\n    }\n\n    // check i, j are valid\n    (0, _array.validateIndex)(i, rows);\n    (0, _array.validateIndex)(j, columns);\n\n    // find value index\n    var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);\n    // check k is prior to next column k and it is in the correct row\n    if (k < this._ptr[j + 1] && this._index[k] === i) {\n      // check value != 0\n      if (!eq(v, zero)) {\n        // update value\n        this._values[k] = v;\n      } else {\n        // remove value from matrix\n        _remove(k, j, this._values, this._index, this._ptr);\n      }\n    } else {\n      if (!eq(v, zero)) {\n        // insert value @ (i, j)\n        _insert(k, i, j, v, this._values, this._index, this._ptr);\n      }\n    }\n    return this;\n  };\n  function _getValueIndex(i, top, bottom, index) {\n    // check row is on the bottom side\n    if (bottom - top === 0) {\n      return bottom;\n    }\n    // loop rows [top, bottom[\n    for (var r = top; r < bottom; r++) {\n      // check we found value index\n      if (index[r] === i) {\n        return r;\n      }\n    }\n    // we did not find row\n    return top;\n  }\n  function _remove(k, j, values, index, ptr) {\n    // remove value @ k\n    values.splice(k, 1);\n    index.splice(k, 1);\n    // update pointers\n    for (var x = j + 1; x < ptr.length; x++) {\n      ptr[x]--;\n    }\n  }\n  function _insert(k, i, j, v, values, index, ptr) {\n    // insert value\n    values.splice(k, 0, v);\n    // update row for k\n    index.splice(k, 0, i);\n    // update column pointers\n    for (var x = j + 1; x < ptr.length; x++) {\n      ptr[x]++;\n    }\n  }\n\n  /**\n   * Resize the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (resize in place).\n   *\n   * @memberof SparseMatrix\n   * @param {number[] | Matrix} size  The new size the matrix should have.\n   *                                  Since sparse matrices are always two-dimensional,\n   *                                  size must be two numbers in either an array or a matrix\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries.\n   *                                  If not provided, the matrix elements will\n   *                                  be filled with zeros.\n   * @param {boolean} [copy]          Return a resized copy of the matrix\n   *\n   * @return {Matrix}                 The resized matrix\n   */\n  SparseMatrix.prototype.resize = function (size, defaultValue, copy) {\n    // validate arguments\n    if (!(0, _is.isCollection)(size)) {\n      throw new TypeError('Array or Matrix expected');\n    }\n\n    // SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector\n    var sizeArray = size.valueOf().map(function (value) {\n      return Array.isArray(value) && value.length === 1 ? value[0] : value;\n    });\n    if (sizeArray.length !== 2) {\n      throw new Error('Only two dimensions matrix are supported');\n    }\n\n    // check sizes\n    sizeArray.forEach(function (value) {\n      if (!(0, _is.isNumber)(value) || !(0, _number.isInteger)(value) || value < 0) {\n        throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + (0, _string.format)(sizeArray) + ')');\n      }\n    });\n\n    // matrix to resize\n    var m = copy ? this.clone() : this;\n    // resize matrix\n    return _resize(m, sizeArray[0], sizeArray[1], defaultValue);\n  };\n  function _resize(matrix, rows, columns, defaultValue) {\n    // value to insert at the time of growing matrix\n    var value = defaultValue || 0;\n\n    // equal signature to use\n    var eq = equalScalar;\n    // zero value\n    var zero = 0;\n    if ((0, _is.isString)(matrix._datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar;\n      // convert 0 to the same datatype\n      zero = typed.convert(0, matrix._datatype);\n      // convert value to the same datatype\n      value = typed.convert(value, matrix._datatype);\n    }\n\n    // should we insert the value?\n    var ins = !eq(value, zero);\n\n    // old columns and rows\n    var r = matrix._size[0];\n    var c = matrix._size[1];\n    var i, j, k;\n\n    // check we need to increase columns\n    if (columns > c) {\n      // loop new columns\n      for (j = c; j < columns; j++) {\n        // update matrix._ptr for current column\n        matrix._ptr[j] = matrix._values.length;\n        // check we need to insert matrix._values\n        if (ins) {\n          // loop rows\n          for (i = 0; i < r; i++) {\n            // add new matrix._values\n            matrix._values.push(value);\n            // update matrix._index\n            matrix._index.push(i);\n          }\n        }\n      }\n      // store number of matrix._values in matrix._ptr\n      matrix._ptr[columns] = matrix._values.length;\n    } else if (columns < c) {\n      // truncate matrix._ptr\n      matrix._ptr.splice(columns + 1, c - columns);\n      // truncate matrix._values and matrix._index\n      matrix._values.splice(matrix._ptr[columns], matrix._values.length);\n      matrix._index.splice(matrix._ptr[columns], matrix._index.length);\n    }\n    // update columns\n    c = columns;\n\n    // check we need to increase rows\n    if (rows > r) {\n      // check we have to insert values\n      if (ins) {\n        // inserts\n        var n = 0;\n        // loop columns\n        for (j = 0; j < c; j++) {\n          // update matrix._ptr for current column\n          matrix._ptr[j] = matrix._ptr[j] + n;\n          // where to insert matrix._values\n          k = matrix._ptr[j + 1] + n;\n          // pointer\n          var p = 0;\n          // loop new rows, initialize pointer\n          for (i = r; i < rows; i++, p++) {\n            // add value\n            matrix._values.splice(k + p, 0, value);\n            // update matrix._index\n            matrix._index.splice(k + p, 0, i);\n            // increment inserts\n            n++;\n          }\n        }\n        // store number of matrix._values in matrix._ptr\n        matrix._ptr[c] = matrix._values.length;\n      }\n    } else if (rows < r) {\n      // deletes\n      var d = 0;\n      // loop columns\n      for (j = 0; j < c; j++) {\n        // update matrix._ptr for current column\n        matrix._ptr[j] = matrix._ptr[j] - d;\n        // where matrix._values start for next column\n        var k0 = matrix._ptr[j];\n        var k1 = matrix._ptr[j + 1] - d;\n        // loop matrix._index\n        for (k = k0; k < k1; k++) {\n          // row\n          i = matrix._index[k];\n          // check we need to delete value and matrix._index\n          if (i > rows - 1) {\n            // remove value\n            matrix._values.splice(k, 1);\n            // remove item from matrix._index\n            matrix._index.splice(k, 1);\n            // increase deletes\n            d++;\n          }\n        }\n      }\n      // update matrix._ptr for current column\n      matrix._ptr[j] = matrix._values.length;\n    }\n    // update matrix._size\n    matrix._size[0] = rows;\n    matrix._size[1] = columns;\n    // return matrix\n    return matrix;\n  }\n\n  /**\n   * Reshape the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (reshape in place).\n   *\n   * NOTE: This might be better suited to copy by default, instead of modifying\n   *       in place. For now, it operates in place to remain consistent with\n   *       resize().\n   *\n   * @memberof SparseMatrix\n   * @param {number[]} sizes          The new size the matrix should have.\n   *                                  Since sparse matrices are always two-dimensional,\n   *                                  size must be two numbers in either an array or a matrix\n   * @param {boolean} [copy]          Return a reshaped copy of the matrix\n   *\n   * @return {Matrix}                 The reshaped matrix\n   */\n  SparseMatrix.prototype.reshape = function (sizes, copy) {\n    // validate arguments\n    if (!(0, _is.isArray)(sizes)) {\n      throw new TypeError('Array expected');\n    }\n    if (sizes.length !== 2) {\n      throw new Error('Sparse matrices can only be reshaped in two dimensions');\n    }\n\n    // check sizes\n    sizes.forEach(function (value) {\n      if (!(0, _is.isNumber)(value) || !(0, _number.isInteger)(value) || value <= -2 || value === 0) {\n        throw new TypeError('Invalid size, must contain positive integers or -1 ' + '(size: ' + (0, _string.format)(sizes) + ')');\n      }\n    });\n    var currentLength = this._size[0] * this._size[1];\n    sizes = (0, _array.processSizesWildcard)(sizes, currentLength);\n    var newLength = sizes[0] * sizes[1];\n\n    // m * n must not change\n    if (currentLength !== newLength) {\n      throw new Error('Reshaping sparse matrix will result in the wrong number of elements');\n    }\n\n    // matrix to reshape\n    var m = copy ? this.clone() : this;\n\n    // return unchanged if the same shape\n    if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {\n      return m;\n    }\n\n    // Convert to COO format (generate a column index)\n    var colIndex = [];\n    for (var i = 0; i < m._ptr.length; i++) {\n      for (var j = 0; j < m._ptr[i + 1] - m._ptr[i]; j++) {\n        colIndex.push(i);\n      }\n    }\n\n    // Clone the values array\n    var values = m._values.slice();\n\n    // Clone the row index array\n    var rowIndex = m._index.slice();\n\n    // Transform the (row, column) indices\n    for (var _i = 0; _i < m._index.length; _i++) {\n      var r1 = rowIndex[_i];\n      var c1 = colIndex[_i];\n      var flat = r1 * m._size[1] + c1;\n      colIndex[_i] = flat % sizes[1];\n      rowIndex[_i] = Math.floor(flat / sizes[1]);\n    }\n\n    // Now reshaping is supposed to preserve the row-major order, BUT these sparse matrices are stored\n    // in column-major order, so we have to reorder the value array now. One option is to use a multisort,\n    // sorting several arrays based on some other array.\n\n    // OR, we could easily just:\n\n    // 1. Remove all values from the matrix\n    m._values.length = 0;\n    m._index.length = 0;\n    m._ptr.length = sizes[1] + 1;\n    m._size = sizes.slice();\n    for (var _i2 = 0; _i2 < m._ptr.length; _i2++) {\n      m._ptr[_i2] = 0;\n    }\n\n    // 2. Re-insert all elements in the proper order (simplified code from SparseMatrix.prototype.set)\n    // This step is probably the most time-consuming\n    for (var h = 0; h < values.length; h++) {\n      var _i3 = rowIndex[h];\n      var _j = colIndex[h];\n      var v = values[h];\n      var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);\n      _insert(k, _i3, _j, v, m._values, m._index, m._ptr);\n    }\n\n    // The value indices are inserted out of order, but apparently that's... still OK?\n\n    return m;\n  };\n\n  /**\n   * Create a clone of the matrix\n   * @memberof SparseMatrix\n   * @return {SparseMatrix} clone\n   */\n  SparseMatrix.prototype.clone = function () {\n    var m = new SparseMatrix({\n      values: this._values ? (0, _object.clone)(this._values) : undefined,\n      index: (0, _object.clone)(this._index),\n      ptr: (0, _object.clone)(this._ptr),\n      size: (0, _object.clone)(this._size),\n      datatype: this._datatype\n    });\n    return m;\n  };\n\n  /**\n   * Retrieve the size of the matrix.\n   * @memberof SparseMatrix\n   * @returns {number[]} size\n   */\n  SparseMatrix.prototype.size = function () {\n    return this._size.slice(0); // copy the Array\n  };\n\n  /**\n   * Create a new matrix with the results of the callback function executed on\n   * each entry of the matrix.\n   * @memberof SparseMatrix\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\n   *\n   * @return {SparseMatrix} matrix\n   */\n  SparseMatrix.prototype.map = function (callback, skipZeros) {\n    // check it is a pattern matrix\n    if (!this._values) {\n      throw new Error('Cannot invoke map on a Pattern only matrix');\n    }\n    // matrix instance\n    var me = this;\n    // rows and columns\n    var rows = this._size[0];\n    var columns = this._size[1];\n    // invoke callback\n    var args = (0, _function.maxArgumentCount)(callback);\n    var invoke = function invoke(v, i, j) {\n      // invoke callback\n      if (args === 1) return callback(v);\n      if (args === 2) return callback(v, [i, j]);\n      return callback(v, [i, j], me);\n    };\n    // invoke _map\n    return _map(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);\n  };\n\n  /**\n   * Create a new matrix with the results of the callback function executed on the interval\n   * [minRow..maxRow, minColumn..maxColumn].\n   */\n  function _map(matrix, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {\n    // result arrays\n    var values = [];\n    var index = [];\n    var ptr = [];\n\n    // equal signature to use\n    var eq = equalScalar;\n    // zero value\n    var zero = 0;\n    if ((0, _is.isString)(matrix._datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar;\n      // convert 0 to the same datatype\n      zero = typed.convert(0, matrix._datatype);\n    }\n\n    // invoke callback\n    var invoke = function invoke(v, x, y) {\n      // invoke callback\n      v = callback(v, x, y);\n      // check value != 0\n      if (!eq(v, zero)) {\n        // store value\n        values.push(v);\n        // index\n        index.push(x);\n      }\n    };\n    // loop columns\n    for (var j = minColumn; j <= maxColumn; j++) {\n      // store pointer to values index\n      ptr.push(values.length);\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = matrix._ptr[j];\n      var k1 = matrix._ptr[j + 1];\n      if (skipZeros) {\n        // loop k within [k0, k1[\n        for (var k = k0; k < k1; k++) {\n          // row index\n          var i = matrix._index[k];\n          // check i is in range\n          if (i >= minRow && i <= maxRow) {\n            // value @ k\n            invoke(matrix._values[k], i - minRow, j - minColumn);\n          }\n        }\n      } else {\n        // create a cache holding all defined values\n        var _values = {};\n        for (var _k = k0; _k < k1; _k++) {\n          var _i4 = matrix._index[_k];\n          _values[_i4] = matrix._values[_k];\n        }\n\n        // loop over all rows (indexes can be unordered so we can't use that),\n        // and either read the value or zero\n        for (var _i5 = minRow; _i5 <= maxRow; _i5++) {\n          var value = _i5 in _values ? _values[_i5] : 0;\n          invoke(value, _i5 - minRow, j - minColumn);\n        }\n      }\n    }\n\n    // store number of values in ptr\n    ptr.push(values.length);\n    // return sparse matrix\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: [maxRow - minRow + 1, maxColumn - minColumn + 1]\n    });\n  }\n\n  /**\n   * Execute a callback function on each entry of the matrix.\n   * @memberof SparseMatrix\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\n   *                              If false, the indices are guaranteed to be in order,\n   *                              if true, the indices can be unordered.\n   */\n  SparseMatrix.prototype.forEach = function (callback, skipZeros) {\n    // check it is a pattern matrix\n    if (!this._values) {\n      throw new Error('Cannot invoke forEach on a Pattern only matrix');\n    }\n    // matrix instance\n    var me = this;\n    // rows and columns\n    var rows = this._size[0];\n    var columns = this._size[1];\n    // loop columns\n    for (var j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = this._ptr[j];\n      var k1 = this._ptr[j + 1];\n      if (skipZeros) {\n        // loop k within [k0, k1[\n        for (var k = k0; k < k1; k++) {\n          // row index\n          var i = this._index[k];\n\n          // value @ k\n          callback(this._values[k], [i, j], me);\n        }\n      } else {\n        // create a cache holding all defined values\n        var values = {};\n        for (var _k2 = k0; _k2 < k1; _k2++) {\n          var _i6 = this._index[_k2];\n          values[_i6] = this._values[_k2];\n        }\n\n        // loop over all rows (indexes can be unordered so we can't use that),\n        // and either read the value or zero\n        for (var _i7 = 0; _i7 < rows; _i7++) {\n          var value = _i7 in values ? values[_i7] : 0;\n          callback(value, [_i7, j], me);\n        }\n      }\n    }\n  };\n\n  /**\n   * Iterate over the matrix elements, skipping zeros\n   * @return {Iterable<{ value, index: number[] }>}\n   */\n  SparseMatrix.prototype[Symbol.iterator] = /*#__PURE__*/_regenerator[\"default\"].mark(function _callee() {\n    var columns, j, k0, k1, k, i;\n    return _regenerator[\"default\"].wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (this._values) {\n              _context.next = 2;\n              break;\n            }\n            throw new Error('Cannot iterate a Pattern only matrix');\n          case 2:\n            columns = this._size[1];\n            j = 0;\n          case 4:\n            if (!(j < columns)) {\n              _context.next = 18;\n              break;\n            }\n            k0 = this._ptr[j];\n            k1 = this._ptr[j + 1];\n            k = k0;\n          case 8:\n            if (!(k < k1)) {\n              _context.next = 15;\n              break;\n            }\n            // row index\n            i = this._index[k];\n            _context.next = 12;\n            return {\n              value: this._values[k],\n              index: [i, j]\n            };\n          case 12:\n            k++;\n            _context.next = 8;\n            break;\n          case 15:\n            j++;\n            _context.next = 4;\n            break;\n          case 18:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  });\n\n  /**\n   * Create an Array with a copy of the data of the SparseMatrix\n   * @memberof SparseMatrix\n   * @returns {Array} array\n   */\n  SparseMatrix.prototype.toArray = function () {\n    return _toArray(this._values, this._index, this._ptr, this._size, true);\n  };\n\n  /**\n   * Get the primitive value of the SparseMatrix: a two dimensions array\n   * @memberof SparseMatrix\n   * @returns {Array} array\n   */\n  SparseMatrix.prototype.valueOf = function () {\n    return _toArray(this._values, this._index, this._ptr, this._size, false);\n  };\n  function _toArray(values, index, ptr, size, copy) {\n    // rows and columns\n    var rows = size[0];\n    var columns = size[1];\n    // result\n    var a = [];\n    // vars\n    var i, j;\n    // initialize array\n    for (i = 0; i < rows; i++) {\n      a[i] = [];\n      for (j = 0; j < columns; j++) {\n        a[i][j] = 0;\n      }\n    }\n\n    // loop columns\n    for (j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = ptr[j];\n      var k1 = ptr[j + 1];\n      // loop k within [k0, k1[\n      for (var k = k0; k < k1; k++) {\n        // row index\n        i = index[k];\n        // set value (use one for pattern matrix)\n        a[i][j] = values ? copy ? (0, _object.clone)(values[k]) : values[k] : 1;\n      }\n    }\n    return a;\n  }\n\n  /**\n   * Get a string representation of the matrix, with optional formatting options.\n   * @memberof SparseMatrix\n   * @param {Object | number | Function} [options]  Formatting options. See\n   *                                                lib/utils/number:format for a\n   *                                                description of the available\n   *                                                options.\n   * @returns {string} str\n   */\n  SparseMatrix.prototype.format = function (options) {\n    // rows and columns\n    var rows = this._size[0];\n    var columns = this._size[1];\n    // density\n    var density = this.density();\n    // rows & columns\n    var str = 'Sparse Matrix [' + (0, _string.format)(rows, options) + ' x ' + (0, _string.format)(columns, options) + '] density: ' + (0, _string.format)(density, options) + '\\n';\n    // loop columns\n    for (var j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = this._ptr[j];\n      var k1 = this._ptr[j + 1];\n      // loop k within [k0, k1[\n      for (var k = k0; k < k1; k++) {\n        // row index\n        var i = this._index[k];\n        // append value\n        str += '\\n    (' + (0, _string.format)(i, options) + ', ' + (0, _string.format)(j, options) + ') ==> ' + (this._values ? (0, _string.format)(this._values[k], options) : 'X');\n      }\n    }\n    return str;\n  };\n\n  /**\n   * Get a string representation of the matrix\n   * @memberof SparseMatrix\n   * @returns {string} str\n   */\n  SparseMatrix.prototype.toString = function () {\n    return (0, _string.format)(this.toArray());\n  };\n\n  /**\n   * Get a JSON representation of the matrix\n   * @memberof SparseMatrix\n   * @returns {Object}\n   */\n  SparseMatrix.prototype.toJSON = function () {\n    return {\n      mathjs: 'SparseMatrix',\n      values: this._values,\n      index: this._index,\n      ptr: this._ptr,\n      size: this._size,\n      datatype: this._datatype\n    };\n  };\n\n  /**\n   * Get the kth Matrix diagonal.\n   *\n   * @memberof SparseMatrix\n   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.\n   *\n   * @returns {Matrix}                     The matrix vector with the diagonal values.\n   */\n  SparseMatrix.prototype.diagonal = function (k) {\n    // validate k if any\n    if (k) {\n      // convert BigNumber to a number\n      if ((0, _is.isBigNumber)(k)) {\n        k = k.toNumber();\n      }\n      // is must be an integer\n      if (!(0, _is.isNumber)(k) || !(0, _number.isInteger)(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    }\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0;\n\n    // rows & columns\n    var rows = this._size[0];\n    var columns = this._size[1];\n\n    // number diagonal values\n    var n = Math.min(rows - kSub, columns - kSuper);\n\n    // diagonal arrays\n    var values = [];\n    var index = [];\n    var ptr = [];\n    // initial ptr value\n    ptr[0] = 0;\n    // loop columns\n    for (var j = kSuper; j < columns && values.length < n; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = this._ptr[j];\n      var k1 = this._ptr[j + 1];\n      // loop x within [k0, k1[\n      for (var x = k0; x < k1; x++) {\n        // row index\n        var i = this._index[x];\n        // check row\n        if (i === j - kSuper + kSub) {\n          // value on this column\n          values.push(this._values[x]);\n          // store row\n          index[values.length - 1] = i - kSub;\n          // exit loop\n          break;\n        }\n      }\n    }\n    // close ptr\n    ptr.push(values.length);\n    // return matrix\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: [n, 1]\n    });\n  };\n\n  /**\n   * Generate a matrix from a JSON object\n   * @memberof SparseMatrix\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"SparseMatrix\", \"values\": [], \"index\": [], \"ptr\": [], \"size\": []}`,\n   *                       where mathjs is optional\n   * @returns {SparseMatrix}\n   */\n  SparseMatrix.fromJSON = function (json) {\n    return new SparseMatrix(json);\n  };\n\n  /**\n   * Create a diagonal matrix.\n   *\n   * @memberof SparseMatrix\n   * @param {Array} size                       The matrix size.\n   * @param {number | Array | Matrix } value   The values for the diagonal.\n   * @param {number | BigNumber} [k=0]         The kth diagonal where the vector will be filled in.\n   * @param {number} [defaultValue]            The default value for non-diagonal\n   * @param {string} [datatype]                The Matrix datatype, values must be of this datatype.\n   *\n   * @returns {SparseMatrix}\n   */\n  SparseMatrix.diagonal = function (size, value, k, defaultValue, datatype) {\n    if (!(0, _is.isArray)(size)) {\n      throw new TypeError('Array expected, size parameter');\n    }\n    if (size.length !== 2) {\n      throw new Error('Only two dimensions matrix are supported');\n    }\n\n    // map size & validate\n    size = size.map(function (s) {\n      // check it is a big number\n      if ((0, _is.isBigNumber)(s)) {\n        // convert it\n        s = s.toNumber();\n      }\n      // validate arguments\n      if (!(0, _is.isNumber)(s) || !(0, _number.isInteger)(s) || s < 1) {\n        throw new Error('Size values must be positive integers');\n      }\n      return s;\n    });\n\n    // validate k if any\n    if (k) {\n      // convert BigNumber to a number\n      if ((0, _is.isBigNumber)(k)) {\n        k = k.toNumber();\n      }\n      // is must be an integer\n      if (!(0, _is.isNumber)(k) || !(0, _number.isInteger)(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    }\n\n    // equal signature to use\n    var eq = equalScalar;\n    // zero value\n    var zero = 0;\n    if ((0, _is.isString)(datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar;\n      // convert 0 to the same datatype\n      zero = typed.convert(0, datatype);\n    }\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0;\n\n    // rows and columns\n    var rows = size[0];\n    var columns = size[1];\n\n    // number of non-zero items\n    var n = Math.min(rows - kSub, columns - kSuper);\n\n    // value extraction function\n    var _value;\n\n    // check value\n    if ((0, _is.isArray)(value)) {\n      // validate array\n      if (value.length !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid value array length');\n      }\n      // define function\n      _value = function _value(i) {\n        // return value @ i\n        return value[i];\n      };\n    } else if ((0, _is.isMatrix)(value)) {\n      // matrix size\n      var ms = value.size();\n      // validate matrix\n      if (ms.length !== 1 || ms[0] !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid matrix length');\n      }\n      // define function\n      _value = function _value(i) {\n        // return value @ i\n        return value.get([i]);\n      };\n    } else {\n      // define function\n      _value = function _value() {\n        // return value\n        return value;\n      };\n    }\n\n    // create arrays\n    var values = [];\n    var index = [];\n    var ptr = [];\n\n    // loop items\n    for (var j = 0; j < columns; j++) {\n      // number of rows with value\n      ptr.push(values.length);\n      // diagonal index\n      var i = j - kSuper;\n      // check we need to set diagonal value\n      if (i >= 0 && i < n) {\n        // get value @ i\n        var v = _value(i);\n        // check for zero\n        if (!eq(v, zero)) {\n          // column\n          index.push(i + kSub);\n          // add value\n          values.push(v);\n        }\n      }\n    }\n    // last value should be number of values\n    ptr.push(values.length);\n    // create SparseMatrix\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: [rows, columns]\n    });\n  };\n\n  /**\n   * Swap rows i and j in Matrix.\n   *\n   * @memberof SparseMatrix\n   * @param {number} i       Matrix row index 1\n   * @param {number} j       Matrix row index 2\n   *\n   * @return {Matrix}        The matrix reference\n   */\n  SparseMatrix.prototype.swapRows = function (i, j) {\n    // check index\n    if (!(0, _is.isNumber)(i) || !(0, _number.isInteger)(i) || !(0, _is.isNumber)(j) || !(0, _number.isInteger)(j)) {\n      throw new Error('Row index must be positive integers');\n    }\n    // check dimensions\n    if (this._size.length !== 2) {\n      throw new Error('Only two dimensional matrix is supported');\n    }\n    // validate index\n    (0, _array.validateIndex)(i, this._size[0]);\n    (0, _array.validateIndex)(j, this._size[0]);\n\n    // swap rows\n    SparseMatrix._swapRows(i, j, this._size[1], this._values, this._index, this._ptr);\n    // return current instance\n    return this;\n  };\n\n  /**\n   * Loop rows with data in column j.\n   *\n   * @param {number} j            Column\n   * @param {Array} values        Matrix values\n   * @param {Array} index         Matrix row indeces\n   * @param {Array} ptr           Matrix column pointers\n   * @param {Function} callback   Callback function invoked for every row in column j\n   */\n  SparseMatrix._forEachRow = function (j, values, index, ptr, callback) {\n    // indeces for column j\n    var k0 = ptr[j];\n    var k1 = ptr[j + 1];\n    // loop\n    for (var k = k0; k < k1; k++) {\n      // invoke callback\n      callback(index[k], values[k]);\n    }\n  };\n\n  /**\n   * Swap rows x and y in Sparse Matrix data structures.\n   *\n   * @param {number} x         Matrix row index 1\n   * @param {number} y         Matrix row index 2\n   * @param {number} columns   Number of columns in matrix\n   * @param {Array} values     Matrix values\n   * @param {Array} index      Matrix row indeces\n   * @param {Array} ptr        Matrix column pointers\n   */\n  SparseMatrix._swapRows = function (x, y, columns, values, index, ptr) {\n    // loop columns\n    for (var j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = ptr[j];\n      var k1 = ptr[j + 1];\n      // find value index @ x\n      var kx = _getValueIndex(x, k0, k1, index);\n      // find value index @ x\n      var ky = _getValueIndex(y, k0, k1, index);\n      // check both rows exist in matrix\n      if (kx < k1 && ky < k1 && index[kx] === x && index[ky] === y) {\n        // swap values (check for pattern matrix)\n        if (values) {\n          var v = values[kx];\n          values[kx] = values[ky];\n          values[ky] = v;\n        }\n        // next column\n        continue;\n      }\n      // check x row exist & no y row\n      if (kx < k1 && index[kx] === x && (ky >= k1 || index[ky] !== y)) {\n        // value @ x (check for pattern matrix)\n        var vx = values ? values[kx] : undefined;\n        // insert value @ y\n        index.splice(ky, 0, y);\n        if (values) {\n          values.splice(ky, 0, vx);\n        }\n        // remove value @ x (adjust array index if needed)\n        index.splice(ky <= kx ? kx + 1 : kx, 1);\n        if (values) {\n          values.splice(ky <= kx ? kx + 1 : kx, 1);\n        }\n        // next column\n        continue;\n      }\n      // check y row exist & no x row\n      if (ky < k1 && index[ky] === y && (kx >= k1 || index[kx] !== x)) {\n        // value @ y (check for pattern matrix)\n        var vy = values ? values[ky] : undefined;\n        // insert value @ x\n        index.splice(kx, 0, x);\n        if (values) {\n          values.splice(kx, 0, vy);\n        }\n        // remove value @ y (adjust array index if needed)\n        index.splice(kx <= ky ? ky + 1 : ky, 1);\n        if (values) {\n          values.splice(kx <= ky ? ky + 1 : ky, 1);\n        }\n      }\n    }\n  };\n  return SparseMatrix;\n}, {\n  isClass: true\n});\nexports.createSparseMatrixClass = createSparseMatrixClass;","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","createSparseMatrixClass","_regenerator","_is","_number","_string","_object","_array","_factory","_DimensionError","_function","name","dependencies","factory","_ref","typed","equalScalar","Matrix","SparseMatrix","data","datatype","SyntaxError","isString","Error","isMatrix","_createFromMatrix","isArray","index","ptr","size","_values","values","_index","_ptr","_size","_datatype","_createFromArray","TypeError","typeOf","matrix","source","type","clone","undefined","valueOf","rows","length","columns","eq","zero","find","convert","j","push","i","row","v","prototype","createSparseMatrix","constructor","isSparseMatrix","getDataType","getArrayDataType","storage","create","density","subset","replacement","defaultValue","arguments","_getsubset","_setsubset","idx","isIndex","isScalar","get","min","DimensionError","ii","k","kk","max","validateIndex","mvalues","mindex","mptr","dimension","w","pv","forEach","r","submatrix","iSize","sSize","toArray","arraySize","set","outer","unsqueeze","deepStrictEqual","range","dataIndex","subIndex","firstDimensionRange","secondDimensionRange","firstDataIndex","firstSubIndex","secondDataIndex","secondSubIndex","_getValueIndex","_resize","Math","_remove","_insert","top","bottom","splice","x","resize","copy","isCollection","sizeArray","map","Array","isNumber","isInteger","format","m","ins","c","n","p","d","k0","k1","reshape","sizes","currentLength","processSizesWildcard","newLength","colIndex","slice","rowIndex","_i","r1","c1","flat","floor","_i2","h","_i3","_j","callback","skipZeros","me","args","maxArgumentCount","invoke","_map","minRow","maxRow","minColumn","maxColumn","y","_k","_i4","_i5","_k2","_i6","_i7","Symbol","iterator","mark","_callee","wrap","_callee$","_context","prev","next","stop","_toArray","a","options","str","toString","toJSON","mathjs","diagonal","isBigNumber","toNumber","kSuper","kSub","fromJSON","json","s","_value","ms","swapRows","_swapRows","_forEachRow","kx","ky","vx","vy","isClass"],"sources":["C:/Users/Admin/Desktop/React-Web-main/node_modules/mathjs/lib/cjs/type/matrix/SparseMatrix.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSparseMatrixClass = void 0;\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\nvar _is = require(\"../../utils/is.js\");\nvar _number = require(\"../../utils/number.js\");\nvar _string = require(\"../../utils/string.js\");\nvar _object = require(\"../../utils/object.js\");\nvar _array = require(\"../../utils/array.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar _DimensionError = require(\"../../error/DimensionError.js\");\nvar _function = require(\"../../utils/function.js\");\nvar name = 'SparseMatrix';\nvar dependencies = ['typed', 'equalScalar', 'Matrix'];\nvar createSparseMatrixClass = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n    equalScalar = _ref.equalScalar,\n    Matrix = _ref.Matrix;\n  /**\n   * Sparse Matrix implementation. This type implements\n   * a [Compressed Column Storage](https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_(CSC_or_CCS))\n   * format for two-dimensional sparse matrices.\n   * @class SparseMatrix\n   */\n  function SparseMatrix(data, datatype) {\n    if (!(this instanceof SparseMatrix)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n    if (datatype && !(0, _is.isString)(datatype)) {\n      throw new Error('Invalid datatype: ' + datatype);\n    }\n    if ((0, _is.isMatrix)(data)) {\n      // create from matrix\n      _createFromMatrix(this, data, datatype);\n    } else if (data && (0, _is.isArray)(data.index) && (0, _is.isArray)(data.ptr) && (0, _is.isArray)(data.size)) {\n      // initialize fields\n      this._values = data.values;\n      this._index = data.index;\n      this._ptr = data.ptr;\n      this._size = data.size;\n      this._datatype = datatype || data.datatype;\n    } else if ((0, _is.isArray)(data)) {\n      // create from array\n      _createFromArray(this, data, datatype);\n    } else if (data) {\n      // unsupported type\n      throw new TypeError('Unsupported type of data (' + (0, _is.typeOf)(data) + ')');\n    } else {\n      // nothing provided\n      this._values = [];\n      this._index = [];\n      this._ptr = [0];\n      this._size = [0, 0];\n      this._datatype = datatype;\n    }\n  }\n  function _createFromMatrix(matrix, source, datatype) {\n    // check matrix type\n    if (source.type === 'SparseMatrix') {\n      // clone arrays\n      matrix._values = source._values ? (0, _object.clone)(source._values) : undefined;\n      matrix._index = (0, _object.clone)(source._index);\n      matrix._ptr = (0, _object.clone)(source._ptr);\n      matrix._size = (0, _object.clone)(source._size);\n      matrix._datatype = datatype || source._datatype;\n    } else {\n      // build from matrix data\n      _createFromArray(matrix, source.valueOf(), datatype || source._datatype);\n    }\n  }\n  function _createFromArray(matrix, data, datatype) {\n    // initialize fields\n    matrix._values = [];\n    matrix._index = [];\n    matrix._ptr = [];\n    matrix._datatype = datatype;\n    // discover rows & columns, do not use math.size() to avoid looping array twice\n    var rows = data.length;\n    var columns = 0;\n\n    // equal signature to use\n    var eq = equalScalar;\n    // zero value\n    var zero = 0;\n    if ((0, _is.isString)(datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar;\n      // convert 0 to the same datatype\n      zero = typed.convert(0, datatype);\n    }\n\n    // check we have rows (empty array)\n    if (rows > 0) {\n      // column index\n      var j = 0;\n      do {\n        // store pointer to values index\n        matrix._ptr.push(matrix._index.length);\n        // loop rows\n        for (var i = 0; i < rows; i++) {\n          // current row\n          var row = data[i];\n          // check row is an array\n          if ((0, _is.isArray)(row)) {\n            // update columns if needed (only on first column)\n            if (j === 0 && columns < row.length) {\n              columns = row.length;\n            }\n            // check row has column\n            if (j < row.length) {\n              // value\n              var v = row[j];\n              // check value != 0\n              if (!eq(v, zero)) {\n                // store value\n                matrix._values.push(v);\n                // index\n                matrix._index.push(i);\n              }\n            }\n          } else {\n            // update columns if needed (only on first column)\n            if (j === 0 && columns < 1) {\n              columns = 1;\n            }\n            // check value != 0 (row is a scalar)\n            if (!eq(row, zero)) {\n              // store value\n              matrix._values.push(row);\n              // index\n              matrix._index.push(i);\n            }\n          }\n        }\n        // increment index\n        j++;\n      } while (j < columns);\n    }\n    // store number of values in ptr\n    matrix._ptr.push(matrix._index.length);\n    // size\n    matrix._size = [rows, columns];\n  }\n  SparseMatrix.prototype = new Matrix();\n\n  /**\n   * Create a new SparseMatrix\n   */\n  SparseMatrix.prototype.createSparseMatrix = function (data, datatype) {\n    return new SparseMatrix(data, datatype);\n  };\n\n  /**\n   * Attach type information\n   */\n  Object.defineProperty(SparseMatrix, 'name', {\n    value: 'SparseMatrix'\n  });\n  SparseMatrix.prototype.constructor = SparseMatrix;\n  SparseMatrix.prototype.type = 'SparseMatrix';\n  SparseMatrix.prototype.isSparseMatrix = true;\n\n  /**\n   * Get the matrix type\n   *\n   * Usage:\n   *    const matrixType = matrix.getDataType()  // retrieves the matrix type\n   *\n   * @memberOf SparseMatrix\n   * @return {string}   type information; if multiple types are found from the Matrix, it will return \"mixed\"\n   */\n  SparseMatrix.prototype.getDataType = function () {\n    return (0, _array.getArrayDataType)(this._values, _is.typeOf);\n  };\n\n  /**\n   * Get the storage format used by the matrix.\n   *\n   * Usage:\n   *     const format = matrix.storage()   // retrieve storage format\n   *\n   * @memberof SparseMatrix\n   * @return {string}           The storage format.\n   */\n  SparseMatrix.prototype.storage = function () {\n    return 'sparse';\n  };\n\n  /**\n   * Get the datatype of the data stored in the matrix.\n   *\n   * Usage:\n   *     const format = matrix.datatype()    // retrieve matrix datatype\n   *\n   * @memberof SparseMatrix\n   * @return {string}           The datatype.\n   */\n  SparseMatrix.prototype.datatype = function () {\n    return this._datatype;\n  };\n\n  /**\n   * Create a new SparseMatrix\n   * @memberof SparseMatrix\n   * @param {Array} data\n   * @param {string} [datatype]\n   */\n  SparseMatrix.prototype.create = function (data, datatype) {\n    return new SparseMatrix(data, datatype);\n  };\n\n  /**\n   * Get the matrix density.\n   *\n   * Usage:\n   *     const density = matrix.density()                   // retrieve matrix density\n   *\n   * @memberof SparseMatrix\n   * @return {number}           The matrix density.\n   */\n  SparseMatrix.prototype.density = function () {\n    // rows & columns\n    var rows = this._size[0];\n    var columns = this._size[1];\n    // calculate density\n    return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;\n  };\n\n  /**\n   * Get a subset of the matrix, or replace a subset of the matrix.\n   *\n   * Usage:\n   *     const subset = matrix.subset(index)               // retrieve subset\n   *     const value = matrix.subset(index, replacement)   // replace subset\n   *\n   * @memberof SparseMatrix\n   * @param {Index} index\n   * @param {Array | Matrix | *} [replacement]\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be filled with zeros.\n   */\n  SparseMatrix.prototype.subset = function (index, replacement, defaultValue) {\n    // check it is a pattern matrix\n    if (!this._values) {\n      throw new Error('Cannot invoke subset on a Pattern only matrix');\n    }\n\n    // check arguments\n    switch (arguments.length) {\n      case 1:\n        return _getsubset(this, index);\n\n      // intentional fall through\n      case 2:\n      case 3:\n        return _setsubset(this, index, replacement, defaultValue);\n      default:\n        throw new SyntaxError('Wrong number of arguments');\n    }\n  };\n  function _getsubset(matrix, idx) {\n    // check idx\n    if (!(0, _is.isIndex)(idx)) {\n      throw new TypeError('Invalid index');\n    }\n    var isScalar = idx.isScalar();\n    if (isScalar) {\n      // return a scalar\n      return matrix.get(idx.min());\n    }\n    // validate dimensions\n    var size = idx.size();\n    if (size.length !== matrix._size.length) {\n      throw new _DimensionError.DimensionError(size.length, matrix._size.length);\n    }\n\n    // vars\n    var i, ii, k, kk;\n\n    // validate if any of the ranges in the index is out of range\n    var min = idx.min();\n    var max = idx.max();\n    for (i = 0, ii = matrix._size.length; i < ii; i++) {\n      (0, _array.validateIndex)(min[i], matrix._size[i]);\n      (0, _array.validateIndex)(max[i], matrix._size[i]);\n    }\n\n    // matrix arrays\n    var mvalues = matrix._values;\n    var mindex = matrix._index;\n    var mptr = matrix._ptr;\n\n    // rows & columns dimensions for result matrix\n    var rows = idx.dimension(0);\n    var columns = idx.dimension(1);\n\n    // workspace & permutation vector\n    var w = [];\n    var pv = [];\n\n    // loop rows in resulting matrix\n    rows.forEach(function (i, r) {\n      // update permutation vector\n      pv[i] = r[0];\n      // mark i in workspace\n      w[i] = true;\n    });\n\n    // result matrix arrays\n    var values = mvalues ? [] : undefined;\n    var index = [];\n    var ptr = [];\n\n    // loop columns in result matrix\n    columns.forEach(function (j) {\n      // update ptr\n      ptr.push(index.length);\n      // loop values in column j\n      for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {\n        // row\n        i = mindex[k];\n        // check row is in result matrix\n        if (w[i] === true) {\n          // push index\n          index.push(pv[i]);\n          // check we need to process values\n          if (values) {\n            values.push(mvalues[k]);\n          }\n        }\n      }\n    });\n    // update ptr\n    ptr.push(index.length);\n\n    // return matrix\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: size,\n      datatype: matrix._datatype\n    });\n  }\n  function _setsubset(matrix, index, submatrix, defaultValue) {\n    // check index\n    if (!index || index.isIndex !== true) {\n      throw new TypeError('Invalid index');\n    }\n\n    // get index size and check whether the index contains a single value\n    var iSize = index.size();\n    var isScalar = index.isScalar();\n\n    // calculate the size of the submatrix, and convert it into an Array if needed\n    var sSize;\n    if ((0, _is.isMatrix)(submatrix)) {\n      // submatrix size\n      sSize = submatrix.size();\n      // use array representation\n      submatrix = submatrix.toArray();\n    } else {\n      // get submatrix size (array, scalar)\n      sSize = (0, _array.arraySize)(submatrix);\n    }\n\n    // check index is a scalar\n    if (isScalar) {\n      // verify submatrix is a scalar\n      if (sSize.length !== 0) {\n        throw new TypeError('Scalar expected');\n      }\n      // set value\n      matrix.set(index.min(), submatrix, defaultValue);\n    } else {\n      // validate dimensions, index size must be one or two dimensions\n      if (iSize.length !== 1 && iSize.length !== 2) {\n        throw new _DimensionError.DimensionError(iSize.length, matrix._size.length, '<');\n      }\n\n      // check submatrix and index have the same dimensions\n      if (sSize.length < iSize.length) {\n        // calculate number of missing outer dimensions\n        var i = 0;\n        var outer = 0;\n        while (iSize[i] === 1 && sSize[i] === 1) {\n          i++;\n        }\n        while (iSize[i] === 1) {\n          outer++;\n          i++;\n        }\n        // unsqueeze both outer and inner dimensions\n        submatrix = (0, _array.unsqueeze)(submatrix, iSize.length, outer, sSize);\n      }\n\n      // check whether the size of the submatrix matches the index size\n      if (!(0, _object.deepStrictEqual)(iSize, sSize)) {\n        throw new _DimensionError.DimensionError(iSize, sSize, '>');\n      }\n\n      // insert the sub matrix\n      if (iSize.length === 1) {\n        // if the replacement index only has 1 dimension, go trough each one and set its value\n        var range = index.dimension(0);\n        range.forEach(function (dataIndex, subIndex) {\n          (0, _array.validateIndex)(dataIndex);\n          matrix.set([dataIndex, 0], submatrix[subIndex[0]], defaultValue);\n        });\n      } else {\n        // if the replacement index has 2 dimensions, go through each one and set the value in the correct index\n        var firstDimensionRange = index.dimension(0);\n        var secondDimensionRange = index.dimension(1);\n        firstDimensionRange.forEach(function (firstDataIndex, firstSubIndex) {\n          (0, _array.validateIndex)(firstDataIndex);\n          secondDimensionRange.forEach(function (secondDataIndex, secondSubIndex) {\n            (0, _array.validateIndex)(secondDataIndex);\n            matrix.set([firstDataIndex, secondDataIndex], submatrix[firstSubIndex[0]][secondSubIndex[0]], defaultValue);\n          });\n        });\n      }\n    }\n    return matrix;\n  }\n\n  /**\n   * Get a single element from the matrix.\n   * @memberof SparseMatrix\n   * @param {number[]} index   Zero-based index\n   * @return {*} value\n   */\n  SparseMatrix.prototype.get = function (index) {\n    if (!(0, _is.isArray)(index)) {\n      throw new TypeError('Array expected');\n    }\n    if (index.length !== this._size.length) {\n      throw new _DimensionError.DimensionError(index.length, this._size.length);\n    }\n\n    // check it is a pattern matrix\n    if (!this._values) {\n      throw new Error('Cannot invoke get on a Pattern only matrix');\n    }\n\n    // row and column\n    var i = index[0];\n    var j = index[1];\n\n    // check i, j are valid\n    (0, _array.validateIndex)(i, this._size[0]);\n    (0, _array.validateIndex)(j, this._size[1]);\n\n    // find value index\n    var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);\n    // check k is prior to next column k and it is in the correct row\n    if (k < this._ptr[j + 1] && this._index[k] === i) {\n      return this._values[k];\n    }\n    return 0;\n  };\n\n  /**\n   * Replace a single element in the matrix.\n   * @memberof SparseMatrix\n   * @param {number[]} index   Zero-based index\n   * @param {*} v\n   * @param {*} [defaultValue]        Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be set to zero.\n   * @return {SparseMatrix} self\n   */\n  SparseMatrix.prototype.set = function (index, v, defaultValue) {\n    if (!(0, _is.isArray)(index)) {\n      throw new TypeError('Array expected');\n    }\n    if (index.length !== this._size.length) {\n      throw new _DimensionError.DimensionError(index.length, this._size.length);\n    }\n\n    // check it is a pattern matrix\n    if (!this._values) {\n      throw new Error('Cannot invoke set on a Pattern only matrix');\n    }\n\n    // row and column\n    var i = index[0];\n    var j = index[1];\n\n    // rows & columns\n    var rows = this._size[0];\n    var columns = this._size[1];\n\n    // equal signature to use\n    var eq = equalScalar;\n    // zero value\n    var zero = 0;\n    if ((0, _is.isString)(this._datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [this._datatype, this._datatype]) || equalScalar;\n      // convert 0 to the same datatype\n      zero = typed.convert(0, this._datatype);\n    }\n\n    // check we need to resize matrix\n    if (i > rows - 1 || j > columns - 1) {\n      // resize matrix\n      _resize(this, Math.max(i + 1, rows), Math.max(j + 1, columns), defaultValue);\n      // update rows & columns\n      rows = this._size[0];\n      columns = this._size[1];\n    }\n\n    // check i, j are valid\n    (0, _array.validateIndex)(i, rows);\n    (0, _array.validateIndex)(j, columns);\n\n    // find value index\n    var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);\n    // check k is prior to next column k and it is in the correct row\n    if (k < this._ptr[j + 1] && this._index[k] === i) {\n      // check value != 0\n      if (!eq(v, zero)) {\n        // update value\n        this._values[k] = v;\n      } else {\n        // remove value from matrix\n        _remove(k, j, this._values, this._index, this._ptr);\n      }\n    } else {\n      if (!eq(v, zero)) {\n        // insert value @ (i, j)\n        _insert(k, i, j, v, this._values, this._index, this._ptr);\n      }\n    }\n    return this;\n  };\n  function _getValueIndex(i, top, bottom, index) {\n    // check row is on the bottom side\n    if (bottom - top === 0) {\n      return bottom;\n    }\n    // loop rows [top, bottom[\n    for (var r = top; r < bottom; r++) {\n      // check we found value index\n      if (index[r] === i) {\n        return r;\n      }\n    }\n    // we did not find row\n    return top;\n  }\n  function _remove(k, j, values, index, ptr) {\n    // remove value @ k\n    values.splice(k, 1);\n    index.splice(k, 1);\n    // update pointers\n    for (var x = j + 1; x < ptr.length; x++) {\n      ptr[x]--;\n    }\n  }\n  function _insert(k, i, j, v, values, index, ptr) {\n    // insert value\n    values.splice(k, 0, v);\n    // update row for k\n    index.splice(k, 0, i);\n    // update column pointers\n    for (var x = j + 1; x < ptr.length; x++) {\n      ptr[x]++;\n    }\n  }\n\n  /**\n   * Resize the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (resize in place).\n   *\n   * @memberof SparseMatrix\n   * @param {number[] | Matrix} size  The new size the matrix should have.\n   *                                  Since sparse matrices are always two-dimensional,\n   *                                  size must be two numbers in either an array or a matrix\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries.\n   *                                  If not provided, the matrix elements will\n   *                                  be filled with zeros.\n   * @param {boolean} [copy]          Return a resized copy of the matrix\n   *\n   * @return {Matrix}                 The resized matrix\n   */\n  SparseMatrix.prototype.resize = function (size, defaultValue, copy) {\n    // validate arguments\n    if (!(0, _is.isCollection)(size)) {\n      throw new TypeError('Array or Matrix expected');\n    }\n\n    // SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector\n    var sizeArray = size.valueOf().map(function (value) {\n      return Array.isArray(value) && value.length === 1 ? value[0] : value;\n    });\n    if (sizeArray.length !== 2) {\n      throw new Error('Only two dimensions matrix are supported');\n    }\n\n    // check sizes\n    sizeArray.forEach(function (value) {\n      if (!(0, _is.isNumber)(value) || !(0, _number.isInteger)(value) || value < 0) {\n        throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + (0, _string.format)(sizeArray) + ')');\n      }\n    });\n\n    // matrix to resize\n    var m = copy ? this.clone() : this;\n    // resize matrix\n    return _resize(m, sizeArray[0], sizeArray[1], defaultValue);\n  };\n  function _resize(matrix, rows, columns, defaultValue) {\n    // value to insert at the time of growing matrix\n    var value = defaultValue || 0;\n\n    // equal signature to use\n    var eq = equalScalar;\n    // zero value\n    var zero = 0;\n    if ((0, _is.isString)(matrix._datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar;\n      // convert 0 to the same datatype\n      zero = typed.convert(0, matrix._datatype);\n      // convert value to the same datatype\n      value = typed.convert(value, matrix._datatype);\n    }\n\n    // should we insert the value?\n    var ins = !eq(value, zero);\n\n    // old columns and rows\n    var r = matrix._size[0];\n    var c = matrix._size[1];\n    var i, j, k;\n\n    // check we need to increase columns\n    if (columns > c) {\n      // loop new columns\n      for (j = c; j < columns; j++) {\n        // update matrix._ptr for current column\n        matrix._ptr[j] = matrix._values.length;\n        // check we need to insert matrix._values\n        if (ins) {\n          // loop rows\n          for (i = 0; i < r; i++) {\n            // add new matrix._values\n            matrix._values.push(value);\n            // update matrix._index\n            matrix._index.push(i);\n          }\n        }\n      }\n      // store number of matrix._values in matrix._ptr\n      matrix._ptr[columns] = matrix._values.length;\n    } else if (columns < c) {\n      // truncate matrix._ptr\n      matrix._ptr.splice(columns + 1, c - columns);\n      // truncate matrix._values and matrix._index\n      matrix._values.splice(matrix._ptr[columns], matrix._values.length);\n      matrix._index.splice(matrix._ptr[columns], matrix._index.length);\n    }\n    // update columns\n    c = columns;\n\n    // check we need to increase rows\n    if (rows > r) {\n      // check we have to insert values\n      if (ins) {\n        // inserts\n        var n = 0;\n        // loop columns\n        for (j = 0; j < c; j++) {\n          // update matrix._ptr for current column\n          matrix._ptr[j] = matrix._ptr[j] + n;\n          // where to insert matrix._values\n          k = matrix._ptr[j + 1] + n;\n          // pointer\n          var p = 0;\n          // loop new rows, initialize pointer\n          for (i = r; i < rows; i++, p++) {\n            // add value\n            matrix._values.splice(k + p, 0, value);\n            // update matrix._index\n            matrix._index.splice(k + p, 0, i);\n            // increment inserts\n            n++;\n          }\n        }\n        // store number of matrix._values in matrix._ptr\n        matrix._ptr[c] = matrix._values.length;\n      }\n    } else if (rows < r) {\n      // deletes\n      var d = 0;\n      // loop columns\n      for (j = 0; j < c; j++) {\n        // update matrix._ptr for current column\n        matrix._ptr[j] = matrix._ptr[j] - d;\n        // where matrix._values start for next column\n        var k0 = matrix._ptr[j];\n        var k1 = matrix._ptr[j + 1] - d;\n        // loop matrix._index\n        for (k = k0; k < k1; k++) {\n          // row\n          i = matrix._index[k];\n          // check we need to delete value and matrix._index\n          if (i > rows - 1) {\n            // remove value\n            matrix._values.splice(k, 1);\n            // remove item from matrix._index\n            matrix._index.splice(k, 1);\n            // increase deletes\n            d++;\n          }\n        }\n      }\n      // update matrix._ptr for current column\n      matrix._ptr[j] = matrix._values.length;\n    }\n    // update matrix._size\n    matrix._size[0] = rows;\n    matrix._size[1] = columns;\n    // return matrix\n    return matrix;\n  }\n\n  /**\n   * Reshape the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (reshape in place).\n   *\n   * NOTE: This might be better suited to copy by default, instead of modifying\n   *       in place. For now, it operates in place to remain consistent with\n   *       resize().\n   *\n   * @memberof SparseMatrix\n   * @param {number[]} sizes          The new size the matrix should have.\n   *                                  Since sparse matrices are always two-dimensional,\n   *                                  size must be two numbers in either an array or a matrix\n   * @param {boolean} [copy]          Return a reshaped copy of the matrix\n   *\n   * @return {Matrix}                 The reshaped matrix\n   */\n  SparseMatrix.prototype.reshape = function (sizes, copy) {\n    // validate arguments\n    if (!(0, _is.isArray)(sizes)) {\n      throw new TypeError('Array expected');\n    }\n    if (sizes.length !== 2) {\n      throw new Error('Sparse matrices can only be reshaped in two dimensions');\n    }\n\n    // check sizes\n    sizes.forEach(function (value) {\n      if (!(0, _is.isNumber)(value) || !(0, _number.isInteger)(value) || value <= -2 || value === 0) {\n        throw new TypeError('Invalid size, must contain positive integers or -1 ' + '(size: ' + (0, _string.format)(sizes) + ')');\n      }\n    });\n    var currentLength = this._size[0] * this._size[1];\n    sizes = (0, _array.processSizesWildcard)(sizes, currentLength);\n    var newLength = sizes[0] * sizes[1];\n\n    // m * n must not change\n    if (currentLength !== newLength) {\n      throw new Error('Reshaping sparse matrix will result in the wrong number of elements');\n    }\n\n    // matrix to reshape\n    var m = copy ? this.clone() : this;\n\n    // return unchanged if the same shape\n    if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {\n      return m;\n    }\n\n    // Convert to COO format (generate a column index)\n    var colIndex = [];\n    for (var i = 0; i < m._ptr.length; i++) {\n      for (var j = 0; j < m._ptr[i + 1] - m._ptr[i]; j++) {\n        colIndex.push(i);\n      }\n    }\n\n    // Clone the values array\n    var values = m._values.slice();\n\n    // Clone the row index array\n    var rowIndex = m._index.slice();\n\n    // Transform the (row, column) indices\n    for (var _i = 0; _i < m._index.length; _i++) {\n      var r1 = rowIndex[_i];\n      var c1 = colIndex[_i];\n      var flat = r1 * m._size[1] + c1;\n      colIndex[_i] = flat % sizes[1];\n      rowIndex[_i] = Math.floor(flat / sizes[1]);\n    }\n\n    // Now reshaping is supposed to preserve the row-major order, BUT these sparse matrices are stored\n    // in column-major order, so we have to reorder the value array now. One option is to use a multisort,\n    // sorting several arrays based on some other array.\n\n    // OR, we could easily just:\n\n    // 1. Remove all values from the matrix\n    m._values.length = 0;\n    m._index.length = 0;\n    m._ptr.length = sizes[1] + 1;\n    m._size = sizes.slice();\n    for (var _i2 = 0; _i2 < m._ptr.length; _i2++) {\n      m._ptr[_i2] = 0;\n    }\n\n    // 2. Re-insert all elements in the proper order (simplified code from SparseMatrix.prototype.set)\n    // This step is probably the most time-consuming\n    for (var h = 0; h < values.length; h++) {\n      var _i3 = rowIndex[h];\n      var _j = colIndex[h];\n      var v = values[h];\n      var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);\n      _insert(k, _i3, _j, v, m._values, m._index, m._ptr);\n    }\n\n    // The value indices are inserted out of order, but apparently that's... still OK?\n\n    return m;\n  };\n\n  /**\n   * Create a clone of the matrix\n   * @memberof SparseMatrix\n   * @return {SparseMatrix} clone\n   */\n  SparseMatrix.prototype.clone = function () {\n    var m = new SparseMatrix({\n      values: this._values ? (0, _object.clone)(this._values) : undefined,\n      index: (0, _object.clone)(this._index),\n      ptr: (0, _object.clone)(this._ptr),\n      size: (0, _object.clone)(this._size),\n      datatype: this._datatype\n    });\n    return m;\n  };\n\n  /**\n   * Retrieve the size of the matrix.\n   * @memberof SparseMatrix\n   * @returns {number[]} size\n   */\n  SparseMatrix.prototype.size = function () {\n    return this._size.slice(0); // copy the Array\n  };\n\n  /**\n   * Create a new matrix with the results of the callback function executed on\n   * each entry of the matrix.\n   * @memberof SparseMatrix\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\n   *\n   * @return {SparseMatrix} matrix\n   */\n  SparseMatrix.prototype.map = function (callback, skipZeros) {\n    // check it is a pattern matrix\n    if (!this._values) {\n      throw new Error('Cannot invoke map on a Pattern only matrix');\n    }\n    // matrix instance\n    var me = this;\n    // rows and columns\n    var rows = this._size[0];\n    var columns = this._size[1];\n    // invoke callback\n    var args = (0, _function.maxArgumentCount)(callback);\n    var invoke = function invoke(v, i, j) {\n      // invoke callback\n      if (args === 1) return callback(v);\n      if (args === 2) return callback(v, [i, j]);\n      return callback(v, [i, j], me);\n    };\n    // invoke _map\n    return _map(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);\n  };\n\n  /**\n   * Create a new matrix with the results of the callback function executed on the interval\n   * [minRow..maxRow, minColumn..maxColumn].\n   */\n  function _map(matrix, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {\n    // result arrays\n    var values = [];\n    var index = [];\n    var ptr = [];\n\n    // equal signature to use\n    var eq = equalScalar;\n    // zero value\n    var zero = 0;\n    if ((0, _is.isString)(matrix._datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar;\n      // convert 0 to the same datatype\n      zero = typed.convert(0, matrix._datatype);\n    }\n\n    // invoke callback\n    var invoke = function invoke(v, x, y) {\n      // invoke callback\n      v = callback(v, x, y);\n      // check value != 0\n      if (!eq(v, zero)) {\n        // store value\n        values.push(v);\n        // index\n        index.push(x);\n      }\n    };\n    // loop columns\n    for (var j = minColumn; j <= maxColumn; j++) {\n      // store pointer to values index\n      ptr.push(values.length);\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = matrix._ptr[j];\n      var k1 = matrix._ptr[j + 1];\n      if (skipZeros) {\n        // loop k within [k0, k1[\n        for (var k = k0; k < k1; k++) {\n          // row index\n          var i = matrix._index[k];\n          // check i is in range\n          if (i >= minRow && i <= maxRow) {\n            // value @ k\n            invoke(matrix._values[k], i - minRow, j - minColumn);\n          }\n        }\n      } else {\n        // create a cache holding all defined values\n        var _values = {};\n        for (var _k = k0; _k < k1; _k++) {\n          var _i4 = matrix._index[_k];\n          _values[_i4] = matrix._values[_k];\n        }\n\n        // loop over all rows (indexes can be unordered so we can't use that),\n        // and either read the value or zero\n        for (var _i5 = minRow; _i5 <= maxRow; _i5++) {\n          var value = _i5 in _values ? _values[_i5] : 0;\n          invoke(value, _i5 - minRow, j - minColumn);\n        }\n      }\n    }\n\n    // store number of values in ptr\n    ptr.push(values.length);\n    // return sparse matrix\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: [maxRow - minRow + 1, maxColumn - minColumn + 1]\n    });\n  }\n\n  /**\n   * Execute a callback function on each entry of the matrix.\n   * @memberof SparseMatrix\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\n   *                              If false, the indices are guaranteed to be in order,\n   *                              if true, the indices can be unordered.\n   */\n  SparseMatrix.prototype.forEach = function (callback, skipZeros) {\n    // check it is a pattern matrix\n    if (!this._values) {\n      throw new Error('Cannot invoke forEach on a Pattern only matrix');\n    }\n    // matrix instance\n    var me = this;\n    // rows and columns\n    var rows = this._size[0];\n    var columns = this._size[1];\n    // loop columns\n    for (var j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = this._ptr[j];\n      var k1 = this._ptr[j + 1];\n      if (skipZeros) {\n        // loop k within [k0, k1[\n        for (var k = k0; k < k1; k++) {\n          // row index\n          var i = this._index[k];\n\n          // value @ k\n          callback(this._values[k], [i, j], me);\n        }\n      } else {\n        // create a cache holding all defined values\n        var values = {};\n        for (var _k2 = k0; _k2 < k1; _k2++) {\n          var _i6 = this._index[_k2];\n          values[_i6] = this._values[_k2];\n        }\n\n        // loop over all rows (indexes can be unordered so we can't use that),\n        // and either read the value or zero\n        for (var _i7 = 0; _i7 < rows; _i7++) {\n          var value = _i7 in values ? values[_i7] : 0;\n          callback(value, [_i7, j], me);\n        }\n      }\n    }\n  };\n\n  /**\n   * Iterate over the matrix elements, skipping zeros\n   * @return {Iterable<{ value, index: number[] }>}\n   */\n  SparseMatrix.prototype[Symbol.iterator] = /*#__PURE__*/_regenerator[\"default\"].mark(function _callee() {\n    var columns, j, k0, k1, k, i;\n    return _regenerator[\"default\"].wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (this._values) {\n              _context.next = 2;\n              break;\n            }\n            throw new Error('Cannot iterate a Pattern only matrix');\n          case 2:\n            columns = this._size[1];\n            j = 0;\n          case 4:\n            if (!(j < columns)) {\n              _context.next = 18;\n              break;\n            }\n            k0 = this._ptr[j];\n            k1 = this._ptr[j + 1];\n            k = k0;\n          case 8:\n            if (!(k < k1)) {\n              _context.next = 15;\n              break;\n            }\n            // row index\n            i = this._index[k];\n            _context.next = 12;\n            return {\n              value: this._values[k],\n              index: [i, j]\n            };\n          case 12:\n            k++;\n            _context.next = 8;\n            break;\n          case 15:\n            j++;\n            _context.next = 4;\n            break;\n          case 18:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  });\n\n  /**\n   * Create an Array with a copy of the data of the SparseMatrix\n   * @memberof SparseMatrix\n   * @returns {Array} array\n   */\n  SparseMatrix.prototype.toArray = function () {\n    return _toArray(this._values, this._index, this._ptr, this._size, true);\n  };\n\n  /**\n   * Get the primitive value of the SparseMatrix: a two dimensions array\n   * @memberof SparseMatrix\n   * @returns {Array} array\n   */\n  SparseMatrix.prototype.valueOf = function () {\n    return _toArray(this._values, this._index, this._ptr, this._size, false);\n  };\n  function _toArray(values, index, ptr, size, copy) {\n    // rows and columns\n    var rows = size[0];\n    var columns = size[1];\n    // result\n    var a = [];\n    // vars\n    var i, j;\n    // initialize array\n    for (i = 0; i < rows; i++) {\n      a[i] = [];\n      for (j = 0; j < columns; j++) {\n        a[i][j] = 0;\n      }\n    }\n\n    // loop columns\n    for (j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = ptr[j];\n      var k1 = ptr[j + 1];\n      // loop k within [k0, k1[\n      for (var k = k0; k < k1; k++) {\n        // row index\n        i = index[k];\n        // set value (use one for pattern matrix)\n        a[i][j] = values ? copy ? (0, _object.clone)(values[k]) : values[k] : 1;\n      }\n    }\n    return a;\n  }\n\n  /**\n   * Get a string representation of the matrix, with optional formatting options.\n   * @memberof SparseMatrix\n   * @param {Object | number | Function} [options]  Formatting options. See\n   *                                                lib/utils/number:format for a\n   *                                                description of the available\n   *                                                options.\n   * @returns {string} str\n   */\n  SparseMatrix.prototype.format = function (options) {\n    // rows and columns\n    var rows = this._size[0];\n    var columns = this._size[1];\n    // density\n    var density = this.density();\n    // rows & columns\n    var str = 'Sparse Matrix [' + (0, _string.format)(rows, options) + ' x ' + (0, _string.format)(columns, options) + '] density: ' + (0, _string.format)(density, options) + '\\n';\n    // loop columns\n    for (var j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = this._ptr[j];\n      var k1 = this._ptr[j + 1];\n      // loop k within [k0, k1[\n      for (var k = k0; k < k1; k++) {\n        // row index\n        var i = this._index[k];\n        // append value\n        str += '\\n    (' + (0, _string.format)(i, options) + ', ' + (0, _string.format)(j, options) + ') ==> ' + (this._values ? (0, _string.format)(this._values[k], options) : 'X');\n      }\n    }\n    return str;\n  };\n\n  /**\n   * Get a string representation of the matrix\n   * @memberof SparseMatrix\n   * @returns {string} str\n   */\n  SparseMatrix.prototype.toString = function () {\n    return (0, _string.format)(this.toArray());\n  };\n\n  /**\n   * Get a JSON representation of the matrix\n   * @memberof SparseMatrix\n   * @returns {Object}\n   */\n  SparseMatrix.prototype.toJSON = function () {\n    return {\n      mathjs: 'SparseMatrix',\n      values: this._values,\n      index: this._index,\n      ptr: this._ptr,\n      size: this._size,\n      datatype: this._datatype\n    };\n  };\n\n  /**\n   * Get the kth Matrix diagonal.\n   *\n   * @memberof SparseMatrix\n   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.\n   *\n   * @returns {Matrix}                     The matrix vector with the diagonal values.\n   */\n  SparseMatrix.prototype.diagonal = function (k) {\n    // validate k if any\n    if (k) {\n      // convert BigNumber to a number\n      if ((0, _is.isBigNumber)(k)) {\n        k = k.toNumber();\n      }\n      // is must be an integer\n      if (!(0, _is.isNumber)(k) || !(0, _number.isInteger)(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    }\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0;\n\n    // rows & columns\n    var rows = this._size[0];\n    var columns = this._size[1];\n\n    // number diagonal values\n    var n = Math.min(rows - kSub, columns - kSuper);\n\n    // diagonal arrays\n    var values = [];\n    var index = [];\n    var ptr = [];\n    // initial ptr value\n    ptr[0] = 0;\n    // loop columns\n    for (var j = kSuper; j < columns && values.length < n; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = this._ptr[j];\n      var k1 = this._ptr[j + 1];\n      // loop x within [k0, k1[\n      for (var x = k0; x < k1; x++) {\n        // row index\n        var i = this._index[x];\n        // check row\n        if (i === j - kSuper + kSub) {\n          // value on this column\n          values.push(this._values[x]);\n          // store row\n          index[values.length - 1] = i - kSub;\n          // exit loop\n          break;\n        }\n      }\n    }\n    // close ptr\n    ptr.push(values.length);\n    // return matrix\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: [n, 1]\n    });\n  };\n\n  /**\n   * Generate a matrix from a JSON object\n   * @memberof SparseMatrix\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"SparseMatrix\", \"values\": [], \"index\": [], \"ptr\": [], \"size\": []}`,\n   *                       where mathjs is optional\n   * @returns {SparseMatrix}\n   */\n  SparseMatrix.fromJSON = function (json) {\n    return new SparseMatrix(json);\n  };\n\n  /**\n   * Create a diagonal matrix.\n   *\n   * @memberof SparseMatrix\n   * @param {Array} size                       The matrix size.\n   * @param {number | Array | Matrix } value   The values for the diagonal.\n   * @param {number | BigNumber} [k=0]         The kth diagonal where the vector will be filled in.\n   * @param {number} [defaultValue]            The default value for non-diagonal\n   * @param {string} [datatype]                The Matrix datatype, values must be of this datatype.\n   *\n   * @returns {SparseMatrix}\n   */\n  SparseMatrix.diagonal = function (size, value, k, defaultValue, datatype) {\n    if (!(0, _is.isArray)(size)) {\n      throw new TypeError('Array expected, size parameter');\n    }\n    if (size.length !== 2) {\n      throw new Error('Only two dimensions matrix are supported');\n    }\n\n    // map size & validate\n    size = size.map(function (s) {\n      // check it is a big number\n      if ((0, _is.isBigNumber)(s)) {\n        // convert it\n        s = s.toNumber();\n      }\n      // validate arguments\n      if (!(0, _is.isNumber)(s) || !(0, _number.isInteger)(s) || s < 1) {\n        throw new Error('Size values must be positive integers');\n      }\n      return s;\n    });\n\n    // validate k if any\n    if (k) {\n      // convert BigNumber to a number\n      if ((0, _is.isBigNumber)(k)) {\n        k = k.toNumber();\n      }\n      // is must be an integer\n      if (!(0, _is.isNumber)(k) || !(0, _number.isInteger)(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    }\n\n    // equal signature to use\n    var eq = equalScalar;\n    // zero value\n    var zero = 0;\n    if ((0, _is.isString)(datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar;\n      // convert 0 to the same datatype\n      zero = typed.convert(0, datatype);\n    }\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0;\n\n    // rows and columns\n    var rows = size[0];\n    var columns = size[1];\n\n    // number of non-zero items\n    var n = Math.min(rows - kSub, columns - kSuper);\n\n    // value extraction function\n    var _value;\n\n    // check value\n    if ((0, _is.isArray)(value)) {\n      // validate array\n      if (value.length !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid value array length');\n      }\n      // define function\n      _value = function _value(i) {\n        // return value @ i\n        return value[i];\n      };\n    } else if ((0, _is.isMatrix)(value)) {\n      // matrix size\n      var ms = value.size();\n      // validate matrix\n      if (ms.length !== 1 || ms[0] !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid matrix length');\n      }\n      // define function\n      _value = function _value(i) {\n        // return value @ i\n        return value.get([i]);\n      };\n    } else {\n      // define function\n      _value = function _value() {\n        // return value\n        return value;\n      };\n    }\n\n    // create arrays\n    var values = [];\n    var index = [];\n    var ptr = [];\n\n    // loop items\n    for (var j = 0; j < columns; j++) {\n      // number of rows with value\n      ptr.push(values.length);\n      // diagonal index\n      var i = j - kSuper;\n      // check we need to set diagonal value\n      if (i >= 0 && i < n) {\n        // get value @ i\n        var v = _value(i);\n        // check for zero\n        if (!eq(v, zero)) {\n          // column\n          index.push(i + kSub);\n          // add value\n          values.push(v);\n        }\n      }\n    }\n    // last value should be number of values\n    ptr.push(values.length);\n    // create SparseMatrix\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: [rows, columns]\n    });\n  };\n\n  /**\n   * Swap rows i and j in Matrix.\n   *\n   * @memberof SparseMatrix\n   * @param {number} i       Matrix row index 1\n   * @param {number} j       Matrix row index 2\n   *\n   * @return {Matrix}        The matrix reference\n   */\n  SparseMatrix.prototype.swapRows = function (i, j) {\n    // check index\n    if (!(0, _is.isNumber)(i) || !(0, _number.isInteger)(i) || !(0, _is.isNumber)(j) || !(0, _number.isInteger)(j)) {\n      throw new Error('Row index must be positive integers');\n    }\n    // check dimensions\n    if (this._size.length !== 2) {\n      throw new Error('Only two dimensional matrix is supported');\n    }\n    // validate index\n    (0, _array.validateIndex)(i, this._size[0]);\n    (0, _array.validateIndex)(j, this._size[0]);\n\n    // swap rows\n    SparseMatrix._swapRows(i, j, this._size[1], this._values, this._index, this._ptr);\n    // return current instance\n    return this;\n  };\n\n  /**\n   * Loop rows with data in column j.\n   *\n   * @param {number} j            Column\n   * @param {Array} values        Matrix values\n   * @param {Array} index         Matrix row indeces\n   * @param {Array} ptr           Matrix column pointers\n   * @param {Function} callback   Callback function invoked for every row in column j\n   */\n  SparseMatrix._forEachRow = function (j, values, index, ptr, callback) {\n    // indeces for column j\n    var k0 = ptr[j];\n    var k1 = ptr[j + 1];\n    // loop\n    for (var k = k0; k < k1; k++) {\n      // invoke callback\n      callback(index[k], values[k]);\n    }\n  };\n\n  /**\n   * Swap rows x and y in Sparse Matrix data structures.\n   *\n   * @param {number} x         Matrix row index 1\n   * @param {number} y         Matrix row index 2\n   * @param {number} columns   Number of columns in matrix\n   * @param {Array} values     Matrix values\n   * @param {Array} index      Matrix row indeces\n   * @param {Array} ptr        Matrix column pointers\n   */\n  SparseMatrix._swapRows = function (x, y, columns, values, index, ptr) {\n    // loop columns\n    for (var j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = ptr[j];\n      var k1 = ptr[j + 1];\n      // find value index @ x\n      var kx = _getValueIndex(x, k0, k1, index);\n      // find value index @ x\n      var ky = _getValueIndex(y, k0, k1, index);\n      // check both rows exist in matrix\n      if (kx < k1 && ky < k1 && index[kx] === x && index[ky] === y) {\n        // swap values (check for pattern matrix)\n        if (values) {\n          var v = values[kx];\n          values[kx] = values[ky];\n          values[ky] = v;\n        }\n        // next column\n        continue;\n      }\n      // check x row exist & no y row\n      if (kx < k1 && index[kx] === x && (ky >= k1 || index[ky] !== y)) {\n        // value @ x (check for pattern matrix)\n        var vx = values ? values[kx] : undefined;\n        // insert value @ y\n        index.splice(ky, 0, y);\n        if (values) {\n          values.splice(ky, 0, vx);\n        }\n        // remove value @ x (adjust array index if needed)\n        index.splice(ky <= kx ? kx + 1 : kx, 1);\n        if (values) {\n          values.splice(ky <= kx ? kx + 1 : kx, 1);\n        }\n        // next column\n        continue;\n      }\n      // check y row exist & no x row\n      if (ky < k1 && index[ky] === y && (kx >= k1 || index[kx] !== x)) {\n        // value @ y (check for pattern matrix)\n        var vy = values ? values[ky] : undefined;\n        // insert value @ x\n        index.splice(kx, 0, x);\n        if (values) {\n          values.splice(kx, 0, vy);\n        }\n        // remove value @ y (adjust array index if needed)\n        index.splice(kx <= ky ? ky + 1 : ky, 1);\n        if (values) {\n          values.splice(kx <= ky ? ky + 1 : ky, 1);\n        }\n      }\n    }\n  };\n  return SparseMatrix;\n}, {\n  isClass: true\n});\nexports.createSparseMatrixClass = createSparseMatrixClass;"],"mappings":"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"},"metadata":{},"sourceType":"script"}