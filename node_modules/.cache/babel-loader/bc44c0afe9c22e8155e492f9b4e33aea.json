{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSimplifyConstant = void 0;\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\nvar _is = require(\"../../utils/is.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar _util = require(\"./simplify/util.js\");\nvar _noop = require(\"../../utils/noop.js\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nvar name = 'simplifyConstant';\nvar dependencies = ['typed', 'parse', 'config', 'mathWithTransform', 'matrix', '?fraction', '?bignumber', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'SymbolNode'];\nvar createSimplifyConstant = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n    parse = _ref.parse,\n    config = _ref.config,\n    mathWithTransform = _ref.mathWithTransform,\n    matrix = _ref.matrix,\n    fraction = _ref.fraction,\n    bignumber = _ref.bignumber,\n    AccessorNode = _ref.AccessorNode,\n    ArrayNode = _ref.ArrayNode,\n    ConstantNode = _ref.ConstantNode,\n    FunctionNode = _ref.FunctionNode,\n    IndexNode = _ref.IndexNode,\n    ObjectNode = _ref.ObjectNode,\n    OperatorNode = _ref.OperatorNode,\n    SymbolNode = _ref.SymbolNode;\n  var _createUtil = (0, _util.createUtil)({\n      FunctionNode: FunctionNode,\n      OperatorNode: OperatorNode,\n      SymbolNode: SymbolNode\n    }),\n    isCommutative = _createUtil.isCommutative,\n    isAssociative = _createUtil.isAssociative,\n    allChildren = _createUtil.allChildren,\n    createMakeNodeFunction = _createUtil.createMakeNodeFunction;\n\n  /**\n   * simplifyConstant() takes a mathjs expression (either a Node representing\n   * a parse tree or a string which it parses to produce a node), and replaces\n   * any subexpression of it consisting entirely of constants with the computed\n   * value of that subexpression.\n   *\n   * Syntax:\n   *\n   *     simplifyConstant(expr)\n   *     simplifyConstant(expr, options)\n   *\n   * Examples:\n   *\n   *     math.simplifyConstant('x + 4*3/6')  // Node \"x + 2\"\n   *     math.simplifyConstant('z cos(0)')   // Node \"z 1\"\n   *     math.simplifyConstant('(5.2 + 1.08)t', {exactFractions: false})  // Node \"6.28 t\"\n   *\n   * See also:\n   *\n   *     simplify, simplifyCore, resolve, derivative\n   *\n   * @param {Node | string} node\n   *     The expression to be simplified\n   * @param {Object} options\n   *     Simplification options, as per simplify()\n   * @return {Node} Returns expression with constant subexpressions evaluated\n   */\n  var simplifyConstant = typed('simplifyConstant', {\n    Node: function Node(node) {\n      return _ensureNode(foldFraction(node, {}));\n    },\n    'Node, Object': function NodeObject(expr, options) {\n      return _ensureNode(foldFraction(expr, options));\n    }\n  });\n  function _removeFractions(thing) {\n    if ((0, _is.isFraction)(thing)) {\n      return thing.valueOf();\n    }\n    if (thing instanceof Array) {\n      return thing.map(_removeFractions);\n    }\n    if ((0, _is.isMatrix)(thing)) {\n      return matrix(_removeFractions(thing.valueOf()));\n    }\n    return thing;\n  }\n  function _eval(fnname, args, options) {\n    try {\n      return mathWithTransform[fnname].apply(null, args);\n    } catch (ignore) {\n      // sometimes the implicit type conversion causes the evaluation to fail, so we'll try again after removing Fractions\n      args = args.map(_removeFractions);\n      return _toNumber(mathWithTransform[fnname].apply(null, args), options);\n    }\n  }\n  var _toNode = typed({\n    Fraction: _fractionToNode,\n    number: function number(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n      return new ConstantNode(n);\n    },\n    BigNumber: function BigNumber(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n      return new ConstantNode(n); // old parameters: (n.toString(), 'number')\n    },\n\n    Complex: function Complex(s) {\n      throw new Error('Cannot convert Complex number to Node');\n    },\n    string: function string(s) {\n      return new ConstantNode(s);\n    },\n    Matrix: function Matrix(m) {\n      return new ArrayNode(m.valueOf().map(function (e) {\n        return _toNode(e);\n      }));\n    }\n  });\n  function _ensureNode(thing) {\n    if ((0, _is.isNode)(thing)) {\n      return thing;\n    }\n    return _toNode(thing);\n  }\n\n  // convert a number to a fraction only if it can be expressed exactly,\n  // and when both numerator and denominator are small enough\n  function _exactFraction(n, options) {\n    var exactFractions = options && options.exactFractions !== false;\n    if (exactFractions && isFinite(n) && fraction) {\n      var f = fraction(n);\n      var fractionsLimit = options && typeof options.fractionsLimit === 'number' ? options.fractionsLimit : Infinity; // no limit by default\n\n      if (f.valueOf() === n && f.n < fractionsLimit && f.d < fractionsLimit) {\n        return f;\n      }\n    }\n    return n;\n  }\n\n  // Convert numbers to a preferred number type in preference order: Fraction, number, Complex\n  // BigNumbers are left alone\n  var _toNumber = typed({\n    'string, Object': function stringObject(s, options) {\n      if (config.number === 'BigNumber') {\n        if (bignumber === undefined) {\n          (0, _noop.noBignumber)();\n        }\n        return bignumber(s);\n      } else if (config.number === 'Fraction') {\n        if (fraction === undefined) {\n          (0, _noop.noFraction)();\n        }\n        return fraction(s);\n      } else {\n        var n = parseFloat(s);\n        return _exactFraction(n, options);\n      }\n    },\n    'Fraction, Object': function FractionObject(s, options) {\n      return s;\n    },\n    // we don't need options here\n\n    'BigNumber, Object': function BigNumberObject(s, options) {\n      return s;\n    },\n    // we don't need options here\n\n    'number, Object': function numberObject(s, options) {\n      return _exactFraction(s, options);\n    },\n    'Complex, Object': function ComplexObject(s, options) {\n      if (s.im !== 0) {\n        return s;\n      }\n      return _exactFraction(s.re, options);\n    },\n    'Matrix, Object': function MatrixObject(s, options) {\n      return matrix(_exactFraction(s.valueOf()));\n    },\n    'Array, Object': function ArrayObject(s, options) {\n      return s.map(_exactFraction);\n    }\n  });\n  function unaryMinusNode(n) {\n    return new OperatorNode('-', 'unaryMinus', [n]);\n  }\n  function _fractionToNode(f) {\n    var n;\n    var vn = f.s * f.n;\n    if (vn < 0) {\n      n = new OperatorNode('-', 'unaryMinus', [new ConstantNode(-vn)]);\n    } else {\n      n = new ConstantNode(vn);\n    }\n    if (f.d === 1) {\n      return n;\n    }\n    return new OperatorNode('/', 'divide', [n, new ConstantNode(f.d)]);\n  }\n\n  /* Handles constant indexing of ArrayNodes, matrices, and ObjectNodes */\n  function _foldAccessor(obj, index, options) {\n    if (!(0, _is.isIndexNode)(index)) {\n      // don't know what to do with that...\n      return new AccessorNode(_ensureNode(obj), _ensureNode(index));\n    }\n    if ((0, _is.isArrayNode)(obj) || (0, _is.isMatrix)(obj)) {\n      var remainingDims = Array.from(index.dimensions);\n      /* We will resolve constant indices one at a time, looking\n       * just in the first or second dimensions because (a) arrays\n       * of more than two dimensions are likely rare, and (b) pulling\n       * out the third or higher dimension would be pretty intricate.\n       * The price is that we miss simplifying [..3d array][x,y,1]\n       */\n      while (remainingDims.length > 0) {\n        if ((0, _is.isConstantNode)(remainingDims[0]) && typeof remainingDims[0].value !== 'string') {\n          var first = _toNumber(remainingDims.shift().value, options);\n          if ((0, _is.isArrayNode)(obj)) {\n            obj = obj.items[first - 1];\n          } else {\n            // matrix\n            obj = obj.valueOf()[first - 1];\n            if (obj instanceof Array) {\n              obj = matrix(obj);\n            }\n          }\n        } else if (remainingDims.length > 1 && (0, _is.isConstantNode)(remainingDims[1]) && typeof remainingDims[1].value !== 'string') {\n          var second = _toNumber(remainingDims[1].value, options);\n          var tryItems = [];\n          var fromItems = (0, _is.isArrayNode)(obj) ? obj.items : obj.valueOf();\n          var _iterator = _createForOfIteratorHelper(fromItems),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var item = _step.value;\n              if ((0, _is.isArrayNode)(item)) {\n                tryItems.push(item.items[second - 1]);\n              } else if ((0, _is.isMatrix)(obj)) {\n                tryItems.push(item[second - 1]);\n              } else {\n                break;\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n          if (tryItems.length === fromItems.length) {\n            if ((0, _is.isArrayNode)(obj)) {\n              obj = new ArrayNode(tryItems);\n            } else {\n              // matrix\n              obj = matrix(tryItems);\n            }\n            remainingDims.splice(1, 1);\n          } else {\n            // extracting slice along 2nd dimension failed, give up\n            break;\n          }\n        } else {\n          // neither 1st or 2nd dimension is constant, give up\n          break;\n        }\n      }\n      if (remainingDims.length === index.dimensions.length) {\n        /* No successful constant indexing */\n        return new AccessorNode(_ensureNode(obj), index);\n      }\n      if (remainingDims.length > 0) {\n        /* Indexed some but not all dimensions */\n        index = new IndexNode(remainingDims);\n        return new AccessorNode(_ensureNode(obj), index);\n      }\n      /* All dimensions were constant, access completely resolved */\n      return obj;\n    }\n    if ((0, _is.isObjectNode)(obj) && index.dimensions.length === 1 && (0, _is.isConstantNode)(index.dimensions[0])) {\n      var key = index.dimensions[0].value;\n      if (key in obj.properties) {\n        return obj.properties[key];\n      }\n      return new ConstantNode(); // undefined\n    }\n    /* Don't know how to index this sort of obj, at least not with this index */\n    return new AccessorNode(_ensureNode(obj), index);\n  }\n\n  /*\n   * Create a binary tree from a list of Fractions and Nodes.\n   * Tries to fold Fractions by evaluating them until the first Node in the list is hit, so\n   * `args` should be sorted to have the Fractions at the start (if the operator is commutative).\n   * @param args - list of Fractions and Nodes\n   * @param fn - evaluator for the binary operation evaluator that accepts two Fractions\n   * @param makeNode - creates a binary OperatorNode/FunctionNode from a list of child Nodes\n   * if args.length is 1, returns args[0]\n   * @return - Either a Node representing a binary expression or Fraction\n   */\n  function foldOp(fn, args, makeNode, options) {\n    return args.reduce(function (a, b) {\n      if (!(0, _is.isNode)(a) && !(0, _is.isNode)(b)) {\n        try {\n          return _eval(fn, [a, b], options);\n        } catch (ignoreandcontinue) {}\n        a = _toNode(a);\n        b = _toNode(b);\n      } else if (!(0, _is.isNode)(a)) {\n        a = _toNode(a);\n      } else if (!(0, _is.isNode)(b)) {\n        b = _toNode(b);\n      }\n      return makeNode([a, b]);\n    });\n  }\n\n  // destroys the original node and returns a folded one\n  function foldFraction(node, options) {\n    switch (node.type) {\n      case 'SymbolNode':\n        return node;\n      case 'ConstantNode':\n        switch ((0, _typeof2[\"default\"])(node.value)) {\n          case 'number':\n            return _toNumber(node.value, options);\n          case 'string':\n            return node.value;\n          default:\n            if (!isNaN(node.value)) return _toNumber(node.value, options);\n        }\n        return node;\n      case 'FunctionNode':\n        if (mathWithTransform[node.name] && mathWithTransform[node.name].rawArgs) {\n          return node;\n        }\n        {\n          // Process operators as OperatorNode\n          var operatorFunctions = ['add', 'multiply'];\n          if (operatorFunctions.indexOf(node.name) === -1) {\n            var args = node.args.map(function (arg) {\n              return foldFraction(arg, options);\n            });\n\n            // If all args are numbers\n            if (!args.some(_is.isNode)) {\n              try {\n                return _eval(node.name, args, options);\n              } catch (ignoreandcontinue) {}\n            }\n\n            // Size of a matrix does not depend on entries\n            if (node.name === 'size' && args.length === 1 && (0, _is.isArrayNode)(args[0])) {\n              var sz = [];\n              var section = args[0];\n              while ((0, _is.isArrayNode)(section)) {\n                sz.push(section.items.length);\n                section = section.items[0];\n              }\n              return matrix(sz);\n            }\n\n            // Convert all args to nodes and construct a symbolic function call\n            return new FunctionNode(node.name, args.map(_ensureNode));\n          } else {\n            // treat as operator\n          }\n        }\n      /* falls through */\n      case 'OperatorNode':\n        {\n          var fn = node.fn.toString();\n          var _args;\n          var res;\n          var makeNode = createMakeNodeFunction(node);\n          if ((0, _is.isOperatorNode)(node) && node.isUnary()) {\n            _args = [foldFraction(node.args[0], options)];\n            if (!(0, _is.isNode)(_args[0])) {\n              res = _eval(fn, _args, options);\n            } else {\n              res = makeNode(_args);\n            }\n          } else if (isAssociative(node, options.context)) {\n            _args = allChildren(node, options.context);\n            _args = _args.map(function (arg) {\n              return foldFraction(arg, options);\n            });\n            if (isCommutative(fn, options.context)) {\n              // commutative binary operator\n              var consts = [];\n              var vars = [];\n              for (var i = 0; i < _args.length; i++) {\n                if (!(0, _is.isNode)(_args[i])) {\n                  consts.push(_args[i]);\n                } else {\n                  vars.push(_args[i]);\n                }\n              }\n              if (consts.length > 1) {\n                res = foldOp(fn, consts, makeNode, options);\n                vars.unshift(res);\n                res = foldOp(fn, vars, makeNode, options);\n              } else {\n                // we won't change the children order since it's not neccessary\n                res = foldOp(fn, _args, makeNode, options);\n              }\n            } else {\n              // non-commutative binary operator\n              res = foldOp(fn, _args, makeNode, options);\n            }\n          } else {\n            // non-associative binary operator\n            _args = node.args.map(function (arg) {\n              return foldFraction(arg, options);\n            });\n            res = foldOp(fn, _args, makeNode, options);\n          }\n          return res;\n        }\n      case 'ParenthesisNode':\n        // remove the uneccessary parenthesis\n        return foldFraction(node.content, options);\n      case 'AccessorNode':\n        return _foldAccessor(foldFraction(node.object, options), foldFraction(node.index, options), options);\n      case 'ArrayNode':\n        {\n          var foldItems = node.items.map(function (item) {\n            return foldFraction(item, options);\n          });\n          if (foldItems.some(_is.isNode)) {\n            return new ArrayNode(foldItems.map(_ensureNode));\n          }\n          /* All literals -- return a Matrix so we can operate on it */\n          return matrix(foldItems);\n        }\n      case 'IndexNode':\n        {\n          return new IndexNode(node.dimensions.map(function (n) {\n            return simplifyConstant(n, options);\n          }));\n        }\n      case 'ObjectNode':\n        {\n          var foldProps = {};\n          for (var prop in node.properties) {\n            foldProps[prop] = simplifyConstant(node.properties[prop], options);\n          }\n          return new ObjectNode(foldProps);\n        }\n      case 'AssignmentNode':\n      /* falls through */\n      case 'BlockNode':\n      /* falls through */\n      case 'FunctionAssignmentNode':\n      /* falls through */\n      case 'RangeNode':\n      /* falls through */\n      case 'ConditionalNode':\n      /* falls through */\n      default:\n        throw new Error(\"Unimplemented node type in simplifyConstant: \".concat(node.type));\n    }\n  }\n  return simplifyConstant;\n});\nexports.createSimplifyConstant = createSimplifyConstant;","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","createSimplifyConstant","_typeof2","_is","_factory","_util","_noop","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","length","i","F","s","n","done","e","_e","f","TypeError","normalCompletion","didErr","err","call","step","next","_e2","minLen","_arrayLikeToArray","prototype","toString","slice","constructor","name","from","test","arr","len","arr2","dependencies","factory","_ref","typed","parse","config","mathWithTransform","matrix","fraction","bignumber","AccessorNode","ArrayNode","ConstantNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","SymbolNode","_createUtil","createUtil","isCommutative","isAssociative","allChildren","createMakeNodeFunction","simplifyConstant","Node","node","_ensureNode","foldFraction","NodeObject","expr","options","_removeFractions","thing","isFraction","valueOf","map","isMatrix","_eval","fnname","args","apply","ignore","_toNumber","_toNode","Fraction","_fractionToNode","number","unaryMinusNode","BigNumber","Complex","Error","string","Matrix","m","isNode","_exactFraction","exactFractions","isFinite","fractionsLimit","Infinity","d","stringObject","undefined","noBignumber","noFraction","parseFloat","FractionObject","BigNumberObject","numberObject","ComplexObject","im","re","MatrixObject","ArrayObject","vn","_foldAccessor","obj","index","isIndexNode","isArrayNode","remainingDims","dimensions","isConstantNode","first","shift","items","second","tryItems","fromItems","_iterator","_step","item","push","splice","isObjectNode","key","properties","foldOp","fn","makeNode","reduce","a","b","ignoreandcontinue","type","isNaN","rawArgs","operatorFunctions","indexOf","arg","some","sz","section","_args","res","isOperatorNode","isUnary","context","consts","vars","unshift","content","object","foldItems","foldProps","prop","concat"],"sources":["C:/Users/Admin/Desktop/React-Web-main/node_modules/mathjs/lib/cjs/function/algebra/simplifyConstant.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSimplifyConstant = void 0;\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\nvar _is = require(\"../../utils/is.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar _util = require(\"./simplify/util.js\");\nvar _noop = require(\"../../utils/noop.js\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar name = 'simplifyConstant';\nvar dependencies = ['typed', 'parse', 'config', 'mathWithTransform', 'matrix', '?fraction', '?bignumber', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'SymbolNode'];\nvar createSimplifyConstant = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n    parse = _ref.parse,\n    config = _ref.config,\n    mathWithTransform = _ref.mathWithTransform,\n    matrix = _ref.matrix,\n    fraction = _ref.fraction,\n    bignumber = _ref.bignumber,\n    AccessorNode = _ref.AccessorNode,\n    ArrayNode = _ref.ArrayNode,\n    ConstantNode = _ref.ConstantNode,\n    FunctionNode = _ref.FunctionNode,\n    IndexNode = _ref.IndexNode,\n    ObjectNode = _ref.ObjectNode,\n    OperatorNode = _ref.OperatorNode,\n    SymbolNode = _ref.SymbolNode;\n  var _createUtil = (0, _util.createUtil)({\n      FunctionNode: FunctionNode,\n      OperatorNode: OperatorNode,\n      SymbolNode: SymbolNode\n    }),\n    isCommutative = _createUtil.isCommutative,\n    isAssociative = _createUtil.isAssociative,\n    allChildren = _createUtil.allChildren,\n    createMakeNodeFunction = _createUtil.createMakeNodeFunction;\n\n  /**\n   * simplifyConstant() takes a mathjs expression (either a Node representing\n   * a parse tree or a string which it parses to produce a node), and replaces\n   * any subexpression of it consisting entirely of constants with the computed\n   * value of that subexpression.\n   *\n   * Syntax:\n   *\n   *     simplifyConstant(expr)\n   *     simplifyConstant(expr, options)\n   *\n   * Examples:\n   *\n   *     math.simplifyConstant('x + 4*3/6')  // Node \"x + 2\"\n   *     math.simplifyConstant('z cos(0)')   // Node \"z 1\"\n   *     math.simplifyConstant('(5.2 + 1.08)t', {exactFractions: false})  // Node \"6.28 t\"\n   *\n   * See also:\n   *\n   *     simplify, simplifyCore, resolve, derivative\n   *\n   * @param {Node | string} node\n   *     The expression to be simplified\n   * @param {Object} options\n   *     Simplification options, as per simplify()\n   * @return {Node} Returns expression with constant subexpressions evaluated\n   */\n  var simplifyConstant = typed('simplifyConstant', {\n    Node: function Node(node) {\n      return _ensureNode(foldFraction(node, {}));\n    },\n    'Node, Object': function NodeObject(expr, options) {\n      return _ensureNode(foldFraction(expr, options));\n    }\n  });\n  function _removeFractions(thing) {\n    if ((0, _is.isFraction)(thing)) {\n      return thing.valueOf();\n    }\n    if (thing instanceof Array) {\n      return thing.map(_removeFractions);\n    }\n    if ((0, _is.isMatrix)(thing)) {\n      return matrix(_removeFractions(thing.valueOf()));\n    }\n    return thing;\n  }\n  function _eval(fnname, args, options) {\n    try {\n      return mathWithTransform[fnname].apply(null, args);\n    } catch (ignore) {\n      // sometimes the implicit type conversion causes the evaluation to fail, so we'll try again after removing Fractions\n      args = args.map(_removeFractions);\n      return _toNumber(mathWithTransform[fnname].apply(null, args), options);\n    }\n  }\n  var _toNode = typed({\n    Fraction: _fractionToNode,\n    number: function number(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n      return new ConstantNode(n);\n    },\n    BigNumber: function BigNumber(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n      return new ConstantNode(n); // old parameters: (n.toString(), 'number')\n    },\n\n    Complex: function Complex(s) {\n      throw new Error('Cannot convert Complex number to Node');\n    },\n    string: function string(s) {\n      return new ConstantNode(s);\n    },\n    Matrix: function Matrix(m) {\n      return new ArrayNode(m.valueOf().map(function (e) {\n        return _toNode(e);\n      }));\n    }\n  });\n  function _ensureNode(thing) {\n    if ((0, _is.isNode)(thing)) {\n      return thing;\n    }\n    return _toNode(thing);\n  }\n\n  // convert a number to a fraction only if it can be expressed exactly,\n  // and when both numerator and denominator are small enough\n  function _exactFraction(n, options) {\n    var exactFractions = options && options.exactFractions !== false;\n    if (exactFractions && isFinite(n) && fraction) {\n      var f = fraction(n);\n      var fractionsLimit = options && typeof options.fractionsLimit === 'number' ? options.fractionsLimit : Infinity; // no limit by default\n\n      if (f.valueOf() === n && f.n < fractionsLimit && f.d < fractionsLimit) {\n        return f;\n      }\n    }\n    return n;\n  }\n\n  // Convert numbers to a preferred number type in preference order: Fraction, number, Complex\n  // BigNumbers are left alone\n  var _toNumber = typed({\n    'string, Object': function stringObject(s, options) {\n      if (config.number === 'BigNumber') {\n        if (bignumber === undefined) {\n          (0, _noop.noBignumber)();\n        }\n        return bignumber(s);\n      } else if (config.number === 'Fraction') {\n        if (fraction === undefined) {\n          (0, _noop.noFraction)();\n        }\n        return fraction(s);\n      } else {\n        var n = parseFloat(s);\n        return _exactFraction(n, options);\n      }\n    },\n    'Fraction, Object': function FractionObject(s, options) {\n      return s;\n    },\n    // we don't need options here\n\n    'BigNumber, Object': function BigNumberObject(s, options) {\n      return s;\n    },\n    // we don't need options here\n\n    'number, Object': function numberObject(s, options) {\n      return _exactFraction(s, options);\n    },\n    'Complex, Object': function ComplexObject(s, options) {\n      if (s.im !== 0) {\n        return s;\n      }\n      return _exactFraction(s.re, options);\n    },\n    'Matrix, Object': function MatrixObject(s, options) {\n      return matrix(_exactFraction(s.valueOf()));\n    },\n    'Array, Object': function ArrayObject(s, options) {\n      return s.map(_exactFraction);\n    }\n  });\n  function unaryMinusNode(n) {\n    return new OperatorNode('-', 'unaryMinus', [n]);\n  }\n  function _fractionToNode(f) {\n    var n;\n    var vn = f.s * f.n;\n    if (vn < 0) {\n      n = new OperatorNode('-', 'unaryMinus', [new ConstantNode(-vn)]);\n    } else {\n      n = new ConstantNode(vn);\n    }\n    if (f.d === 1) {\n      return n;\n    }\n    return new OperatorNode('/', 'divide', [n, new ConstantNode(f.d)]);\n  }\n\n  /* Handles constant indexing of ArrayNodes, matrices, and ObjectNodes */\n  function _foldAccessor(obj, index, options) {\n    if (!(0, _is.isIndexNode)(index)) {\n      // don't know what to do with that...\n      return new AccessorNode(_ensureNode(obj), _ensureNode(index));\n    }\n    if ((0, _is.isArrayNode)(obj) || (0, _is.isMatrix)(obj)) {\n      var remainingDims = Array.from(index.dimensions);\n      /* We will resolve constant indices one at a time, looking\n       * just in the first or second dimensions because (a) arrays\n       * of more than two dimensions are likely rare, and (b) pulling\n       * out the third or higher dimension would be pretty intricate.\n       * The price is that we miss simplifying [..3d array][x,y,1]\n       */\n      while (remainingDims.length > 0) {\n        if ((0, _is.isConstantNode)(remainingDims[0]) && typeof remainingDims[0].value !== 'string') {\n          var first = _toNumber(remainingDims.shift().value, options);\n          if ((0, _is.isArrayNode)(obj)) {\n            obj = obj.items[first - 1];\n          } else {\n            // matrix\n            obj = obj.valueOf()[first - 1];\n            if (obj instanceof Array) {\n              obj = matrix(obj);\n            }\n          }\n        } else if (remainingDims.length > 1 && (0, _is.isConstantNode)(remainingDims[1]) && typeof remainingDims[1].value !== 'string') {\n          var second = _toNumber(remainingDims[1].value, options);\n          var tryItems = [];\n          var fromItems = (0, _is.isArrayNode)(obj) ? obj.items : obj.valueOf();\n          var _iterator = _createForOfIteratorHelper(fromItems),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var item = _step.value;\n              if ((0, _is.isArrayNode)(item)) {\n                tryItems.push(item.items[second - 1]);\n              } else if ((0, _is.isMatrix)(obj)) {\n                tryItems.push(item[second - 1]);\n              } else {\n                break;\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n          if (tryItems.length === fromItems.length) {\n            if ((0, _is.isArrayNode)(obj)) {\n              obj = new ArrayNode(tryItems);\n            } else {\n              // matrix\n              obj = matrix(tryItems);\n            }\n            remainingDims.splice(1, 1);\n          } else {\n            // extracting slice along 2nd dimension failed, give up\n            break;\n          }\n        } else {\n          // neither 1st or 2nd dimension is constant, give up\n          break;\n        }\n      }\n      if (remainingDims.length === index.dimensions.length) {\n        /* No successful constant indexing */\n        return new AccessorNode(_ensureNode(obj), index);\n      }\n      if (remainingDims.length > 0) {\n        /* Indexed some but not all dimensions */\n        index = new IndexNode(remainingDims);\n        return new AccessorNode(_ensureNode(obj), index);\n      }\n      /* All dimensions were constant, access completely resolved */\n      return obj;\n    }\n    if ((0, _is.isObjectNode)(obj) && index.dimensions.length === 1 && (0, _is.isConstantNode)(index.dimensions[0])) {\n      var key = index.dimensions[0].value;\n      if (key in obj.properties) {\n        return obj.properties[key];\n      }\n      return new ConstantNode(); // undefined\n    }\n    /* Don't know how to index this sort of obj, at least not with this index */\n    return new AccessorNode(_ensureNode(obj), index);\n  }\n\n  /*\n   * Create a binary tree from a list of Fractions and Nodes.\n   * Tries to fold Fractions by evaluating them until the first Node in the list is hit, so\n   * `args` should be sorted to have the Fractions at the start (if the operator is commutative).\n   * @param args - list of Fractions and Nodes\n   * @param fn - evaluator for the binary operation evaluator that accepts two Fractions\n   * @param makeNode - creates a binary OperatorNode/FunctionNode from a list of child Nodes\n   * if args.length is 1, returns args[0]\n   * @return - Either a Node representing a binary expression or Fraction\n   */\n  function foldOp(fn, args, makeNode, options) {\n    return args.reduce(function (a, b) {\n      if (!(0, _is.isNode)(a) && !(0, _is.isNode)(b)) {\n        try {\n          return _eval(fn, [a, b], options);\n        } catch (ignoreandcontinue) {}\n        a = _toNode(a);\n        b = _toNode(b);\n      } else if (!(0, _is.isNode)(a)) {\n        a = _toNode(a);\n      } else if (!(0, _is.isNode)(b)) {\n        b = _toNode(b);\n      }\n      return makeNode([a, b]);\n    });\n  }\n\n  // destroys the original node and returns a folded one\n  function foldFraction(node, options) {\n    switch (node.type) {\n      case 'SymbolNode':\n        return node;\n      case 'ConstantNode':\n        switch ((0, _typeof2[\"default\"])(node.value)) {\n          case 'number':\n            return _toNumber(node.value, options);\n          case 'string':\n            return node.value;\n          default:\n            if (!isNaN(node.value)) return _toNumber(node.value, options);\n        }\n        return node;\n      case 'FunctionNode':\n        if (mathWithTransform[node.name] && mathWithTransform[node.name].rawArgs) {\n          return node;\n        }\n        {\n          // Process operators as OperatorNode\n          var operatorFunctions = ['add', 'multiply'];\n          if (operatorFunctions.indexOf(node.name) === -1) {\n            var args = node.args.map(function (arg) {\n              return foldFraction(arg, options);\n            });\n\n            // If all args are numbers\n            if (!args.some(_is.isNode)) {\n              try {\n                return _eval(node.name, args, options);\n              } catch (ignoreandcontinue) {}\n            }\n\n            // Size of a matrix does not depend on entries\n            if (node.name === 'size' && args.length === 1 && (0, _is.isArrayNode)(args[0])) {\n              var sz = [];\n              var section = args[0];\n              while ((0, _is.isArrayNode)(section)) {\n                sz.push(section.items.length);\n                section = section.items[0];\n              }\n              return matrix(sz);\n            }\n\n            // Convert all args to nodes and construct a symbolic function call\n            return new FunctionNode(node.name, args.map(_ensureNode));\n          } else {\n            // treat as operator\n          }\n        }\n      /* falls through */\n      case 'OperatorNode':\n        {\n          var fn = node.fn.toString();\n          var _args;\n          var res;\n          var makeNode = createMakeNodeFunction(node);\n          if ((0, _is.isOperatorNode)(node) && node.isUnary()) {\n            _args = [foldFraction(node.args[0], options)];\n            if (!(0, _is.isNode)(_args[0])) {\n              res = _eval(fn, _args, options);\n            } else {\n              res = makeNode(_args);\n            }\n          } else if (isAssociative(node, options.context)) {\n            _args = allChildren(node, options.context);\n            _args = _args.map(function (arg) {\n              return foldFraction(arg, options);\n            });\n            if (isCommutative(fn, options.context)) {\n              // commutative binary operator\n              var consts = [];\n              var vars = [];\n              for (var i = 0; i < _args.length; i++) {\n                if (!(0, _is.isNode)(_args[i])) {\n                  consts.push(_args[i]);\n                } else {\n                  vars.push(_args[i]);\n                }\n              }\n              if (consts.length > 1) {\n                res = foldOp(fn, consts, makeNode, options);\n                vars.unshift(res);\n                res = foldOp(fn, vars, makeNode, options);\n              } else {\n                // we won't change the children order since it's not neccessary\n                res = foldOp(fn, _args, makeNode, options);\n              }\n            } else {\n              // non-commutative binary operator\n              res = foldOp(fn, _args, makeNode, options);\n            }\n          } else {\n            // non-associative binary operator\n            _args = node.args.map(function (arg) {\n              return foldFraction(arg, options);\n            });\n            res = foldOp(fn, _args, makeNode, options);\n          }\n          return res;\n        }\n      case 'ParenthesisNode':\n        // remove the uneccessary parenthesis\n        return foldFraction(node.content, options);\n      case 'AccessorNode':\n        return _foldAccessor(foldFraction(node.object, options), foldFraction(node.index, options), options);\n      case 'ArrayNode':\n        {\n          var foldItems = node.items.map(function (item) {\n            return foldFraction(item, options);\n          });\n          if (foldItems.some(_is.isNode)) {\n            return new ArrayNode(foldItems.map(_ensureNode));\n          }\n          /* All literals -- return a Matrix so we can operate on it */\n          return matrix(foldItems);\n        }\n      case 'IndexNode':\n        {\n          return new IndexNode(node.dimensions.map(function (n) {\n            return simplifyConstant(n, options);\n          }));\n        }\n      case 'ObjectNode':\n        {\n          var foldProps = {};\n          for (var prop in node.properties) {\n            foldProps[prop] = simplifyConstant(node.properties[prop], options);\n          }\n          return new ObjectNode(foldProps);\n        }\n      case 'AssignmentNode':\n      /* falls through */\n      case 'BlockNode':\n      /* falls through */\n      case 'FunctionAssignmentNode':\n      /* falls through */\n      case 'RangeNode':\n      /* falls through */\n      case 'ConditionalNode':\n      /* falls through */\n      default:\n        throw new Error(\"Unimplemented node type in simplifyConstant: \".concat(node.type));\n    }\n  }\n  return simplifyConstant;\n});\nexports.createSimplifyConstant = createSimplifyConstant;"],"mappings":"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"},"metadata":{},"sourceType":"script"}