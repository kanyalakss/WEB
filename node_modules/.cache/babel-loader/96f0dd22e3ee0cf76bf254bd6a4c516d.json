{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createResolve = void 0;\nvar _map = require(\"../../utils/map.js\");\nvar _is = require(\"../../utils/is.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar name = 'resolve';\nvar dependencies = ['typed', 'parse', 'ConstantNode', 'FunctionNode', 'OperatorNode', 'ParenthesisNode'];\nvar createResolve = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n    parse = _ref.parse,\n    ConstantNode = _ref.ConstantNode,\n    FunctionNode = _ref.FunctionNode,\n    OperatorNode = _ref.OperatorNode,\n    ParenthesisNode = _ref.ParenthesisNode;\n  /**\n   * resolve(expr, scope) replaces variable nodes with their scoped values\n   *\n   * Syntax:\n   *\n   *     resolve(expr, scope)\n   *\n   * Examples:\n   *\n   *     math.resolve('x + y', {x:1, y:2})           // Node '1 + 2'\n   *     math.resolve(math.parse('x+y'), {x:1, y:2}) // Node '1 + 2'\n   *     math.simplify('x+y', {x:2, y: math.parse('x+x')}).toString() // \"6\"\n   *\n   * See also:\n   *\n   *     simplify, evaluate\n   *\n   * @param {Node | Node[]} node\n   *     The expression tree (or trees) to be simplified\n   * @param {Object} scope\n   *     Scope specifying variables to be resolved\n   * @return {Node | Node[]} Returns `node` with variables recursively substituted.\n   * @throws {ReferenceError}\n   *     If there is a cyclic dependency among the variables in `scope`,\n   *     resolution is impossible and a ReferenceError is thrown.\n   */\n  function _resolve(node, scope) {\n    var within = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n    // note `within`:\n    // `within` is not documented, since it is for internal cycle\n    // detection only\n    if (!scope) {\n      return node;\n    }\n    if ((0, _is.isSymbolNode)(node)) {\n      if (within.has(node.name)) {\n        var variables = Array.from(within).join(', ');\n        throw new ReferenceError(\"recursive loop of variable definitions among {\".concat(variables, \"}\"));\n      }\n      var value = scope.get(node.name);\n      if ((0, _is.isNode)(value)) {\n        var nextWithin = new Set(within);\n        nextWithin.add(node.name);\n        return _resolve(value, scope, nextWithin);\n      } else if (typeof value === 'number') {\n        return parse(String(value));\n      } else if (value !== undefined) {\n        return new ConstantNode(value);\n      } else {\n        return node;\n      }\n    } else if ((0, _is.isOperatorNode)(node)) {\n      var args = node.args.map(function (arg) {\n        return _resolve(arg, scope, within);\n      });\n      return new OperatorNode(node.op, node.fn, args, node.implicit);\n    } else if ((0, _is.isParenthesisNode)(node)) {\n      return new ParenthesisNode(_resolve(node.content, scope, within));\n    } else if ((0, _is.isFunctionNode)(node)) {\n      var _args = node.args.map(function (arg) {\n        return _resolve(arg, scope, within);\n      });\n      return new FunctionNode(node.name, _args);\n    }\n\n    // Otherwise just recursively resolve any children (might also work\n    // for some of the above special cases)\n    return node.map(function (child) {\n      return _resolve(child, scope, within);\n    });\n  }\n  return typed('resolve', {\n    Node: _resolve,\n    'Node, Map | null | undefined': _resolve,\n    'Node, Object': function NodeObject(n, scope) {\n      return _resolve(n, (0, _map.createMap)(scope));\n    },\n    // For arrays and matrices, we map `self` rather than `_resolve`\n    // because resolve is fairly expensive anyway, and this way\n    // we get nice error messages if one entry in the array has wrong type.\n    'Array | Matrix': typed.referToSelf(function (self) {\n      return function (A) {\n        return A.map(function (n) {\n          return self(n);\n        });\n      };\n    }),\n    'Array | Matrix, null | undefined': typed.referToSelf(function (self) {\n      return function (A) {\n        return A.map(function (n) {\n          return self(n);\n        });\n      };\n    }),\n    'Array, Object': typed.referTo('Array,Map', function (selfAM) {\n      return function (A, scope) {\n        return selfAM(A, (0, _map.createMap)(scope));\n      };\n    }),\n    'Matrix, Object': typed.referTo('Matrix,Map', function (selfMM) {\n      return function (A, scope) {\n        return selfMM(A, (0, _map.createMap)(scope));\n      };\n    }),\n    'Array | Matrix, Map': typed.referToSelf(function (self) {\n      return function (A, scope) {\n        return A.map(function (n) {\n          return self(n, scope);\n        });\n      };\n    })\n  });\n});\nexports.createResolve = createResolve;","map":{"version":3,"names":["Object","defineProperty","exports","value","createResolve","_map","require","_is","_factory","name","dependencies","factory","_ref","typed","parse","ConstantNode","FunctionNode","OperatorNode","ParenthesisNode","_resolve","node","scope","within","arguments","length","undefined","Set","isSymbolNode","has","variables","Array","from","join","ReferenceError","concat","get","isNode","nextWithin","add","String","isOperatorNode","args","map","arg","op","fn","implicit","isParenthesisNode","content","isFunctionNode","_args","child","Node","NodeObject","n","createMap","referToSelf","self","A","referTo","selfAM","selfMM"],"sources":["C:/Users/Admin/Desktop/React-Web-main/node_modules/mathjs/lib/cjs/function/algebra/resolve.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createResolve = void 0;\nvar _map = require(\"../../utils/map.js\");\nvar _is = require(\"../../utils/is.js\");\nvar _factory = require(\"../../utils/factory.js\");\nvar name = 'resolve';\nvar dependencies = ['typed', 'parse', 'ConstantNode', 'FunctionNode', 'OperatorNode', 'ParenthesisNode'];\nvar createResolve = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n    parse = _ref.parse,\n    ConstantNode = _ref.ConstantNode,\n    FunctionNode = _ref.FunctionNode,\n    OperatorNode = _ref.OperatorNode,\n    ParenthesisNode = _ref.ParenthesisNode;\n  /**\n   * resolve(expr, scope) replaces variable nodes with their scoped values\n   *\n   * Syntax:\n   *\n   *     resolve(expr, scope)\n   *\n   * Examples:\n   *\n   *     math.resolve('x + y', {x:1, y:2})           // Node '1 + 2'\n   *     math.resolve(math.parse('x+y'), {x:1, y:2}) // Node '1 + 2'\n   *     math.simplify('x+y', {x:2, y: math.parse('x+x')}).toString() // \"6\"\n   *\n   * See also:\n   *\n   *     simplify, evaluate\n   *\n   * @param {Node | Node[]} node\n   *     The expression tree (or trees) to be simplified\n   * @param {Object} scope\n   *     Scope specifying variables to be resolved\n   * @return {Node | Node[]} Returns `node` with variables recursively substituted.\n   * @throws {ReferenceError}\n   *     If there is a cyclic dependency among the variables in `scope`,\n   *     resolution is impossible and a ReferenceError is thrown.\n   */\n  function _resolve(node, scope) {\n    var within = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n    // note `within`:\n    // `within` is not documented, since it is for internal cycle\n    // detection only\n    if (!scope) {\n      return node;\n    }\n    if ((0, _is.isSymbolNode)(node)) {\n      if (within.has(node.name)) {\n        var variables = Array.from(within).join(', ');\n        throw new ReferenceError(\"recursive loop of variable definitions among {\".concat(variables, \"}\"));\n      }\n      var value = scope.get(node.name);\n      if ((0, _is.isNode)(value)) {\n        var nextWithin = new Set(within);\n        nextWithin.add(node.name);\n        return _resolve(value, scope, nextWithin);\n      } else if (typeof value === 'number') {\n        return parse(String(value));\n      } else if (value !== undefined) {\n        return new ConstantNode(value);\n      } else {\n        return node;\n      }\n    } else if ((0, _is.isOperatorNode)(node)) {\n      var args = node.args.map(function (arg) {\n        return _resolve(arg, scope, within);\n      });\n      return new OperatorNode(node.op, node.fn, args, node.implicit);\n    } else if ((0, _is.isParenthesisNode)(node)) {\n      return new ParenthesisNode(_resolve(node.content, scope, within));\n    } else if ((0, _is.isFunctionNode)(node)) {\n      var _args = node.args.map(function (arg) {\n        return _resolve(arg, scope, within);\n      });\n      return new FunctionNode(node.name, _args);\n    }\n\n    // Otherwise just recursively resolve any children (might also work\n    // for some of the above special cases)\n    return node.map(function (child) {\n      return _resolve(child, scope, within);\n    });\n  }\n  return typed('resolve', {\n    Node: _resolve,\n    'Node, Map | null | undefined': _resolve,\n    'Node, Object': function NodeObject(n, scope) {\n      return _resolve(n, (0, _map.createMap)(scope));\n    },\n    // For arrays and matrices, we map `self` rather than `_resolve`\n    // because resolve is fairly expensive anyway, and this way\n    // we get nice error messages if one entry in the array has wrong type.\n    'Array | Matrix': typed.referToSelf(function (self) {\n      return function (A) {\n        return A.map(function (n) {\n          return self(n);\n        });\n      };\n    }),\n    'Array | Matrix, null | undefined': typed.referToSelf(function (self) {\n      return function (A) {\n        return A.map(function (n) {\n          return self(n);\n        });\n      };\n    }),\n    'Array, Object': typed.referTo('Array,Map', function (selfAM) {\n      return function (A, scope) {\n        return selfAM(A, (0, _map.createMap)(scope));\n      };\n    }),\n    'Matrix, Object': typed.referTo('Matrix,Map', function (selfMM) {\n      return function (A, scope) {\n        return selfMM(A, (0, _map.createMap)(scope));\n      };\n    }),\n    'Array | Matrix, Map': typed.referToSelf(function (self) {\n      return function (A, scope) {\n        return A.map(function (n) {\n          return self(n, scope);\n        });\n      };\n    })\n  });\n});\nexports.createResolve = createResolve;"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,aAAa,GAAG,KAAK,CAAC;AAC9B,IAAIC,IAAI,GAAGC,OAAO,CAAC,oBAAoB,CAAC;AACxC,IAAIC,GAAG,GAAGD,OAAO,CAAC,mBAAmB,CAAC;AACtC,IAAIE,QAAQ,GAAGF,OAAO,CAAC,wBAAwB,CAAC;AAChD,IAAIG,IAAI,GAAG,SAAS;AACpB,IAAIC,YAAY,GAAG,CAAC,OAAO,EAAE,OAAO,EAAE,cAAc,EAAE,cAAc,EAAE,cAAc,EAAE,iBAAiB,CAAC;AACxG,IAAIN,aAAa,GAAG,eAAe,CAAC,CAAC,EAAEI,QAAQ,CAACG,OAAO,EAAEF,IAAI,EAAEC,YAAY,EAAE,UAAUE,IAAI,EAAE;EAC3F,IAAIC,KAAK,GAAGD,IAAI,CAACC,KAAK;IACpBC,KAAK,GAAGF,IAAI,CAACE,KAAK;IAClBC,YAAY,GAAGH,IAAI,CAACG,YAAY;IAChCC,YAAY,GAAGJ,IAAI,CAACI,YAAY;IAChCC,YAAY,GAAGL,IAAI,CAACK,YAAY;IAChCC,eAAe,GAAGN,IAAI,CAACM,eAAe;EACxC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASC,QAAQ,CAACC,IAAI,EAAEC,KAAK,EAAE;IAC7B,IAAIC,MAAM,GAAGC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,IAAIG,GAAG,EAAE;IAC1F;IACA;IACA;IACA,IAAI,CAACL,KAAK,EAAE;MACV,OAAOD,IAAI;IACb;IACA,IAAI,CAAC,CAAC,EAAEb,GAAG,CAACoB,YAAY,EAAEP,IAAI,CAAC,EAAE;MAC/B,IAAIE,MAAM,CAACM,GAAG,CAACR,IAAI,CAACX,IAAI,CAAC,EAAE;QACzB,IAAIoB,SAAS,GAAGC,KAAK,CAACC,IAAI,CAACT,MAAM,CAAC,CAACU,IAAI,CAAC,IAAI,CAAC;QAC7C,MAAM,IAAIC,cAAc,CAAC,gDAAgD,CAACC,MAAM,CAACL,SAAS,EAAE,GAAG,CAAC,CAAC;MACnG;MACA,IAAI1B,KAAK,GAAGkB,KAAK,CAACc,GAAG,CAACf,IAAI,CAACX,IAAI,CAAC;MAChC,IAAI,CAAC,CAAC,EAAEF,GAAG,CAAC6B,MAAM,EAAEjC,KAAK,CAAC,EAAE;QAC1B,IAAIkC,UAAU,GAAG,IAAIX,GAAG,CAACJ,MAAM,CAAC;QAChCe,UAAU,CAACC,GAAG,CAAClB,IAAI,CAACX,IAAI,CAAC;QACzB,OAAOU,QAAQ,CAAChB,KAAK,EAAEkB,KAAK,EAAEgB,UAAU,CAAC;MAC3C,CAAC,MAAM,IAAI,OAAOlC,KAAK,KAAK,QAAQ,EAAE;QACpC,OAAOW,KAAK,CAACyB,MAAM,CAACpC,KAAK,CAAC,CAAC;MAC7B,CAAC,MAAM,IAAIA,KAAK,KAAKsB,SAAS,EAAE;QAC9B,OAAO,IAAIV,YAAY,CAACZ,KAAK,CAAC;MAChC,CAAC,MAAM;QACL,OAAOiB,IAAI;MACb;IACF,CAAC,MAAM,IAAI,CAAC,CAAC,EAAEb,GAAG,CAACiC,cAAc,EAAEpB,IAAI,CAAC,EAAE;MACxC,IAAIqB,IAAI,GAAGrB,IAAI,CAACqB,IAAI,CAACC,GAAG,CAAC,UAAUC,GAAG,EAAE;QACtC,OAAOxB,QAAQ,CAACwB,GAAG,EAAEtB,KAAK,EAAEC,MAAM,CAAC;MACrC,CAAC,CAAC;MACF,OAAO,IAAIL,YAAY,CAACG,IAAI,CAACwB,EAAE,EAAExB,IAAI,CAACyB,EAAE,EAAEJ,IAAI,EAAErB,IAAI,CAAC0B,QAAQ,CAAC;IAChE,CAAC,MAAM,IAAI,CAAC,CAAC,EAAEvC,GAAG,CAACwC,iBAAiB,EAAE3B,IAAI,CAAC,EAAE;MAC3C,OAAO,IAAIF,eAAe,CAACC,QAAQ,CAACC,IAAI,CAAC4B,OAAO,EAAE3B,KAAK,EAAEC,MAAM,CAAC,CAAC;IACnE,CAAC,MAAM,IAAI,CAAC,CAAC,EAAEf,GAAG,CAAC0C,cAAc,EAAE7B,IAAI,CAAC,EAAE;MACxC,IAAI8B,KAAK,GAAG9B,IAAI,CAACqB,IAAI,CAACC,GAAG,CAAC,UAAUC,GAAG,EAAE;QACvC,OAAOxB,QAAQ,CAACwB,GAAG,EAAEtB,KAAK,EAAEC,MAAM,CAAC;MACrC,CAAC,CAAC;MACF,OAAO,IAAIN,YAAY,CAACI,IAAI,CAACX,IAAI,EAAEyC,KAAK,CAAC;IAC3C;;IAEA;IACA;IACA,OAAO9B,IAAI,CAACsB,GAAG,CAAC,UAAUS,KAAK,EAAE;MAC/B,OAAOhC,QAAQ,CAACgC,KAAK,EAAE9B,KAAK,EAAEC,MAAM,CAAC;IACvC,CAAC,CAAC;EACJ;EACA,OAAOT,KAAK,CAAC,SAAS,EAAE;IACtBuC,IAAI,EAAEjC,QAAQ;IACd,8BAA8B,EAAEA,QAAQ;IACxC,cAAc,EAAE,SAASkC,UAAU,CAACC,CAAC,EAAEjC,KAAK,EAAE;MAC5C,OAAOF,QAAQ,CAACmC,CAAC,EAAE,CAAC,CAAC,EAAEjD,IAAI,CAACkD,SAAS,EAAElC,KAAK,CAAC,CAAC;IAChD,CAAC;IACD;IACA;IACA;IACA,gBAAgB,EAAER,KAAK,CAAC2C,WAAW,CAAC,UAAUC,IAAI,EAAE;MAClD,OAAO,UAAUC,CAAC,EAAE;QAClB,OAAOA,CAAC,CAAChB,GAAG,CAAC,UAAUY,CAAC,EAAE;UACxB,OAAOG,IAAI,CAACH,CAAC,CAAC;QAChB,CAAC,CAAC;MACJ,CAAC;IACH,CAAC,CAAC;IACF,kCAAkC,EAAEzC,KAAK,CAAC2C,WAAW,CAAC,UAAUC,IAAI,EAAE;MACpE,OAAO,UAAUC,CAAC,EAAE;QAClB,OAAOA,CAAC,CAAChB,GAAG,CAAC,UAAUY,CAAC,EAAE;UACxB,OAAOG,IAAI,CAACH,CAAC,CAAC;QAChB,CAAC,CAAC;MACJ,CAAC;IACH,CAAC,CAAC;IACF,eAAe,EAAEzC,KAAK,CAAC8C,OAAO,CAAC,WAAW,EAAE,UAAUC,MAAM,EAAE;MAC5D,OAAO,UAAUF,CAAC,EAAErC,KAAK,EAAE;QACzB,OAAOuC,MAAM,CAACF,CAAC,EAAE,CAAC,CAAC,EAAErD,IAAI,CAACkD,SAAS,EAAElC,KAAK,CAAC,CAAC;MAC9C,CAAC;IACH,CAAC,CAAC;IACF,gBAAgB,EAAER,KAAK,CAAC8C,OAAO,CAAC,YAAY,EAAE,UAAUE,MAAM,EAAE;MAC9D,OAAO,UAAUH,CAAC,EAAErC,KAAK,EAAE;QACzB,OAAOwC,MAAM,CAACH,CAAC,EAAE,CAAC,CAAC,EAAErD,IAAI,CAACkD,SAAS,EAAElC,KAAK,CAAC,CAAC;MAC9C,CAAC;IACH,CAAC,CAAC;IACF,qBAAqB,EAAER,KAAK,CAAC2C,WAAW,CAAC,UAAUC,IAAI,EAAE;MACvD,OAAO,UAAUC,CAAC,EAAErC,KAAK,EAAE;QACzB,OAAOqC,CAAC,CAAChB,GAAG,CAAC,UAAUY,CAAC,EAAE;UACxB,OAAOG,IAAI,CAACH,CAAC,EAAEjC,KAAK,CAAC;QACvB,CAAC,CAAC;MACJ,CAAC;IACH,CAAC;EACH,CAAC,CAAC;AACJ,CAAC,CAAC;AACFnB,OAAO,CAACE,aAAa,GAAGA,aAAa"},"metadata":{},"sourceType":"script"}