{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createFunctionAssignmentNode = void 0;\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _is = require(\"../../utils/is.js\");\nvar _keywords = require(\"../keywords.js\");\nvar _string = require(\"../../utils/string.js\");\nvar _array = require(\"../../utils/array.js\");\nvar _latex = require(\"../../utils/latex.js\");\nvar _operators = require(\"../operators.js\");\nvar _factory = require(\"../../utils/factory.js\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2[\"default\"])(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return (0, _possibleConstructorReturn2[\"default\"])(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar name = 'FunctionAssignmentNode';\nvar dependencies = ['typed', 'Node'];\nvar createFunctionAssignmentNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n    Node = _ref.Node;\n  /**\n   * Is parenthesis needed?\n   * @param {Node} node\n   * @param {Object} parenthesis\n   * @param {string} implicit\n   * @private\n   */\n  function needParenthesis(node, parenthesis, implicit) {\n    var precedence = (0, _operators.getPrecedence)(node, parenthesis, implicit);\n    var exprPrecedence = (0, _operators.getPrecedence)(node.expr, parenthesis, implicit);\n    return parenthesis === 'all' || exprPrecedence !== null && exprPrecedence <= precedence;\n  }\n  var FunctionAssignmentNode = /*#__PURE__*/function (_Node) {\n    (0, _inherits2[\"default\"])(FunctionAssignmentNode, _Node);\n    var _super = _createSuper(FunctionAssignmentNode);\n    /**\n     * @constructor FunctionAssignmentNode\n     * @extends {Node}\n     * Function assignment\n     *\n     * @param {string} name           Function name\n     * @param {string[] | Array.<{name: string, type: string}>} params\n     *                                Array with function parameter names, or an\n     *                                array with objects containing the name\n     *                                and type of the parameter\n     * @param {Node} expr             The function expression\n     */\n    function FunctionAssignmentNode(name, params, expr) {\n      var _this;\n      (0, _classCallCheck2[\"default\"])(this, FunctionAssignmentNode);\n      _this = _super.call(this);\n      // validate input\n      if (typeof name !== 'string') {\n        throw new TypeError('String expected for parameter \"name\"');\n      }\n      if (!Array.isArray(params)) {\n        throw new TypeError('Array containing strings or objects expected for parameter \"params\"');\n      }\n      if (!(0, _is.isNode)(expr)) {\n        throw new TypeError('Node expected for parameter \"expr\"');\n      }\n      if (_keywords.keywords.has(name)) {\n        throw new Error('Illegal function name, \"' + name + '\" is a reserved keyword');\n      }\n      var paramNames = new Set();\n      var _iterator = _createForOfIteratorHelper(params),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var param = _step.value;\n          var _name = typeof param === 'string' ? param : param.name;\n          if (paramNames.has(_name)) {\n            throw new Error(\"Duplicate parameter name \\\"\".concat(_name, \"\\\"\"));\n          } else {\n            paramNames.add(_name);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      _this.name = name;\n      _this.params = params.map(function (param) {\n        return param && param.name || param;\n      });\n      _this.types = params.map(function (param) {\n        return param && param.type || 'any';\n      });\n      _this.expr = expr;\n      return _this;\n    }\n    (0, _createClass2[\"default\"])(FunctionAssignmentNode, [{\n      key: \"type\",\n      get: function get() {\n        return name;\n      }\n    }, {\n      key: \"isFunctionAssignmentNode\",\n      get: function get() {\n        return true;\n      }\n\n      /**\n       * Compile a node into a JavaScript function.\n       * This basically pre-calculates as much as possible and only leaves open\n       * calculations which depend on a dynamic scope with variables.\n       * @param {Object} math     Math.js namespace with functions and constants.\n       * @param {Object} argNames An object with argument names as key and `true`\n       *                          as value. Used in the SymbolNode to optimize\n       *                          for arguments from user assigned functions\n       *                          (see FunctionAssignmentNode) or special symbols\n       *                          like `end` (see IndexNode).\n       * @return {function} Returns a function which can be called like:\n       *                        evalNode(scope: Object, args: Object, context: *)\n       */\n    }, {\n      key: \"_compile\",\n      value: function _compile(math, argNames) {\n        var childArgNames = Object.create(argNames);\n        (0, _array.forEach)(this.params, function (param) {\n          childArgNames[param] = true;\n        });\n\n        // compile the function expression with the child args\n        var evalExpr = this.expr._compile(math, childArgNames);\n        var name = this.name;\n        var params = this.params;\n        var signature = (0, _array.join)(this.types, ',');\n        var syntax = name + '(' + (0, _array.join)(this.params, ', ') + ')';\n        return function evalFunctionAssignmentNode(scope, args, context) {\n          var signatures = {};\n          signatures[signature] = function () {\n            var childArgs = Object.create(args);\n            for (var i = 0; i < params.length; i++) {\n              childArgs[params[i]] = arguments[i];\n            }\n            return evalExpr(scope, childArgs, context);\n          };\n          var fn = typed(name, signatures);\n          fn.syntax = syntax;\n          scope.set(name, fn);\n          return fn;\n        };\n      }\n\n      /**\n       * Execute a callback for each of the child nodes of this node\n       * @param {function(child: Node, path: string, parent: Node)} callback\n       */\n    }, {\n      key: \"forEach\",\n      value: function forEach(callback) {\n        callback(this.expr, 'expr', this);\n      }\n\n      /**\n       * Create a new FunctionAssignmentNode whose children are the results of\n       * calling the provided callback function for each child of the original\n       * node.\n       * @param {function(child: Node, path: string, parent: Node): Node} callback\n       * @returns {FunctionAssignmentNode} Returns a transformed copy of the node\n       */\n    }, {\n      key: \"map\",\n      value: function map(callback) {\n        var expr = this._ifNode(callback(this.expr, 'expr', this));\n        return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);\n      }\n\n      /**\n       * Create a clone of this node, a shallow copy\n       * @return {FunctionAssignmentNode}\n       */\n    }, {\n      key: \"clone\",\n      value: function clone() {\n        return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);\n      }\n\n      /**\n       * get string representation\n       * @param {Object} options\n       * @return {string} str\n       */\n    }, {\n      key: \"_toString\",\n      value: function _toString(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var expr = this.expr.toString(options);\n        if (needParenthesis(this, parenthesis, options && options.implicit)) {\n          expr = '(' + expr + ')';\n        }\n        return this.name + '(' + this.params.join(', ') + ') = ' + expr;\n      }\n\n      /**\n       * Get a JSON representation of the node\n       * @returns {Object}\n       */\n    }, {\n      key: \"toJSON\",\n      value: function toJSON() {\n        var types = this.types;\n        return {\n          mathjs: name,\n          name: this.name,\n          params: this.params.map(function (param, index) {\n            return {\n              name: param,\n              type: types[index]\n            };\n          }),\n          expr: this.expr\n        };\n      }\n\n      /**\n       * Instantiate an FunctionAssignmentNode from its JSON representation\n       * @param {Object} json\n       *     An object structured like\n       *     ```\n       *     {\"mathjs\": \"FunctionAssignmentNode\",\n       *      name: ..., params: ..., expr: ...}\n       *     ```\n       *     where mathjs is optional\n       * @returns {FunctionAssignmentNode}\n       */\n    }, {\n      key: \"toHTML\",\n      value:\n      /**\n       * get HTML representation\n       * @param {Object} options\n       * @return {string} str\n       */\n      function toHTML(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var params = [];\n        for (var i = 0; i < this.params.length; i++) {\n          params.push('<span class=\"math-symbol math-parameter\">' + (0, _string.escape)(this.params[i]) + '</span>');\n        }\n        var expr = this.expr.toHTML(options);\n        if (needParenthesis(this, parenthesis, options && options.implicit)) {\n          expr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + expr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n        return '<span class=\"math-function\">' + (0, _string.escape)(this.name) + '</span>' + '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + params.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>' + '<span class=\"math-operator math-assignment-operator ' + 'math-variable-assignment-operator math-binary-operator\">=</span>' + expr;\n      }\n\n      /**\n       * get LaTeX representation\n       * @param {Object} options\n       * @return {string} str\n       */\n    }, {\n      key: \"_toTex\",\n      value: function _toTex(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var expr = this.expr.toTex(options);\n        if (needParenthesis(this, parenthesis, options && options.implicit)) {\n          expr = \"\\\\left(\".concat(expr, \"\\\\right)\");\n        }\n        return '\\\\mathrm{' + this.name + '}\\\\left(' + this.params.map(_latex.toSymbol).join(',') + '\\\\right):=' + expr;\n      }\n    }], [{\n      key: \"fromJSON\",\n      value: function fromJSON(json) {\n        return new FunctionAssignmentNode(json.name, json.params, json.expr);\n      }\n    }]);\n    return FunctionAssignmentNode;\n  }(Node);\n  (0, _defineProperty2[\"default\"])(FunctionAssignmentNode, \"name\", name);\n  return FunctionAssignmentNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createFunctionAssignmentNode = createFunctionAssignmentNode;","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","createFunctionAssignmentNode","_classCallCheck2","_createClass2","_inherits2","_possibleConstructorReturn2","_getPrototypeOf2","_defineProperty2","_is","_keywords","_string","_array","_latex","_operators","_factory","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","length","i","F","s","n","done","e","_e","f","TypeError","normalCompletion","didErr","err","call","step","next","_e2","minLen","_arrayLikeToArray","prototype","toString","slice","constructor","name","from","test","arr","len","arr2","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","Reflect","construct","arguments","apply","sham","Proxy","Boolean","valueOf","dependencies","factory","_ref","typed","Node","needParenthesis","node","parenthesis","implicit","precedence","getPrecedence","exprPrecedence","expr","FunctionAssignmentNode","_Node","_super","params","_this","isNode","keywords","has","Error","paramNames","Set","_iterator","_step","param","_name","concat","add","map","types","type","key","get","_compile","math","argNames","childArgNames","create","forEach","evalExpr","signature","join","syntax","evalFunctionAssignmentNode","scope","args","context","signatures","childArgs","fn","set","callback","_ifNode","clone","_toString","options","toJSON","mathjs","index","toHTML","push","escape","_toTex","toTex","toSymbol","fromJSON","json","isClass"],"sources":["C:/Users/Admin/Desktop/React-Web-main/node_modules/mathjs/lib/cjs/expression/node/FunctionAssignmentNode.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createFunctionAssignmentNode = void 0;\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _is = require(\"../../utils/is.js\");\nvar _keywords = require(\"../keywords.js\");\nvar _string = require(\"../../utils/string.js\");\nvar _array = require(\"../../utils/array.js\");\nvar _latex = require(\"../../utils/latex.js\");\nvar _operators = require(\"../operators.js\");\nvar _factory = require(\"../../utils/factory.js\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2[\"default\"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2[\"default\"])(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nvar name = 'FunctionAssignmentNode';\nvar dependencies = ['typed', 'Node'];\nvar createFunctionAssignmentNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n    Node = _ref.Node;\n  /**\n   * Is parenthesis needed?\n   * @param {Node} node\n   * @param {Object} parenthesis\n   * @param {string} implicit\n   * @private\n   */\n  function needParenthesis(node, parenthesis, implicit) {\n    var precedence = (0, _operators.getPrecedence)(node, parenthesis, implicit);\n    var exprPrecedence = (0, _operators.getPrecedence)(node.expr, parenthesis, implicit);\n    return parenthesis === 'all' || exprPrecedence !== null && exprPrecedence <= precedence;\n  }\n  var FunctionAssignmentNode = /*#__PURE__*/function (_Node) {\n    (0, _inherits2[\"default\"])(FunctionAssignmentNode, _Node);\n    var _super = _createSuper(FunctionAssignmentNode);\n    /**\n     * @constructor FunctionAssignmentNode\n     * @extends {Node}\n     * Function assignment\n     *\n     * @param {string} name           Function name\n     * @param {string[] | Array.<{name: string, type: string}>} params\n     *                                Array with function parameter names, or an\n     *                                array with objects containing the name\n     *                                and type of the parameter\n     * @param {Node} expr             The function expression\n     */\n    function FunctionAssignmentNode(name, params, expr) {\n      var _this;\n      (0, _classCallCheck2[\"default\"])(this, FunctionAssignmentNode);\n      _this = _super.call(this);\n      // validate input\n      if (typeof name !== 'string') {\n        throw new TypeError('String expected for parameter \"name\"');\n      }\n      if (!Array.isArray(params)) {\n        throw new TypeError('Array containing strings or objects expected for parameter \"params\"');\n      }\n      if (!(0, _is.isNode)(expr)) {\n        throw new TypeError('Node expected for parameter \"expr\"');\n      }\n      if (_keywords.keywords.has(name)) {\n        throw new Error('Illegal function name, \"' + name + '\" is a reserved keyword');\n      }\n      var paramNames = new Set();\n      var _iterator = _createForOfIteratorHelper(params),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var param = _step.value;\n          var _name = typeof param === 'string' ? param : param.name;\n          if (paramNames.has(_name)) {\n            throw new Error(\"Duplicate parameter name \\\"\".concat(_name, \"\\\"\"));\n          } else {\n            paramNames.add(_name);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      _this.name = name;\n      _this.params = params.map(function (param) {\n        return param && param.name || param;\n      });\n      _this.types = params.map(function (param) {\n        return param && param.type || 'any';\n      });\n      _this.expr = expr;\n      return _this;\n    }\n    (0, _createClass2[\"default\"])(FunctionAssignmentNode, [{\n      key: \"type\",\n      get: function get() {\n        return name;\n      }\n    }, {\n      key: \"isFunctionAssignmentNode\",\n      get: function get() {\n        return true;\n      }\n\n      /**\n       * Compile a node into a JavaScript function.\n       * This basically pre-calculates as much as possible and only leaves open\n       * calculations which depend on a dynamic scope with variables.\n       * @param {Object} math     Math.js namespace with functions and constants.\n       * @param {Object} argNames An object with argument names as key and `true`\n       *                          as value. Used in the SymbolNode to optimize\n       *                          for arguments from user assigned functions\n       *                          (see FunctionAssignmentNode) or special symbols\n       *                          like `end` (see IndexNode).\n       * @return {function} Returns a function which can be called like:\n       *                        evalNode(scope: Object, args: Object, context: *)\n       */\n    }, {\n      key: \"_compile\",\n      value: function _compile(math, argNames) {\n        var childArgNames = Object.create(argNames);\n        (0, _array.forEach)(this.params, function (param) {\n          childArgNames[param] = true;\n        });\n\n        // compile the function expression with the child args\n        var evalExpr = this.expr._compile(math, childArgNames);\n        var name = this.name;\n        var params = this.params;\n        var signature = (0, _array.join)(this.types, ',');\n        var syntax = name + '(' + (0, _array.join)(this.params, ', ') + ')';\n        return function evalFunctionAssignmentNode(scope, args, context) {\n          var signatures = {};\n          signatures[signature] = function () {\n            var childArgs = Object.create(args);\n            for (var i = 0; i < params.length; i++) {\n              childArgs[params[i]] = arguments[i];\n            }\n            return evalExpr(scope, childArgs, context);\n          };\n          var fn = typed(name, signatures);\n          fn.syntax = syntax;\n          scope.set(name, fn);\n          return fn;\n        };\n      }\n\n      /**\n       * Execute a callback for each of the child nodes of this node\n       * @param {function(child: Node, path: string, parent: Node)} callback\n       */\n    }, {\n      key: \"forEach\",\n      value: function forEach(callback) {\n        callback(this.expr, 'expr', this);\n      }\n\n      /**\n       * Create a new FunctionAssignmentNode whose children are the results of\n       * calling the provided callback function for each child of the original\n       * node.\n       * @param {function(child: Node, path: string, parent: Node): Node} callback\n       * @returns {FunctionAssignmentNode} Returns a transformed copy of the node\n       */\n    }, {\n      key: \"map\",\n      value: function map(callback) {\n        var expr = this._ifNode(callback(this.expr, 'expr', this));\n        return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);\n      }\n\n      /**\n       * Create a clone of this node, a shallow copy\n       * @return {FunctionAssignmentNode}\n       */\n    }, {\n      key: \"clone\",\n      value: function clone() {\n        return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);\n      }\n\n      /**\n       * get string representation\n       * @param {Object} options\n       * @return {string} str\n       */\n    }, {\n      key: \"_toString\",\n      value: function _toString(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var expr = this.expr.toString(options);\n        if (needParenthesis(this, parenthesis, options && options.implicit)) {\n          expr = '(' + expr + ')';\n        }\n        return this.name + '(' + this.params.join(', ') + ') = ' + expr;\n      }\n\n      /**\n       * Get a JSON representation of the node\n       * @returns {Object}\n       */\n    }, {\n      key: \"toJSON\",\n      value: function toJSON() {\n        var types = this.types;\n        return {\n          mathjs: name,\n          name: this.name,\n          params: this.params.map(function (param, index) {\n            return {\n              name: param,\n              type: types[index]\n            };\n          }),\n          expr: this.expr\n        };\n      }\n\n      /**\n       * Instantiate an FunctionAssignmentNode from its JSON representation\n       * @param {Object} json\n       *     An object structured like\n       *     ```\n       *     {\"mathjs\": \"FunctionAssignmentNode\",\n       *      name: ..., params: ..., expr: ...}\n       *     ```\n       *     where mathjs is optional\n       * @returns {FunctionAssignmentNode}\n       */\n    }, {\n      key: \"toHTML\",\n      value:\n      /**\n       * get HTML representation\n       * @param {Object} options\n       * @return {string} str\n       */\n      function toHTML(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var params = [];\n        for (var i = 0; i < this.params.length; i++) {\n          params.push('<span class=\"math-symbol math-parameter\">' + (0, _string.escape)(this.params[i]) + '</span>');\n        }\n        var expr = this.expr.toHTML(options);\n        if (needParenthesis(this, parenthesis, options && options.implicit)) {\n          expr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + expr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n        return '<span class=\"math-function\">' + (0, _string.escape)(this.name) + '</span>' + '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + params.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>' + '<span class=\"math-operator math-assignment-operator ' + 'math-variable-assignment-operator math-binary-operator\">=</span>' + expr;\n      }\n\n      /**\n       * get LaTeX representation\n       * @param {Object} options\n       * @return {string} str\n       */\n    }, {\n      key: \"_toTex\",\n      value: function _toTex(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var expr = this.expr.toTex(options);\n        if (needParenthesis(this, parenthesis, options && options.implicit)) {\n          expr = \"\\\\left(\".concat(expr, \"\\\\right)\");\n        }\n        return '\\\\mathrm{' + this.name + '}\\\\left(' + this.params.map(_latex.toSymbol).join(',') + '\\\\right):=' + expr;\n      }\n    }], [{\n      key: \"fromJSON\",\n      value: function fromJSON(json) {\n        return new FunctionAssignmentNode(json.name, json.params, json.expr);\n      }\n    }]);\n    return FunctionAssignmentNode;\n  }(Node);\n  (0, _defineProperty2[\"default\"])(FunctionAssignmentNode, \"name\", name);\n  return FunctionAssignmentNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createFunctionAssignmentNode = createFunctionAssignmentNode;"],"mappings":"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"},"metadata":{},"sourceType":"script"}