{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createUtil = void 0;\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _is = require(\"../../../utils/is.js\");\nvar _factory = require(\"../../../utils/factory.js\");\nvar _object = require(\"../../../utils/object.js\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      (0, _defineProperty2[\"default\"])(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nvar name = 'simplifyUtil';\nvar dependencies = ['FunctionNode', 'OperatorNode', 'SymbolNode'];\nvar createUtil = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var FunctionNode = _ref.FunctionNode,\n    OperatorNode = _ref.OperatorNode,\n    SymbolNode = _ref.SymbolNode;\n  // TODO commutative/associative properties rely on the arguments\n  // e.g. multiply is not commutative for matrices\n  // The properties should be calculated from an argument to simplify, or possibly something in math.config\n  // the other option is for typed() to specify a return type so that we can evaluate the type of arguments\n\n  /* So that properties of an operator fit on one line: */\n  var T = true;\n  var F = false;\n  var defaultName = 'defaultF';\n  var defaultContext = {\n    /*      */add: {\n      trivial: T,\n      total: T,\n      commutative: T,\n      associative: T\n    },\n    /**/unaryPlus: {\n      trivial: T,\n      total: T,\n      commutative: T,\n      associative: T\n    },\n    /* */subtract: {\n      trivial: F,\n      total: T,\n      commutative: F,\n      associative: F\n    },\n    /* */multiply: {\n      trivial: T,\n      total: T,\n      commutative: T,\n      associative: T\n    },\n    /*   */divide: {\n      trivial: F,\n      total: T,\n      commutative: F,\n      associative: F\n    },\n    /*    */paren: {\n      trivial: T,\n      total: T,\n      commutative: T,\n      associative: F\n    },\n    /* */defaultF: {\n      trivial: F,\n      total: T,\n      commutative: F,\n      associative: F\n    }\n  };\n  var realContext = {\n    divide: {\n      total: F\n    },\n    log: {\n      total: F\n    }\n  };\n  var positiveContext = {\n    subtract: {\n      total: F\n    },\n    abs: {\n      trivial: T\n    },\n    log: {\n      total: T\n    }\n  };\n  function hasProperty(nodeOrName, property) {\n    var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultContext;\n    var name = defaultName;\n    if (typeof nodeOrName === 'string') {\n      name = nodeOrName;\n    } else if ((0, _is.isOperatorNode)(nodeOrName)) {\n      name = nodeOrName.fn.toString();\n    } else if ((0, _is.isFunctionNode)(nodeOrName)) {\n      name = nodeOrName.name;\n    } else if ((0, _is.isParenthesisNode)(nodeOrName)) {\n      name = 'paren';\n    }\n    if ((0, _object.hasOwnProperty)(context, name)) {\n      var properties = context[name];\n      if ((0, _object.hasOwnProperty)(properties, property)) {\n        return properties[property];\n      }\n      if ((0, _object.hasOwnProperty)(defaultContext, name)) {\n        return defaultContext[name][property];\n      }\n    }\n    if ((0, _object.hasOwnProperty)(context, defaultName)) {\n      var _properties = context[defaultName];\n      if ((0, _object.hasOwnProperty)(_properties, property)) {\n        return _properties[property];\n      }\n      return defaultContext[defaultName][property];\n    }\n    /* name not found in context and context has no global default */\n    /* So use default context. */\n    if ((0, _object.hasOwnProperty)(defaultContext, name)) {\n      var _properties2 = defaultContext[name];\n      if ((0, _object.hasOwnProperty)(_properties2, property)) {\n        return _properties2[property];\n      }\n    }\n    return defaultContext[defaultName][property];\n  }\n  function isCommutative(node) {\n    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultContext;\n    return hasProperty(node, 'commutative', context);\n  }\n  function isAssociative(node) {\n    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultContext;\n    return hasProperty(node, 'associative', context);\n  }\n\n  /**\n   * Merge the given contexts, with primary overriding secondary\n   * wherever they might conflict\n   */\n  function mergeContext(primary, secondary) {\n    var merged = _objectSpread({}, primary);\n    for (var prop in secondary) {\n      if ((0, _object.hasOwnProperty)(primary, prop)) {\n        merged[prop] = _objectSpread(_objectSpread({}, secondary[prop]), primary[prop]);\n      } else {\n        merged[prop] = secondary[prop];\n      }\n    }\n    return merged;\n  }\n\n  /**\n   * Flatten all associative operators in an expression tree.\n   * Assumes parentheses have already been removed.\n   */\n  function flatten(node, context) {\n    if (!node.args || node.args.length === 0) {\n      return node;\n    }\n    node.args = allChildren(node, context);\n    for (var i = 0; i < node.args.length; i++) {\n      flatten(node.args[i], context);\n    }\n  }\n\n  /**\n   * Get the children of a node as if it has been flattened.\n   * TODO implement for FunctionNodes\n   */\n  function allChildren(node, context) {\n    var op;\n    var children = [];\n    var findChildren = function findChildren(node) {\n      for (var i = 0; i < node.args.length; i++) {\n        var child = node.args[i];\n        if ((0, _is.isOperatorNode)(child) && op === child.op) {\n          findChildren(child);\n        } else {\n          children.push(child);\n        }\n      }\n    };\n    if (isAssociative(node, context)) {\n      op = node.op;\n      findChildren(node);\n      return children;\n    } else {\n      return node.args;\n    }\n  }\n\n  /**\n   *  Unflatten all flattened operators to a right-heavy binary tree.\n   */\n  function unflattenr(node, context) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n    for (var i = 0; i < l; i++) {\n      unflattenr(node.args[i], context);\n    }\n    if (l > 2 && isAssociative(node, context)) {\n      var curnode = node.args.pop();\n      while (node.args.length > 0) {\n        curnode = makeNode([node.args.pop(), curnode]);\n      }\n      node.args = curnode.args;\n    }\n  }\n\n  /**\n   *  Unflatten all flattened operators to a left-heavy binary tree.\n   */\n  function unflattenl(node, context) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n    for (var i = 0; i < l; i++) {\n      unflattenl(node.args[i], context);\n    }\n    if (l > 2 && isAssociative(node, context)) {\n      var curnode = node.args.shift();\n      while (node.args.length > 0) {\n        curnode = makeNode([curnode, node.args.shift()]);\n      }\n      node.args = curnode.args;\n    }\n  }\n  function createMakeNodeFunction(node) {\n    if ((0, _is.isOperatorNode)(node)) {\n      return function (args) {\n        try {\n          return new OperatorNode(node.op, node.fn, args, node.implicit);\n        } catch (err) {\n          console.error(err);\n          return [];\n        }\n      };\n    } else {\n      return function (args) {\n        return new FunctionNode(new SymbolNode(node.name), args);\n      };\n    }\n  }\n  return {\n    createMakeNodeFunction: createMakeNodeFunction,\n    hasProperty: hasProperty,\n    isCommutative: isCommutative,\n    isAssociative: isAssociative,\n    mergeContext: mergeContext,\n    flatten: flatten,\n    allChildren: allChildren,\n    unflattenr: unflattenr,\n    unflattenl: unflattenl,\n    defaultContext: defaultContext,\n    realContext: realContext,\n    positiveContext: positiveContext\n  };\n});\nexports.createUtil = createUtil;","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","createUtil","_defineProperty2","_is","_factory","_object","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","name","dependencies","factory","_ref","FunctionNode","OperatorNode","SymbolNode","T","F","defaultName","defaultContext","add","trivial","total","commutative","associative","unaryPlus","subtract","multiply","divide","paren","defaultF","realContext","log","positiveContext","abs","hasProperty","nodeOrName","property","context","undefined","isOperatorNode","fn","toString","isFunctionNode","isParenthesisNode","hasOwnProperty","properties","_properties","_properties2","isCommutative","node","isAssociative","mergeContext","primary","secondary","merged","prop","flatten","args","allChildren","op","children","findChildren","child","unflattenr","makeNode","createMakeNodeFunction","l","curnode","pop","unflattenl","shift","implicit","err","console","error"],"sources":["C:/Users/Admin/Desktop/React-Web-main/node_modules/mathjs/lib/cjs/function/algebra/simplify/util.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createUtil = void 0;\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _is = require(\"../../../utils/is.js\");\nvar _factory = require(\"../../../utils/factory.js\");\nvar _object = require(\"../../../utils/object.js\");\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar name = 'simplifyUtil';\nvar dependencies = ['FunctionNode', 'OperatorNode', 'SymbolNode'];\nvar createUtil = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var FunctionNode = _ref.FunctionNode,\n    OperatorNode = _ref.OperatorNode,\n    SymbolNode = _ref.SymbolNode;\n  // TODO commutative/associative properties rely on the arguments\n  // e.g. multiply is not commutative for matrices\n  // The properties should be calculated from an argument to simplify, or possibly something in math.config\n  // the other option is for typed() to specify a return type so that we can evaluate the type of arguments\n\n  /* So that properties of an operator fit on one line: */\n  var T = true;\n  var F = false;\n  var defaultName = 'defaultF';\n  var defaultContext = {\n    /*      */add: {\n      trivial: T,\n      total: T,\n      commutative: T,\n      associative: T\n    },\n    /**/unaryPlus: {\n      trivial: T,\n      total: T,\n      commutative: T,\n      associative: T\n    },\n    /* */subtract: {\n      trivial: F,\n      total: T,\n      commutative: F,\n      associative: F\n    },\n    /* */multiply: {\n      trivial: T,\n      total: T,\n      commutative: T,\n      associative: T\n    },\n    /*   */divide: {\n      trivial: F,\n      total: T,\n      commutative: F,\n      associative: F\n    },\n    /*    */paren: {\n      trivial: T,\n      total: T,\n      commutative: T,\n      associative: F\n    },\n    /* */defaultF: {\n      trivial: F,\n      total: T,\n      commutative: F,\n      associative: F\n    }\n  };\n  var realContext = {\n    divide: {\n      total: F\n    },\n    log: {\n      total: F\n    }\n  };\n  var positiveContext = {\n    subtract: {\n      total: F\n    },\n    abs: {\n      trivial: T\n    },\n    log: {\n      total: T\n    }\n  };\n  function hasProperty(nodeOrName, property) {\n    var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultContext;\n    var name = defaultName;\n    if (typeof nodeOrName === 'string') {\n      name = nodeOrName;\n    } else if ((0, _is.isOperatorNode)(nodeOrName)) {\n      name = nodeOrName.fn.toString();\n    } else if ((0, _is.isFunctionNode)(nodeOrName)) {\n      name = nodeOrName.name;\n    } else if ((0, _is.isParenthesisNode)(nodeOrName)) {\n      name = 'paren';\n    }\n    if ((0, _object.hasOwnProperty)(context, name)) {\n      var properties = context[name];\n      if ((0, _object.hasOwnProperty)(properties, property)) {\n        return properties[property];\n      }\n      if ((0, _object.hasOwnProperty)(defaultContext, name)) {\n        return defaultContext[name][property];\n      }\n    }\n    if ((0, _object.hasOwnProperty)(context, defaultName)) {\n      var _properties = context[defaultName];\n      if ((0, _object.hasOwnProperty)(_properties, property)) {\n        return _properties[property];\n      }\n      return defaultContext[defaultName][property];\n    }\n    /* name not found in context and context has no global default */\n    /* So use default context. */\n    if ((0, _object.hasOwnProperty)(defaultContext, name)) {\n      var _properties2 = defaultContext[name];\n      if ((0, _object.hasOwnProperty)(_properties2, property)) {\n        return _properties2[property];\n      }\n    }\n    return defaultContext[defaultName][property];\n  }\n  function isCommutative(node) {\n    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultContext;\n    return hasProperty(node, 'commutative', context);\n  }\n  function isAssociative(node) {\n    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultContext;\n    return hasProperty(node, 'associative', context);\n  }\n\n  /**\n   * Merge the given contexts, with primary overriding secondary\n   * wherever they might conflict\n   */\n  function mergeContext(primary, secondary) {\n    var merged = _objectSpread({}, primary);\n    for (var prop in secondary) {\n      if ((0, _object.hasOwnProperty)(primary, prop)) {\n        merged[prop] = _objectSpread(_objectSpread({}, secondary[prop]), primary[prop]);\n      } else {\n        merged[prop] = secondary[prop];\n      }\n    }\n    return merged;\n  }\n\n  /**\n   * Flatten all associative operators in an expression tree.\n   * Assumes parentheses have already been removed.\n   */\n  function flatten(node, context) {\n    if (!node.args || node.args.length === 0) {\n      return node;\n    }\n    node.args = allChildren(node, context);\n    for (var i = 0; i < node.args.length; i++) {\n      flatten(node.args[i], context);\n    }\n  }\n\n  /**\n   * Get the children of a node as if it has been flattened.\n   * TODO implement for FunctionNodes\n   */\n  function allChildren(node, context) {\n    var op;\n    var children = [];\n    var findChildren = function findChildren(node) {\n      for (var i = 0; i < node.args.length; i++) {\n        var child = node.args[i];\n        if ((0, _is.isOperatorNode)(child) && op === child.op) {\n          findChildren(child);\n        } else {\n          children.push(child);\n        }\n      }\n    };\n    if (isAssociative(node, context)) {\n      op = node.op;\n      findChildren(node);\n      return children;\n    } else {\n      return node.args;\n    }\n  }\n\n  /**\n   *  Unflatten all flattened operators to a right-heavy binary tree.\n   */\n  function unflattenr(node, context) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n    for (var i = 0; i < l; i++) {\n      unflattenr(node.args[i], context);\n    }\n    if (l > 2 && isAssociative(node, context)) {\n      var curnode = node.args.pop();\n      while (node.args.length > 0) {\n        curnode = makeNode([node.args.pop(), curnode]);\n      }\n      node.args = curnode.args;\n    }\n  }\n\n  /**\n   *  Unflatten all flattened operators to a left-heavy binary tree.\n   */\n  function unflattenl(node, context) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n    for (var i = 0; i < l; i++) {\n      unflattenl(node.args[i], context);\n    }\n    if (l > 2 && isAssociative(node, context)) {\n      var curnode = node.args.shift();\n      while (node.args.length > 0) {\n        curnode = makeNode([curnode, node.args.shift()]);\n      }\n      node.args = curnode.args;\n    }\n  }\n  function createMakeNodeFunction(node) {\n    if ((0, _is.isOperatorNode)(node)) {\n      return function (args) {\n        try {\n          return new OperatorNode(node.op, node.fn, args, node.implicit);\n        } catch (err) {\n          console.error(err);\n          return [];\n        }\n      };\n    } else {\n      return function (args) {\n        return new FunctionNode(new SymbolNode(node.name), args);\n      };\n    }\n  }\n  return {\n    createMakeNodeFunction: createMakeNodeFunction,\n    hasProperty: hasProperty,\n    isCommutative: isCommutative,\n    isAssociative: isAssociative,\n    mergeContext: mergeContext,\n    flatten: flatten,\n    allChildren: allChildren,\n    unflattenr: unflattenr,\n    unflattenl: unflattenl,\n    defaultContext: defaultContext,\n    realContext: realContext,\n    positiveContext: positiveContext\n  };\n});\nexports.createUtil = createUtil;"],"mappings":"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"},"metadata":{},"sourceType":"script"}